

// =======================================================
// FILE: src/Core/Enum/TemplateType.cs
// =======================================================
namespace CRM_Vivid.Core.Enum;

public enum TemplateType
{
  Email,
  SMS
}

// =======================================================
// FILE: src/Core/Enum/ExpenseCategory.cs
// =======================================================
namespace CRM_Vivid.Core.Enum
{
  public enum ExpenseCategory
  {
    General = 0,
    Venue = 1,
    Catering = 2,
    Talent = 3,
    Production = 4,
    Marketing = 5,
    Travel = 6,
    Admin = 7,
    Legal = 8
  }
}

// =======================================================
// FILE: src/Core/Enum/EventStatus.cs
// =======================================================
// src/Core/Enums/EventStatus.cs
namespace CRM_Vivid.Core.Enums;

public enum EventStatus
{
  Planned,
  InProgress,
  Completed,
  Postponed,
  Cancelled
}

// =======================================================
// FILE: src/Core/Enum/TaskPriority.cs
// =======================================================
namespace CRM_Vivid.Core.Enum
{
  public enum TaskPriority
  {
    Low,
    Medium,
    High,
    Urgent
  }
}

// =======================================================
// FILE: src/Core/Enum/VendorType.cs
// =======================================================
using System.Text.Json.Serialization;

namespace CRM_Vivid.Core.Enum;

[JsonConverter(typeof(JsonStringEnumConverter))]
public enum VendorType
{
  Catering,
  Venue,
  Security,
  Entertainment,
  Florist,
  Photography,
  Videography,
  Other
}

// =======================================================
// FILE: src/Core/Enum/ContractStatus.cs
// =======================================================
namespace CRM_Vivid.Core.Enum
{
  public enum ContractStatus
  {
    /// <summary>
    /// The document has been created but not yet sent to the client.
    /// </summary>
    Draft = 1,

    /// <summary>
    /// The document has been successfully sent (e.g., via email/DocuSign).
    /// </summary>
    Sent = 2,

    /// <summary>
    /// The client has opened and viewed the document.
    /// </summary>
    Viewed = 3,

    /// <summary>
    /// The client has executed (signed) the document. This is the trigger for internal completion logic.
    /// </summary>
    Signed = 4,

    /// <summary>
    /// The document has been cancelled, superseded, or is otherwise invalid.
    /// </summary>
    Voided = 5
  }
}

// =======================================================
// FILE: src/Core/Enum/ContactEnum.cs
// =======================================================
namespace CRM_Vivid.Core.Enum;

public enum ConnectionStatus
{
  // Default state
  Unknown = 0,

  // Diara's specific workflow
  NeedToMeet = 1,
  MetAlready = 2,
  DoesntNeed = 3,

  // "Have/Need" Matrix
  NeedAndDoesntHave = 4,
  NeedAndHas = 5,
  HasAndNeedsToMeet = 6
}

public enum LeadStage
{
  NewLead = 0,         // Just entered system (Intake)
  InDiscussion = 1,    // "Discussion Tab"
  ProposalSent = 2,    // Contract sent
  Negotiating = 3,     // Redlining
  Won = 4,             // Confirmed Client
  Lost = 5             // Dead lead
}

public enum CommunicationType
{
  Email = 0,
  Sms = 1
}

// =======================================================
// FILE: src/Core/Enum/TaskStatus.cs
// =======================================================
namespace CRM_Vivid.Core.Enum
{
  public enum TaskStatus
  {
    NotStarted,
    InProgress,
    Completed,
    Deferred
  }
}

// =======================================================
// FILE: src/Core/Entities/Budget.cs
// =======================================================
namespace CRM_Vivid.Core.Entities
{
  public class Budget
  {
    public Guid Id { get; set; }

    // Foreign Key to Event (1:1)
    public Guid EventId { get; set; }
    public Event? Event { get; set; }

    public decimal TotalAmount { get; set; } // The cap/goal
    public string Currency { get; set; } = "USD";

    public string? Notes { get; set; }

    // --- PHASE 26 ADDITION: Locking Mechanism ---
    public bool IsLocked { get; set; } = false; // NEW

    // Navigation to Line Items
    public ICollection<Expense> Expenses { get; set; } = new List<Expense>();
  }
}

// =======================================================
// FILE: src/Core/Entities/Task.cs
// =======================================================
// src/Core/Entities/Task.cs
using CRM_Vivid.Core.Enum;

namespace CRM_Vivid.Core.Entities
{
  public class Task : IUserScopedEntity
  {
    public Guid Id { get; set; }
    public string Title { get; set; } = string.Empty;
    public string? Description { get; set; }
    public Enum.TaskStatus Status { get; set; } = Enum.TaskStatus.NotStarted;
    public TaskPriority Priority { get; set; } = TaskPriority.Medium;
    public DateTime? DueDate { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime? UpdatedAt { get; set; }

    // Foreign Keys
    public Guid? ContactId { get; set; }
    public Guid? EventId { get; set; }

    // NEW: Foreign Key for Vendor
    public Guid? VendorId { get; set; }

    // Navigation Properties
    public Contact? Contact { get; set; }
    public Event? Event { get; set; }

    // NEW: Navigation Property for Vendor
    public Vendor? Vendor { get; set; }
    public Guid CreatedByUserId { get; set; }
  }
}

// =======================================================
// FILE: src/Core/Entities/Expense.cs
// =======================================================
using CRM_Vivid.Core.Enum;

namespace CRM_Vivid.Core.Entities
{
  public class Expense
  {
    public Guid Id { get; set; }

    // Parent Budget
    public Guid BudgetId { get; set; }
    public Budget? Budget { get; set; }

    // Optional Vendor Link
    public Guid? VendorId { get; set; }
    public Vendor? Vendor { get; set; }

    public string Description { get; set; } = string.Empty;
    public decimal Amount { get; set; }
    public DateTime DateIncurred { get; set; }

    public ExpenseCategory Category { get; set; }

    // Optional Link to an Invoice (Document uses int PK)
    public int? LinkedDocumentId { get; set; }
    public Document? LinkedDocument { get; set; }
  }
}

// =======================================================
// FILE: src/Core/Entities/Event.cs
// =======================================================
// src/Core/Entities/Event.cs
using CRM_Vivid.Core.Enums;

namespace CRM_Vivid.Core.Entities
{
  public class Event
  {
    public Guid Id { get; set; }

    public string Name { get; set; } = string.Empty;

    public EventStatus Status { get; set; }

    public DateTime StartDateTime { get; set; }
    public DateTime EndDateTime { get; set; }
    public bool IsPublic { get; set; }

    public string? Description { get; set; }

    public ICollection<EventContact> EventContacts { get; set; } = new List<EventContact>();

    public ICollection<EventVendor> EventVendors { get; set; } = new List<EventVendor>();

    // --- NEW: The Ledger ---
    // Navigation property for the Financial Budget (1:0..1)
    public Budget? Budget { get; set; }

    public string? Location { get; set; }
  }
}

// =======================================================
// FILE: src/Core/Entities/Vendor.cs
// =======================================================
// FILE: src/Core/Entities/Vendor.cs
// src/Core/Entities/Vendor.cs (FULL FILE)
using CRM_Vivid.Core.Enum;

namespace CRM_Vivid.Core.Entities;

public class Vendor : IUserScopedEntity
{
  public Guid Id { get; set; }
  public string Name
  {
    get; set;
  } = string.Empty;
  public string? PhoneNumber { get; set; }
  public string? Email
  {
    get; set;
  }
  public VendorType ServiceType { get; set; }

  // --- NEW: FLEXIBLE ATTRIBUTES (JSONB) ---
  public string? Attributes { get; set; }

  public Guid CreatedByUserId { get; set; }

  // NEW: Navigation property for Events via the join table
  public ICollection<EventVendor> EventVendors
  {
    get;
    set;
  } = new List<EventVendor>();

  public ICollection<Expense> Expenses { get; set; } = new List<Expense>();
}

// =======================================================
// FILE: src/Core/Entities/EventVendor.cs
// =======================================================
// FILE: src/Core/Entities/EventVendor.cs
// src/Core/Entities/EventVendor.cs
namespace CRM_Vivid.Core.Entities
{
  public class EventVendor
  {
    public Guid Id { get; set; } // PK is GUID, preserved
    public Guid CreatedByUserId { get; set; }

    // Foreign Key to Event
    public Guid EventId { get; set; }
    public Event? Event { get; set; } // FIX: Marked as nullable (CS8618)
    // Foreign Key to Vendor
    public Guid VendorId { get; set; }
    public Vendor? Vendor { get; set; } // FIX: Marked as nullable (CS8618)

    // --- NEW: PHASE 34 ROLE PROPERTY ---
    public string? Role { get; set; }
  }
}

// =======================================================
// FILE: src/Core/Entities/EmailLog.cs
// =======================================================
namespace CRM_Vivid.Core.Entities
{
  public class EmailLog
  {
    public Guid Id { get; set; }
    public string To { get; set; } = string.Empty;
    public string Subject { get; set; } = string.Empty;
    public string Body { get; set; } = string.Empty;
    public DateTime SentAt { get; set; }
    public bool IsSuccess { get; set; }
    public string? ErrorMessage { get; set; }

    // Foreign Keys
    public Guid? ContactId { get; set; }
    public virtual Contact? Contact { get; set; }

    public Guid? VendorId { get; set; }
    public Vendor? Vendor { get; set; }

    public Guid? EventId { get; set; }
    public Event? Event { get; set; }

    public Guid? TemplateId { get; set; }
    public Template? Template { get; set; }
  }
}

// =======================================================
// FILE: src/Core/Entities/IUserScopedEntities.cs
// =======================================================
// FILE: src/Core/Entities/IUserScopedEntity.cs (NEW FILE)
namespace CRM_Vivid.Core.Entities;

/// <summary>
/// Marks an entity that must be scoped/filtered by the creating user's ID.
/// </summary>
public interface IUserScopedEntity
{
  Guid CreatedByUserId { get; set; }
}

// =======================================================
// FILE: src/Core/Entities/Note.cs
// =======================================================
namespace CRM_Vivid.Core.Entities;

public class Note : IUserScopedEntity
{
  public Guid Id { get; set; }
  public string Title { get; set; } = string.Empty;
  public string Content { get; set; } = string.Empty; // Added default
  public DateTime CreatedAt { get; set; }
  public DateTime? UpdatedAt { get; set; }

  // Polymorphic Foreign Keys
  public Guid? ContactId { get; set; }
  public Contact? Contact { get; set; }

  public Guid? EventId { get; set; }
  public Event? Event { get; set; }

  public Guid? TaskId { get; set; }
  public Task? Task { get; set; }

  public Guid? VendorId { get; set; }
  public Vendor? Vendor { get; set; }
  public Guid CreatedByUserId { get; set; }
}

// =======================================================
// FILE: src/Core/Entities/EventContact.cs
// =======================================================
// FILE: src/Core/Entities/EventContact.cs
namespace CRM_Vivid.Core.Entities
{
  public class EventContact
  {
    public string? Role { get; set; } // e.g., "Guest", "Speaker", "Host" 
    public Guid CreatedByUserId { get; set; } // NEW

    // Foreign keys and navigation properties
    public Guid EventId { get; set; }
    public Event Event { get; set; } = null!;

    public Guid ContactId { get; set; }
    public Contact Contact { get; set; } = null!;
  }
}

// =======================================================
// FILE: src/Core/Entities/Contact.cs
// =======================================================
using CRM_Vivid.Core.Enum; // Uses the new file

namespace CRM_Vivid.Core.Entities;

public class Contact : IUserScopedEntity
{
  public Guid Id { get; set; } = Guid.NewGuid();

  public string FirstName { get; set; } = string.Empty;
  public string? LastName { get; set; }
  public string Email { get; set; } = string.Empty;
  public string? PhoneNumber { get; set; }

  public string? Title { get; set; }
  public string? Organization { get; set; }

  // --- Timestamps (Preserved) ---
  public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
  public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

  // --- Pipeline & Logic (New) ---
  public ConnectionStatus ConnectionStatus { get; set; } // Renamed to match Enum file strictly
  public LeadStage Stage { get; set; } = LeadStage.NewLead; // New for Pipeline
  public bool IsLead { get; set; } // To distinguish Leads from confirmed Clients
  public int FollowUpCount { get; set; } // Track 1st, 2nd, 3rd follow up

  public DateTime? LastContactedAt { get; set; }
  public string? Source { get; set; } // e.g., "Intake Form", "Referral"

  // --- Relationships ---
  public ICollection<EventContact> EventContacts { get; set; } = new List<EventContact>();

  // Added these back to support "Notes tab" and "Tasks bar"
  public ICollection<Note> Notes { get; set; } = new List<Note>();
  public ICollection<Task> Tasks { get; set; } = new List<Task>();
  public ICollection<EmailLog> EmailLogs { get; set; } = new List<EmailLog>();
  public Guid CreatedByUserId { get; set; }
}

// =======================================================
// FILE: src/Core/Entities/Document.cs
// =======================================================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using CRM_Vivid.Core.Enum; // NEW

// Protocol 10: The Task Alias

namespace CRM_Vivid.Core.Entities
{
  [Table("Documents")]
  public class Document
  {
    [Key]
    public int Id { get; set; } // PK is int

    [Required]
    [MaxLength(255)]
    public required string FileName { get; set; }

    [Required]
    [MaxLength(255)]
    public required string StoredFileName { get; set; }

    [Required]
    [MaxLength(100)]
    public required string ContentType { get; set; }

    public long Size { get; set; }

    public DateTime UploadedAt { get; set; } = DateTime.UtcNow;

    public Guid RelatedEntityId { get; set; }

    [Required]
    [MaxLength(50)]
    public required string RelatedEntityType { get; set; }

    // --- NEW: The Librarian ---
    [MaxLength(50)]
    public string Category { get; set; } = "General"; // Invoice, Contract, Rider, etc.

    // --- PHASE 26 ADDITIONS ---
    public ContractStatus Status { get; set; } = ContractStatus.Draft; // NEW
    public DateTime? SignedAt { get; set; } // NEW
  }
}

// =======================================================
// FILE: src/Core/Entities/Template.cs
// =======================================================
using CRM_Vivid.Core.Enum;

namespace CRM_Vivid.Core.Entities;

public class Template
{
  public Guid Id { get; set; }
  public string Name { get; set; } = string.Empty;
  public string? Subject { get; set; }
  public string Content { get; set; } = string.Empty;
  public TemplateType Type { get; set; }
}

// =======================================================
// FILE: src/Api/Middleware/GlobalExceptionHandlingMiddleware.cs
// =======================================================
using System.Net;
using System.Text.Json;
using CRM_Vivid.Application.Exceptions;
using FluentValidation;

namespace CRM_Vivid.Api.Middleware
{
  public class GlobalExceptionHandlingMiddleware
  {
    private readonly RequestDelegate _next;
    private readonly ILogger<GlobalExceptionHandlingMiddleware> _logger;

    public GlobalExceptionHandlingMiddleware(RequestDelegate next, ILogger<GlobalExceptionHandlingMiddleware> logger)
    {
      _next = next;
      _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
      try
      {
        await _next(context);
      }
      catch (Exception ex)
      {
        await HandleExceptionAsync(context, ex);
      }
    }

    private async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
      context.Response.ContentType = "application/json";
      var response = context.Response;

      object errorResponse = new
      {
        message = exception.Message,
        details = exception.StackTrace?.ToString() // Only include stack trace in dev
      };

      // You can create a more structured error response if you prefer

      switch (exception)
      {
        case NotFoundException ex:
          response.StatusCode = (int)HttpStatusCode.NotFound;
          errorResponse = new { message = ex.Message, details = ex.StackTrace?.ToString() };
          break;

        case ValidationException ex:
          response.StatusCode = (int)HttpStatusCode.BadRequest;
          // Format FluentValidation errors
          var validationErrors = ex.Errors.Select(e => new { e.PropertyName, e.ErrorMessage });
          errorResponse = new { message = "Validation Failed", errors = validationErrors, details = ex.StackTrace?.ToString() };
          break;

        case ArgumentException ex: // Catch our old exceptions if any are left
          response.StatusCode = (int)HttpStatusCode.BadRequest;
          errorResponse = new { message = ex.Message, details = ex.StackTrace?.ToString() };
          break;

        default:
          response.StatusCode = (int)HttpStatusCode.InternalServerError;
          _logger.LogError(exception, "An unhandled exception has occurred.");
          errorResponse = new { message = "Internal Server Error", details = exception.StackTrace?.ToString() };
          break;
      }

      // In a real production app, you'd hide 'details' based on Environment
      var result = JsonSerializer.Serialize(errorResponse);
      await context.Response.WriteAsync(result);
    }
  }
}

// =======================================================
// FILE: src/Api/Controllers/DashboardController.cs
// =======================================================
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Dashboard.Queries;
using MediatR;
using Microsoft.AspNetCore.Mvc;

namespace CRM_Vivid.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
public class DashboardController : ControllerBase
{
  private readonly IMediator _mediator;

  public DashboardController(IMediator mediator)
  {
    _mediator = mediator;
  }

  [HttpGet]
  public async Task<ActionResult<DashboardStatsDto>> GetStats()
  {
    return await _mediator.Send(new GetDashboardStatsQuery());
  }
}

// =======================================================
// FILE: src/Api/Controllers/TemplatesController.cs
// =======================================================
using CRM_Vivid.Application.Templates.Commands;
using CRM_Vivid.Application.Templates.Queries;
using CRM_Vivid.Application.Common.Models;
using Microsoft.AspNetCore.Mvc;
using MediatR;

namespace CRM_Vivid.Api.Controllers;

[Route("api/[controller]")]
[ApiController]
public class TemplatesController : ControllerBase
{
  private readonly ISender _sender;

  public TemplatesController(ISender sender)
  {
    _sender = sender;
  }

  [HttpGet]
  public async Task<ActionResult<List<TemplateDto>>> GetTemplates()
  {
    return await _sender.Send(new GetTemplatesQuery());
  }

  [HttpGet("{id}")]
  public async Task<ActionResult<TemplateDto>> GetTemplate(Guid id)
  {
    return await _sender.Send(new GetTemplateByIdQuery(id));
  }

  [HttpPost]
  public async Task<ActionResult<Guid>> Create(CreateTemplateCommand command)
  {
    return await _sender.Send(command);
  }

  [HttpPut("{id}")]
  public async Task<ActionResult> Update(Guid id, UpdateTemplateCommand command)
  {
    if (id != command.Id)
    {
      return BadRequest();
    }

    await _sender.Send(command);

    return NoContent();
  }

  [HttpDelete("{id}")]
  public async Task<ActionResult> Delete(Guid id)
  {
    await _sender.Send(new DeleteTemplateCommand(id));
    return NoContent();
  }

  // --- NEW ENDPOINT ---
  [HttpPost("send")]
  public async Task<ActionResult> SendTemplate(SendTemplateEmailCommand command)
  {
    await _sender.Send(command);
    return Ok();
  }
}

// =======================================================
// FILE: src/Api/Controllers/DocumentsController.cs
// =======================================================
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Documents.Commands;
using CRM_Vivid.Application.Documents.Queries;
using CRM_Vivid.Application.Exceptions;
using CRM_Vivid.Core.Enum; // NEW: Needed for ContractStatus in Webhook action
using MediatR;
using Microsoft.AspNetCore.Mvc;

namespace CRM_Vivid.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
public class DocumentsController : ControllerBase
{
  private readonly IMediator _mediator;
  private readonly IConfiguration _configuration; // NEW: Configuration to check Webhook Secret

  // MODIFIED CONSTRUCTOR
  public DocumentsController(IMediator mediator, IConfiguration configuration)
  {
    _mediator = mediator;
    _configuration = configuration;
  }

  [HttpPost]
  public async Task<ActionResult<DocumentDto>> Upload(
      [FromForm] IFormFile file,
      [FromForm] Guid relatedEntityId,
      [FromForm] string relatedEntityType,
      [FromForm] string category = "General") // NEW: Accept Category
  {
    if (file == null || file.Length == 0)
    {
      return BadRequest("No file uploaded.");
    }

    using var stream = file.OpenReadStream();

    var command = new UploadDocumentCommand
    {
      FileName = file.FileName,
      ContentType = file.ContentType,
      Size = file.Length,
      FileContent = stream,
      RelatedEntityId = relatedEntityId,
      RelatedEntityType = relatedEntityType,
      Category = category // Pass to Command
    };

    var result = await _mediator.Send(command);

    return Ok(result);
  }

  [HttpGet]
  public async Task<ActionResult<List<DocumentDto>>> Get(
      [FromQuery] Guid relatedEntityId,
      [FromQuery] string relatedEntityType)
  {
    var query = new GetDocumentsQuery
    {
      RelatedEntityId = relatedEntityId,
      RelatedEntityType = relatedEntityType
    };

    var result = await _mediator.Send(query);
    return Ok(result);
  }

  [HttpDelete("{id}")]
  public async Task<IActionResult> Delete(int id)
  {
    await _mediator.Send(new DeleteDocumentCommand(id));
    return NoContent();
  }

  // --- NEW ENDPOINT: PHASE 24 (CONTRACT GENERATOR) ---
  [HttpGet("contract/{eventId}")]
  [Produces("application/pdf")]
  [ProducesResponseType(StatusCodes.Status200OK)]
  [ProducesResponseType(StatusCodes.Status404NotFound)]
  public async Task<ActionResult> GenerateContract(Guid eventId)
  {
    var command = new GenerateContractCommand { EventId = eventId };

    try
    {
      // Note: The Command Handler is responsible for calling IContractGenerator
      var pdfBytes = await _mediator.Send(command);

      var fileName = $"Contract_{eventId}_{DateTime.Now:yyyyMMdd}.pdf";

      // Return the byte array as a file download
      return File(
          fileContents: pdfBytes,
          contentType: "application/pdf",
          fileDownloadName: fileName
      );
    }
    catch (NotFoundException)
    {
      // Catch the specific exception thrown by the command handler if the event doesn't exist
      return NotFound(new { message = $"Event ID {eventId} not found." });
    }
  }

  // --- PHASE 26 ADDITION: THE WEBHOOK LISTENER ---
  [HttpPost("webhook")]
  [Microsoft.AspNetCore.Authorization.AllowAnonymous]
  [ProducesResponseType(StatusCodes.Status200OK)]
  [ProducesResponseType(StatusCodes.Status400BadRequest)]
  [ProducesResponseType(StatusCodes.Status401Unauthorized)]
  public async Task<IActionResult> Webhook([FromBody] SimulatedWebhookRequest request)
  {
    // 1. Security: Check the Webhook Secret (Keep it simple but secure for now)
    var expectedSecret = _configuration["Secrets:ContractWebhookSecret"];

    if (string.IsNullOrEmpty(expectedSecret) || request.WebhookSecret != expectedSecret)
    {
      // Log failure attempt here
      return Unauthorized("Invalid webhook secret.");
    }

    // 2. Mapping: Map the incoming Status string to our internal ContractStatus enum
    ContractStatus newStatus;

    if (!Enum.TryParse(request.Status, true, out newStatus))
    {
      return BadRequest($"Invalid status value received: {request.Status}");
    }

    // 3. Command: Trigger the internal state change logic
    var command = new UpdateDocumentStatusCommand(
        DocumentId: request.DocumentId,
        NewStatus: newStatus
    );

    try
    {
      await _mediator.Send(command);
      return Ok(new { message = $"Document {request.DocumentId} status updated to {newStatus}." });
    }
    catch (NotFoundException ex)
    {
      return NotFound(new { message = ex.Message });
    }
    catch (Exception ex)
    {
      // Catch other errors (e.g., database failure) and return a 500
      return StatusCode(StatusCodes.Status500InternalServerError, new { message = "Webhook processing failed.", error = ex.Message });
    }
  }
}

// =======================================================
// FILE: src/Api/Controllers/AutomationController.cs
// =======================================================
using CRM_Vivid.Application.Automation.Commands;
using MediatR;
using Microsoft.AspNetCore.Mvc;

namespace CRM_Vivid.Api.Controllers;

[Route("api/[controller]")]
[ApiController]
public class AutomationController : ControllerBase
{
  private readonly ISender _sender;

  public AutomationController(ISender sender)
  {
    _sender = sender;
  }

  // NOTE: SendTestEmail and ScheduleEmail logic has been removed/refactored
  // to avoid exposing IBackgroundJobClient directly and centralize scheduling via ISender.

  [HttpPost("schedule-followup")]
  [ProducesResponseType(typeof(string), StatusCodes.Status200OK)]
  [ProducesResponseType(StatusCodes.Status400BadRequest)]
  public async Task<IActionResult> ScheduleFollowUp([FromBody] ScheduleFollowUpCommand command)
  {
    // The command handler validates the time/IDs and queues the job via Hangfire.
    var jobId = await _sender.Send(command);

    return Ok(new { Message = "Follow-up job scheduled successfully.", JobId = jobId });
  }

  // Placeholder for future general automation actions
  // [HttpPost("trigger-workflow")]
  // public IActionResult TriggerWorkflow(...) { ... }
}

// =======================================================
// FILE: src/Api/Controllers/LeadsController.cs
// =======================================================
using CRM_Vivid.Application.Contacts.Commands;
using MediatR;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace CRM_Vivid.Api.Controllers;

[AllowAnonymous] // IMPORTANT: This allows external app/forms to submit data
[Route("api/[controller]")]
[ApiController]
public class LeadsController : ControllerBase
{
  private readonly ISender _sender;

  public LeadsController(ISender sender)
  {
    _sender = sender;
  }

  /// <summary>
  /// Public endpoint for external systems to submit new leads.
  /// Requires no authentication.
  /// POST /api/leads/submit
  /// </summary>
  [HttpPost("submit")]
  [ProducesResponseType(typeof(Guid), StatusCodes.Status200OK)]
  [ProducesResponseType(StatusCodes.Status400BadRequest)]
  public async Task<ActionResult<Guid>> SubmitLead(SubmitLeadCommand command)
  {
    // Validation handled by MediatR pipeline (FluentValidation)
    var contactId = await _sender.Send(command);
    return Ok(contactId);
  }
}

// =======================================================
// FILE: src/Api/Controllers/TasksControllers.cs
// =======================================================
using MediatR;
using Microsoft.AspNetCore.Mvc;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Tasks.Queries;
using CRM_Vivid.Application.Tasks.Commands;

namespace CRM_Vivid.Api.Controllers;

[ApiController]
[Route("api/tasks")]
public class TasksController : ControllerBase
{
  private readonly ISender _mediator;

  public TasksController(ISender mediator)
  {
    _mediator = mediator;
  }

  [HttpGet]
  public async Task<IEnumerable<TaskDto>> GetTasks([FromQuery] GetTasksQuery query)
  {
    return await _mediator.Send(query);
  }

  [HttpPost]
  // --- FIX: Reverted to ActionResult<Guid> to match the Command ---
  public async Task<ActionResult<Guid>> Create(CreateTaskCommand command)
  {
    return await _mediator.Send(command);
  }

  [HttpPut("{id}")]
  public async Task<ActionResult> Update(Guid id, UpdateTaskCommand command)
  {
    if (id != command.Id)
    {
      return BadRequest();
    }

    await _mediator.Send(command);
    return NoContent();
  }

  [HttpDelete("{id}")]
  public async Task<ActionResult> Delete(Guid id)
  {
    await _mediator.Send(new DeleteTaskCommand { Id = id });
    return NoContent();
  }
}

// =======================================================
// FILE: src/Api/Controllers/FinancialsController.cs
// =======================================================
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Financials.Commands;
using CRM_Vivid.Application.Financials.Queries;
using Microsoft.AspNetCore.Mvc;

namespace CRM_Vivid.Api.Controllers
{
  [ApiController]
  [Route("api/events/{eventId}/financials")] // Sub-resource routing
  public class FinancialsController : ControllerBase
  {
    private readonly MediatR.ISender _mediator;

    public FinancialsController(MediatR.ISender mediator)
    {
      _mediator = mediator;
    }

    // GET: api/events/{id}/financials
    [HttpGet]
    public async Task<ActionResult<EventFinancialsDto>> Get(Guid eventId)
    {
      return await _mediator.Send(new GetEventFinancialsQuery(eventId));
    }

    // POST: api/events/{id}/financials/budget
    // Initialize or Update the Total Budget
    [HttpPost("budget")]
    public async Task<ActionResult<Guid>> UpsertBudget(Guid eventId, [FromBody] UpsertBudgetCommand command)
    {
      if (eventId != command.EventId) return BadRequest();
      return await _mediator.Send(command);
    }

    // POST: api/events/{id}/financials/expenses
    // Add a line item
    [HttpPost("expenses")]
    public async Task<ActionResult<Guid>> AddExpense(Guid eventId, [FromBody] AddExpenseCommand command)
    {
      if (eventId != command.EventId) return BadRequest();
      return await _mediator.Send(command);
    }
  }
}

// =======================================================
// FILE: src/Api/Controllers/ContactsController.cs
// =======================================================
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Contacts.Commands;
using CRM_Vivid.Application.Contacts.Queries;
using CRM_Vivid.Application.Features.Contacts.Commands; // Note: Check if this namespace is actually needed/correct based on your folder structure, usually it's just Application.Contacts.Commands
using CRM_Vivid.Core.Entities;
using MediatR;
using Microsoft.AspNetCore.Mvc;

namespace CRM_Vivid.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
public class ContactsController : ControllerBase
{
  private readonly IMediator _mediator;

  public ContactsController(IMediator mediator)
  {
    _mediator = mediator;
  }

  [HttpPost]
  public async Task<ActionResult<Guid>> Create(CreateContactCommand command)
  {
    var contactId = await _mediator.Send(command);
    return Ok(contactId);
  }

  [HttpPost("init-fixtures")]
  public async Task<ActionResult<Guid>> InitializeTestFixtures()
  {
    // WARNING: This endpoint bypasses authorization checks in the handler logic 
    // (it calls ISender directly), but should only be used in dev/test environments.
    var primaryContactId = await _mediator.Send(new InitializeTestFixturesCommand());
    return Ok(primaryContactId);
  }

  [HttpGet]
  public async Task<ActionResult<List<Contact>>> Get()
  {
    var contacts = await _mediator.Send(new GetContactsQuery());
    return Ok(contacts);
  }

  [HttpGet("{id:guid}")]
  public async Task<ActionResult<Contact>> GetById(Guid id)
  {
    var query = new GetContactByIdQuery { Id = id };
    var contact = await _mediator.Send(query);
    return Ok(contact);
  }

  [HttpGet("{contactId:guid}/task-summary")]
  public async Task<ActionResult<ContactTaskSummaryDto>> GetContactTaskSummary(Guid contactId)
  {
    return await _mediator.Send(new GetContactTaskSummaryQuery(contactId));
  }

  [HttpPut("{id}")]
  public async Task<IActionResult> Update(Guid id, [FromBody] UpdateContactCommand command)
  {
    if (id != command.Id)
    {
      return BadRequest("ID mismatch between route and request body.");
    }
    await _mediator.Send(command);
    return NoContent();
  }

  [HttpDelete("{id}")]
  public async Task<IActionResult> Delete(Guid id)
  {
    var command = new DeleteContactCommand(id);
    await _mediator.Send(command);
    return NoContent();
  }

  [HttpGet("{contactId:guid}/events")]
  public async Task<ActionResult<IEnumerable<EventDto>>> GetEventsForContact(Guid contactId)
  {
    var query = new GetEventsForContactQuery { ContactId = contactId };
    var events = await _mediator.Send(query);
    return Ok(events);
  }

  // --- NEW: Email Logs Endpoint ---
  [HttpGet("{contactId:guid}/email-logs")]
  public async Task<ActionResult<IEnumerable<EmailLogDto>>> GetEmailLogs(Guid contactId)
  {
    // Note: Ensure GetEmailLogsForContactQuery accepts the Guid in constructor or property init
    var query = new GetEmailLogsForContactQuery(contactId);
    var logs = await _mediator.Send(query);
    return Ok(logs);
  }

  [HttpGet("{contactId:guid}/activity-stream")]
  public async Task<ActionResult<List<ActivityDto>>> GetActivityStream(Guid contactId)
  {
    var query = new GetActivityStreamQuery(contactId);
    var stream = await _mediator.Send(query);
    return Ok(stream);
  }
}

// =======================================================
// FILE: src/Api/Controllers/NotesController.cs
// =======================================================
using MediatR;
using Microsoft.AspNetCore.Mvc;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Notes.Queries;
// --- FIX 1: Correct Namespace Import (Matches your file tree) ---
using CRM_Vivid.Application.Notes.Commands;

namespace CRM_Vivid.Api.Controllers;

[ApiController]
[Route("api/notes")]
public class NotesController : ControllerBase
{
  private readonly ISender _mediator;

  public NotesController(ISender mediator)
  {
    _mediator = mediator;
  }

  [HttpGet]
  public async Task<IEnumerable<NoteDto>> GetNotes([FromQuery] GetNotesQuery query)
  {
    return await _mediator.Send(query);
  }

  [HttpPost]
  // --- FIX 2: Return NoteDto, not Guid ---
  public async Task<ActionResult<NoteDto>> Create(CreateNoteCommand command)
  {
    return await _mediator.Send(command);
  }

  [HttpPut("{id}")]
  public async Task<ActionResult> Update(Guid id, UpdateNoteCommand command)
  {
    if (id != command.Id)
    {
      return BadRequest();
    }

    await _mediator.Send(command);
    return NoContent();
  }

  [HttpDelete("{id}")]
  public async Task<ActionResult> Delete(Guid id)
  {
    // --- FIX 3: Use Object Initializer Syntax ---
    await _mediator.Send(new DeleteNoteCommand { Id = id });
    return NoContent();
  }
}

// =======================================================
// FILE: src/Api/Controllers/EventsController.cs
// =======================================================
// FILE: src/Api/Controllers/EventsController.cs

using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Events.Commands;
using CRM_Vivid.Application.Events.Queries;
using CRM_Vivid.Core.Entities;
using MediatR;
using Microsoft.AspNetCore.Mvc;
using CRM_Vivid.Application.Exceptions;

namespace CRM_Vivid.Api.Controllers
{
  [ApiController]
  [Route("api/[controller]")]
  public class EventsController : ControllerBase
  {
    private readonly IMediator _mediator;

    public EventsController(IMediator mediator)
    {
      _mediator = mediator;
    }

    [HttpPost]
    public async Task<ActionResult<Guid>> Create(CreateEventCommand command)
    {
      var id = await _mediator.Send(command);
      return CreatedAtAction(nameof(Create), new { id }, id);
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<Event>>> GetAll()
    {
      var events = await _mediator.Send(new GetEventsQuery());
      return Ok(events);
    }

    [HttpGet("{id:guid}")]
    public async Task<ActionResult<EventDto>> GetEventById(Guid id)
    {
      var query = new GetEventByIdQuery { Id = id };
      var eventItem = await _mediator.Send(query);

      if (eventItem == null)
      {
        return NotFound();
      }

      return Ok(eventItem);
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> UpdateEvent(Guid id, UpdateEventCommand command)
    {
      if (id != command.Id)
      {
        return BadRequest("ID mismatch between URL and request body.");
      }

      try
      {
        await _mediator.Send(command);
      }
      catch (Exception ex)
      {
        return NotFound(ex.Message);
      }

      return NoContent();
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteEvent(Guid id)
    {
      var command = new DeleteEventCommand { Id = id };

      try
      {
        await _mediator.Send(command);
      }
      catch (Exception ex)
      {
        return NotFound(ex.Message);
      }

      return NoContent();
    }

    [HttpPost("{eventId}/contacts")]
    public async Task<IActionResult> AddContactToEvent(Guid eventId, [FromBody] AddContactToEventCommand command)
    {
      command.EventId = eventId;

      try
      {
        await _mediator.Send(command);
      }
      // Note: Handler now throws NotFoundException and ArgumentException for links
      catch (Exception ex)
      {
        return BadRequest(ex.Message);
      }
      return Ok();
    }

    [HttpGet("{eventId:guid}/contacts")]
    public async Task<ActionResult<IEnumerable<ContactDto>>> GetContactsForEvent(Guid eventId)
    {
      var query = new GetContactsForEventQuery { EventId = eventId };
      // Handler now uses explicit projection to include the Role
      var contacts = await _mediator.Send(query);

      return Ok(contacts);
    }

    // NEW: Delete Contact from Event (Unlink)
    [HttpDelete("{eventId:guid}/contacts/{contactId:guid}")]
    public async Task<IActionResult> DeleteContactFromEvent(Guid eventId, Guid contactId)
    {
      var command = new DeleteContactFromEventCommand
      {
        EventId = eventId,
        ContactId = contactId
      };

      try
      {
        await _mediator.Send(command);
      }
      // Uses the now-imported NotFoundException type
      catch (NotFoundException ex)
      {
        return NotFound(ex.Message);
      }
      catch (Exception ex)
      {
        return BadRequest(ex.Message);
      }

      return NoContent(); // 204 success, no content returned
    }

    // --- PHASE 14 VENDOR ENDPOINTS START HERE ---

    // POST api/events/{id}/vendors (Now accepts Role)
    [HttpPost("{id}/vendors")]
    public async Task<ActionResult<Guid>> AddVendorToEvent(Guid id, [FromBody] AddVendorToEventCommand command)
    {
      if (id != command.EventId)
      {
        return BadRequest("Event ID in path must match Event ID in body.");
      }
      // Handler now assigns Role and is hardened
      var eventVendorId = await _mediator.Send(command);
      return Ok(eventVendorId);
    }

    // --- PHASE 34 ADDITION: Get Vendors for Event with Roles ---
    [HttpGet("{eventId:guid}/vendors")]
    public async Task<ActionResult<IEnumerable<VendorDto>>> GetVendorsForEvent(Guid eventId)
    {
      // Handler uses explicit projection to include the Role
      var query = new GetVendorsForEventQuery { EventId = eventId };
      var vendors = await _mediator.Send(query);
      return Ok(vendors);
    }

    // DELETE api/events/{id}/vendors/{vendorId}
    [HttpDelete("{id}/vendors/{vendorId}")]
    public async Task<ActionResult> DeleteVendorFromEvent(Guid id, Guid vendorId)
    {
      // FIX: Use the injected _mediator field
      await _mediator.Send(new DeleteVendorFromEventCommand { EventId = id, VendorId = vendorId });
      return NoContent();
    }
  } // FINAL closing brace for EventsController
}

// =======================================================
// FILE: src/Api/Controllers/VendorsController.cs
// =======================================================
// src/Api/Controllers/VendorsController.cs

using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Vendors.Commands;
using CRM_Vivid.Application.Vendors.Queries;
using MediatR;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace CRM_Vivid.Api.Controllers;

[Authorize]
[ApiController]
[Route("api/[controller]")]
public class VendorsController : ControllerBase
{
  private readonly IMediator _mediator;

  public VendorsController(IMediator mediator)
  {
    _mediator = mediator;
  }

  [HttpPost]
  public async Task<IActionResult> CreateVendor([FromBody] CreateVendorCommand command)
  {
    var vendorId = await _mediator.Send(command);
    return CreatedAtAction(nameof(GetVendorById), new { id = vendorId }, command);
  }

  [HttpGet]
  public async Task<ActionResult<IEnumerable<VendorDto>>> GetVendors()
  {
    var vendors = await _mediator.Send(new GetVendorsQuery());
    return Ok(vendors);
  }

  [HttpGet("{id}")]
  public async Task<ActionResult<VendorDto>> GetVendorById(Guid id)
  {
    var vendor = await _mediator.Send(new GetVendorByIdQuery { Id = id });
    return Ok(vendor);
  }

  [HttpGet("{id:guid}/summary")]
  public async Task<ActionResult<VendorSummaryDto>> GetVendorSummary(Guid id)
  {
    return await _mediator.Send(new GetVendorSummaryQuery(id));
  }

  [HttpPut("{id}")]
  public async Task<IActionResult> UpdateVendor(Guid id, [FromBody] UpdateVendorCommand command)
  {
    if (id != command.Id)
    {
      return BadRequest("ID mismatch");
    }

    await _mediator.Send(command);
    return NoContent();
  }

  [HttpDelete("{id}")]
  public async Task<IActionResult> DeleteVendor(Guid id)
  {
    await _mediator.Send(new DeleteVendorCommand { Id = id });
    return NoContent();
  }

  // NEW: Get Events For Vendor Endpoint
  [HttpGet("{id}/events")]
  public async Task<ActionResult<List<EventDto>>> GetEventsForVendor(Guid id)
  {
    // FIX: Use the injected private field _mediator
    var events = await _mediator.Send(new GetEventsForVendorQuery { VendorId = id });
    return Ok(events);
  }
}

// =======================================================
// FILE: src/Api/Program.cs
// =======================================================
using CRM_Vivid.Infrastructure;
using CRM_Vivid.Application;
using CRM_Vivid.Api.Middleware;
using Microsoft.AspNetCore.Authorization;
using Microsoft.OpenApi.Models;
using System.Text.Json.Serialization;
using Hangfire;
using Microsoft.IdentityModel.Logging;
using Microsoft.AspNetCore.Authentication.JwtBearer;

var _myAllowSpecificOrigins = "_myAllowSpecificOrigins";

var builder = WebApplication.CreateBuilder(args);

// ADDED: Enable PII Logging for debugging (Development only)
if (builder.Environment.IsDevelopment())
{
    IdentityModelEventSource.ShowPII = true;
}

// 1. CORS Configuration
builder.Services.AddCors(options =>
{
    options.AddPolicy(name: _myAllowSpecificOrigins,
                      policy =>
                      {
                          policy.WithOrigins("http://localhost:5179",
                                             "http://localhost:3000",
                                             "http://localhost:5173")
                                .AllowAnyHeader()
                                .AllowAnyMethod()
                                .AllowCredentials();
                      });
});

// Add services to the container.
builder.Services.AddApplicationServices();
builder.Services.AddInfrastructureServices(builder.Configuration);

// FIX: Switching to standard AddJwtBearer for reliable JWT validation
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        // Authority (Issuer) tells the middleware where to fetch the public keys (JWKS endpoint)
        options.Authority = builder.Configuration["Clerk:Authority"];

        options.TokenValidationParameters = new Microsoft.IdentityModel.Tokens.TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = false, // Set to true if you define the Audience (Aud) claim
            ValidateLifetime = true,
            // The Authority URL automatically resolves the Issuer Signing Key via the JWKS endpoint
        };

        // OPTIONAL: Event handlers for debugging validation failures
        options.Events = new JwtBearerEvents
        {
            OnAuthenticationFailed = context =>
            {
                Console.WriteLine($"Token Validation Failed: {context.Exception.Message}");
                return Task.CompletedTask;
            }
        };
    });

builder.Services.AddAuthorizationBuilder()
    .SetFallbackPolicy(new AuthorizationPolicyBuilder()
    .RequireAuthenticatedUser()
    .Build());

builder.Services.AddControllers().AddJsonOptions(options =>
{
    options.JsonSerializerOptions.Converters.Add(new JsonStringEnumConverter());
});

builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(options =>
{
    options.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        In = ParameterLocation.Header,
        Description = "Please enter a valid token",
        Name = "Authorization",
        Type = SecuritySchemeType.Http,
        BearerFormat = "JWT",
        Scheme = "Bearer"
    });

    options.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type = ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },
            Array.Empty<string>()
        }
    });
}
);

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    builder.Configuration.AddUserSecrets<Program>();
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseMiddleware<GlobalExceptionHandlingMiddleware>();

app.UseHttpsRedirection();

app.UseCors(_myAllowSpecificOrigins);

// --- NEW: Enable Static Files (Resolves 404 on Downloads) ---
app.UseStaticFiles();
// ------------------------------------------------------------

// Middleware MUST be in this order: Authentication THEN Authorization
app.UseAuthentication();
app.UseAuthorization();

// The Hangfire Dashboard
app.UseHangfireDashboard("/hangfire");

app.MapControllers();

app.Run();

// =======================================================
// FILE: src/Application/Vendors/Queries/GetVendorsQuery.cs
// =======================================================
using CRM_Vivid.Application.Common.Models;
using MediatR;

namespace CRM_Vivid.Application.Vendors.Queries;

public class GetVendorsQuery : IRequest<IEnumerable<VendorDto>>
{
}

// =======================================================
// FILE: src/Application/Vendors/Queries/GetVendorSummaryQuery.cs
// =======================================================
// FILE: src/Application/Vendors/Queries/GetVendorSummaryQuery.cs (NEW FILE)
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Application.Exceptions;
using CRM_Vivid.Core.Entities;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Vendors.Queries;

public record GetVendorSummaryQuery(Guid VendorId) : IRequest<VendorSummaryDto>;

public class GetVendorSummaryQueryHandler : IRequestHandler<GetVendorSummaryQuery, VendorSummaryDto>
{
  private readonly IApplicationDbContext _context;

  public GetVendorSummaryQueryHandler(IApplicationDbContext context)
  {
    _context = context;
  }

  public async Task<VendorSummaryDto> Handle(GetVendorSummaryQuery request, CancellationToken cancellationToken)
  {
    // 1. Fetch the base Vendor details and calculate metrics simultaneously
    var result = await _context.Vendors
        .Where(v => v.Id == request.VendorId)
        .Select(v => new VendorSummaryDto
        {
          VendorId = v.Id,
          VendorName = v.Name,

          // Calculate 1: Total Events Hired For (via EventVendor join table)
          TotalEventsHiredFor = v.EventVendors.Count(),

          // Calculate 2: Total Expenses Paid (via Expense table)
          TotalExpensesPaid = v.Expenses.Sum(e => (decimal?)e.Amount) ?? 0.00m
        })
        .SingleOrDefaultAsync(cancellationToken);

    if (result == null)
    {
      throw new NotFoundException(nameof(Vendor), request.VendorId);
    }

    return result;
  }
}

// =======================================================
// FILE: src/Application/Vendors/Queries/GetVendorByIdQueryHandler.cs
// =======================================================
using AutoMapper;
using AutoMapper.QueryableExtensions;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Exceptions;
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Entities;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Vendors.Queries;

public class GetVendorByIdQueryHandler : IRequestHandler<GetVendorByIdQuery, VendorDto>
{
  private readonly IApplicationDbContext _context;
  private readonly IMapper _mapper;

  public GetVendorByIdQueryHandler(IApplicationDbContext context, IMapper mapper)
  {
    _context = context;
    _mapper = mapper;
  }

  public async Task<VendorDto> Handle(GetVendorByIdQuery request, CancellationToken cancellationToken)
  {
    var vendorDto = await _context.Vendors
        .Where(v => v.Id == request.Id)
        .ProjectTo<VendorDto>(_mapper.ConfigurationProvider)
        .SingleOrDefaultAsync(cancellationToken);

    if (vendorDto == null)
    {
      throw new NotFoundException(nameof(Vendor), request.Id);
    }

    return vendorDto;
  }
}

// =======================================================
// FILE: src/Application/Vendors/Queries/GetVendorByIdQuery.cs
// =======================================================
using CRM_Vivid.Application.Common.Models;
using MediatR;

namespace CRM_Vivid.Application.Vendors.Queries;

public class GetVendorByIdQuery : IRequest<VendorDto>
{
  public Guid Id { get; set; }
}

// =======================================================
// FILE: src/Application/Vendors/Queries/GetVendorsQueryHandler.cs
// =======================================================
using AutoMapper;
using AutoMapper.QueryableExtensions;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Common.Interfaces;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Vendors.Queries;

public class GetVendorsQueryHandler : IRequestHandler<GetVendorsQuery, IEnumerable<VendorDto>>
{
  private readonly IApplicationDbContext _context;
  private readonly IMapper _mapper;

  public GetVendorsQueryHandler(IApplicationDbContext context, IMapper mapper)
  {
    _context = context;
    _mapper = mapper;
  }

  public async Task<IEnumerable<VendorDto>> Handle(GetVendorsQuery request, CancellationToken cancellationToken)
  {
    return await _context.Vendors
        .ProjectTo<VendorDto>(_mapper.ConfigurationProvider)
        .OrderBy(v => v.Name)
        .ToListAsync(cancellationToken);
  }
}

// =======================================================
// FILE: src/Application/Vendors/Commands/UpdateVendorCommandHandler.cs
// =======================================================
using AutoMapper;
using CRM_Vivid.Application.Exceptions;
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Entities;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Vendors.Commands;

public class UpdateVendorCommandHandler : IRequestHandler<UpdateVendorCommand, bool>
{
  private readonly IApplicationDbContext _context;
  private readonly IMapper _mapper;

  public UpdateVendorCommandHandler(IApplicationDbContext context, IMapper mapper)
  {
    _context = context;
    _mapper = mapper;
  }

  public async Task<bool> Handle(UpdateVendorCommand request, CancellationToken cancellationToken)
  {
    var vendor = await _context.Vendors
        .FirstOrDefaultAsync(v => v.Id == request.Id, cancellationToken);

    if (vendor == null)
    {
      throw new NotFoundException(nameof(Vendor), request.Id);
    }

    _mapper.Map(request, vendor);

    await _context.SaveChangesAsync(cancellationToken);

    return true;
  }
}

// =======================================================
// FILE: src/Application/Vendors/Commands/DeleteVendorCommandHandler.cs
// =======================================================
using CRM_Vivid.Application.Exceptions;
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Entities;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Vendors.Commands;

public class DeleteVendorCommandHandler : IRequestHandler<DeleteVendorCommand, bool>
{
  private readonly IApplicationDbContext _context;

  public DeleteVendorCommandHandler(IApplicationDbContext context)
  {
    _context = context;
  }

  public async Task<bool> Handle(DeleteVendorCommand request, CancellationToken cancellationToken)
  {
    var vendor = await _context.Vendors
        .FirstOrDefaultAsync(v => v.Id == request.Id, cancellationToken);

    if (vendor == null)
    {
      throw new NotFoundException(nameof(Vendor), request.Id);
    }

    _context.Vendors.Remove(vendor);
    await _context.SaveChangesAsync(cancellationToken);

    return true;
  }
}

// =======================================================
// FILE: src/Application/Vendors/Commands/CreateVendorCommandHandler.cs
// =======================================================
using AutoMapper;
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Entities;
using MediatR;

namespace CRM_Vivid.Application.Vendors.Commands;

public class CreateVendorCommandHandler : IRequestHandler<CreateVendorCommand, Guid>
{
  private readonly IApplicationDbContext _context;
  private readonly IMapper _mapper;
  private readonly ICurrentUserService _currentUserService;

  public CreateVendorCommandHandler(IApplicationDbContext context, IMapper mapper, ICurrentUserService currentUserService)
  {
    _context = context;
    _mapper = mapper;
    _currentUserService = currentUserService;
  }

  public async Task<Guid> Handle(CreateVendorCommand request, CancellationToken cancellationToken)
  {
    var vendor = _mapper.Map<Vendor>(request);

    // --- PHASE 37: ASSIGN OWNER ---
    vendor.CreatedByUserId = _currentUserService.CurrentUserId;

    _context.Vendors.Add(vendor);
    await _context.SaveChangesAsync(cancellationToken);

    return vendor.Id;
  }
}

// =======================================================
// FILE: src/Application/Vendors/Commands/CreateVendorCommand.cs
// =======================================================
// FILE: src/Application/Vendors/Commands/CreateVendorCommand.cs
using MediatR;

namespace CRM_Vivid.Application.Vendors.Commands;

public class CreateVendorCommand : IRequest<Guid>
{
  public string Name { get; set; } = string.Empty;
  public string? PhoneNumber
  {
    get;
    set;
  }
  public string? Email { get; set; }
  public string ServiceType { get; set; } = string.Empty;
  // <-- FIX: Changed from VendorType to string

  // NEW: Flexible Attributes as a JSON string
  public string? Attributes { get; set; }
}

// =======================================================
// FILE: src/Application/Vendors/Commands/DeleteVendorCommand.cs
// =======================================================
using MediatR;

namespace CRM_Vivid.Application.Vendors.Commands;

public class DeleteVendorCommand : IRequest<bool>
{
  public Guid Id { get; set; }
}

// =======================================================
// FILE: src/Application/Vendors/Commands/UpdateVendorCommandValidator.cs
// =======================================================
// FILE: src/Application/Vendors/Commands/UpdateVendorCommandValidator.cs
using FluentValidation;
using CRM_Vivid.Core.Enum;
using System.Text.Json; // NEW

namespace CRM_Vivid.Application.Vendors.Commands;

public class UpdateVendorCommandValidator : AbstractValidator<UpdateVendorCommand>
{
    public UpdateVendorCommandValidator()
    {
        RuleFor(v => v.Id)
            .NotEmpty().WithMessage("Id is required.");
        RuleFor(v => v.Name)
            .NotEmpty().WithMessage("Name is required.")
            .MaximumLength(200).WithMessage("Name must not exceed 200 characters.");
        RuleFor(v => v.Email)
            .EmailAddress().WithMessage("A valid email address is required.")
            .When(v => !string.IsNullOrEmpty(v.Email));

        RuleFor(v => v.ServiceType)
            .NotEmpty().WithMessage("ServiceType is required.")
            .IsEnumName(typeof(VendorType), caseSensitive: false)
            .WithMessage("A valid ServiceType is required.");

        // --- PHASE 28: CONDITIONAL JSON ATTRIBUTE VALIDATION ---
        RuleFor(v => v.Attributes)
            .Must(ContainRequiredAttributes)
            .WithMessage("If ServiceType is Venue, Attributes must contain a numeric 'Capacity'. If Entertainment, it must contain a 'Genre'.")
            .When(v => v.ServiceType.Equals("Venue", StringComparison.OrdinalIgnoreCase) ||
                       v.ServiceType.Equals("Entertainment", StringComparison.OrdinalIgnoreCase));
    }

    private bool ContainRequiredAttributes(UpdateVendorCommand command, string? attributesJson)
    {
        // Re-use the logic from CreateVendorCommandValidator
        if (string.IsNullOrWhiteSpace(attributesJson) &&
            (command.ServiceType.Equals("Venue", StringComparison.OrdinalIgnoreCase) ||
             command.ServiceType.Equals("Entertainment", StringComparison.OrdinalIgnoreCase)))
        {
            return false;
        }

        if (string.IsNullOrWhiteSpace(attributesJson))
        {
            return true; // Not required, so empty is fine
        }

        try
        {
            var json = JsonDocument.Parse(attributesJson);

            if (command.ServiceType.Equals("Venue", StringComparison.OrdinalIgnoreCase))
            {
                if (json.RootElement.TryGetProperty("Capacity", out var capacityElement) &&
                    capacityElement.ValueKind == JsonValueKind.Number)
                {
                    return capacityElement.GetInt32() > 0;
                }
                return false;
            }

            if (command.ServiceType.Equals("Entertainment", StringComparison.OrdinalIgnoreCase))
            {
                if (json.RootElement.TryGetProperty("Genre", out var genreElement) &&
                    genreElement.ValueKind == JsonValueKind.String)
                {
                    return !string.IsNullOrWhiteSpace(genreElement.GetString());
                }
                return false;
            }

            return true;
        }
        catch (JsonException)
        {
            return false;
        }
        catch
        {
            return false;
        }
    }
}

// =======================================================
// FILE: src/Application/Vendors/Commands/UpdateVendorCommand.cs
// =======================================================
// FILE: src/Application/Vendors/Commands/UpdateVendorCommand.cs
using MediatR;

namespace CRM_Vivid.Application.Vendors.Commands;

public class UpdateVendorCommand : IRequest<bool>
{
  public Guid Id
  {
    get; set;
  }
  public string Name { get; set; } = string.Empty;
  public string? PhoneNumber
  {
    get; set;
  }
  public string? Email { get; set; }
  public string ServiceType
  {
    get; set;
  } = string.Empty;// <-- FIX: Changed from VendorType to string

  // NEW: Flexible Attributes as a JSON string
  public string? Attributes { get; set; }
}

// =======================================================
// FILE: src/Application/Vendors/Commands/CreateVendorCommandValidator.cs
// =======================================================
// FILE: src/Application/Vendors/Commands/CreateVendorCommandValidator.cs
using FluentValidation;
using CRM_Vivid.Core.Enum;
using System.Text.Json; // NEW

namespace CRM_Vivid.Application.Vendors.Commands;

public class CreateVendorCommandValidator : AbstractValidator<CreateVendorCommand>
{
  public CreateVendorCommandValidator()
  {
    RuleFor(v => v.Name)
        .NotEmpty().WithMessage("Name is required.")
        .MaximumLength(200).WithMessage("Name must not exceed 200 characters.");

    RuleFor(v => v.Email)
        .EmailAddress().WithMessage("A valid email address is required.")
        .When(v => !string.IsNullOrEmpty(v.Email));

    RuleFor(v => v.ServiceType)
        .NotEmpty().WithMessage("ServiceType is required.")
        .IsEnumName(typeof(VendorType), caseSensitive: false)
        .WithMessage("A valid ServiceType is required.");

    // --- PHASE 28: CONDITIONAL JSON ATTRIBUTE VALIDATION ---
    RuleFor(v => v.Attributes)
        .Must(ContainRequiredAttributes)
        .WithMessage("If ServiceType is Venue, Attributes must contain a numeric 'Capacity'. If Entertainment, it must contain a 'Genre'.")
        .When(v => v.ServiceType.Equals("Venue", StringComparison.OrdinalIgnoreCase) ||
                   v.ServiceType.Equals("Entertainment", StringComparison.OrdinalIgnoreCase));
  }

  private bool ContainRequiredAttributes(CreateVendorCommand command, string? attributesJson)
  {
    if (string.IsNullOrWhiteSpace(attributesJson))
    {
      // If attributes are empty and type requires them, this is invalid.
      return false;
    }

    try
    {
      var json = JsonDocument.Parse(attributesJson);

      if (command.ServiceType.Equals("Venue", StringComparison.OrdinalIgnoreCase))
      {
        // Venue: Must have Capacity (must be a number)
        if (json.RootElement.TryGetProperty("Capacity", out var capacityElement) &&
            capacityElement.ValueKind == JsonValueKind.Number)
        {
          return capacityElement.GetInt32() > 0;
        }
        return false;
      }

      if (command.ServiceType.Equals("Entertainment", StringComparison.OrdinalIgnoreCase))
      {
        // Entertainment: Must have Genre (must be a non-empty string)
        if (json.RootElement.TryGetProperty("Genre", out var genreElement) &&
            genreElement.ValueKind == JsonValueKind.String)
        {
          return !string.IsNullOrWhiteSpace(genreElement.GetString());
        }
        return false;
      }

      return true; // If we reach here, it's a valid JSON for a non-specialized type
    }
    catch (JsonException)
    {
      return false; // Invalid JSON format
    }
    catch
    {
      return false; // Catch all other parsing/logic errors
    }
  }
}

// =======================================================
// FILE: src/Application/Tasks/Queries/GetTasksQueryHandler.cs
// =======================================================
// FILE: src/Application/Tasks/Queries/GetTasksQueryHandler.cs (MODIFIED)
using AutoMapper;
using AutoMapper.QueryableExtensions;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Common.Interfaces;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Tasks.Queries
{
  public class GetTasksQueryHandler : IRequestHandler<GetTasksQuery, IEnumerable<TaskDto>>
  {
    private readonly IApplicationDbContext _context;
    private readonly IMapper _mapper;

    public GetTasksQueryHandler(IApplicationDbContext context, IMapper mapper)
    {
      _context = context;
      _mapper = mapper;
    }

    public async Task<IEnumerable<TaskDto>> Handle(GetTasksQuery request, CancellationToken cancellationToken)
    {
      // Start with a base queryable
      var query = _context.Tasks
          .AsNoTracking()
          .AsQueryable();

      // --- PHASE 32 FIX: EAGER LOAD VENDOR FOR DTO MAPPING ---
      query = query.Include(t => t.Vendor);
      // -----------------------------------------------------

      // Conditionally apply filters
      if (request.ContactId.HasValue)
      {
        query = query.Where(t => t.ContactId == request.ContactId);
      }

      if (request.EventId.HasValue)
      {
        query = query.Where(t => t.EventId == request.EventId);
      }

      // NEW: Apply Vendor Filter
      if (request.VendorId.HasValue)
      {
        query = query.Where(t => t.VendorId == request.VendorId);
      }

      // Project and execute
      return await query
          .OrderByDescending(t => t.CreatedAt)
          .ProjectTo<TaskDto>(_mapper.ConfigurationProvider)
          .ToListAsync(cancellationToken);
    }
  }
}

// =======================================================
// FILE: src/Application/Tasks/Queries/GetTasksForContactQuery.cs
// =======================================================
using CRM_Vivid.Application.Common.Models;
using MediatR;

namespace CRM_Vivid.Application.Tasks.Queries
{
  public class GetTasksForContactQuery : IRequest<IEnumerable<TaskDto>>
  {
    public Guid ContactId { get; set; }
  }
}

// =======================================================
// FILE: src/Application/Tasks/Queries/GetTaskByIdQuery.cs
// =======================================================
using CRM_Vivid.Application.Common.Models;
using MediatR;

namespace CRM_Vivid.Application.Tasks.Queries
{
  public class GetTaskByIdQuery : IRequest<TaskDto>
  {
    public Guid Id { get; set; }
  }
}

// =======================================================
// FILE: src/Application/Tasks/Queries/GetTasksForContactQueryHandler.cs
// =======================================================
using AutoMapper;
using AutoMapper.QueryableExtensions;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Common.Interfaces;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Tasks.Queries
{
  public class GetTasksForContactQueryHandler : IRequestHandler<GetTasksForContactQuery, IEnumerable<TaskDto>>
  {
    private readonly IApplicationDbContext _context;
    private readonly IMapper _mapper;

    public GetTasksForContactQueryHandler(IApplicationDbContext context, IMapper mapper)
    {
      _context = context;
      _mapper = mapper;
    }

    public async Task<IEnumerable<TaskDto>> Handle(GetTasksForContactQuery request, CancellationToken cancellationToken)
    {
      return await _context.Tasks
          .AsNoTracking()
          .Where(t => t.ContactId == request.ContactId)
          .OrderBy(t => t.DueDate)
          .ProjectTo<TaskDto>(_mapper.ConfigurationProvider)
          .ToListAsync(cancellationToken);
    }
  }
}

// =======================================================
// FILE: src/Application/Tasks/Queries/GetTaskByIdQueryHandler.cs
// =======================================================
using AutoMapper;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Exceptions;
using CRM_Vivid.Application.Common.Interfaces;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Tasks.Queries
{
  public class GetTaskByIdQueryHandler : IRequestHandler<GetTaskByIdQuery, TaskDto>
  {
    private readonly IApplicationDbContext _context;
    private readonly IMapper _mapper;

    public GetTaskByIdQueryHandler(IApplicationDbContext context, IMapper mapper)
    {
      _context = context;
      _mapper = mapper;
    }

    public async Task<TaskDto> Handle(GetTaskByIdQuery request, CancellationToken cancellationToken)
    {
      var entity = await _context.Tasks
          .AsNoTracking()
          .FirstOrDefaultAsync(t => t.Id == request.Id, cancellationToken);

      if (entity == null)
      {
        throw new NotFoundException(nameof(Core.Entities.Task), request.Id);
      }

      return _mapper.Map<TaskDto>(entity);
    }
  }
}

// =======================================================
// FILE: src/Application/Tasks/Queries/GetTasksQuery.cs
// =======================================================
// src/Application/Tasks/Queries/GetTasksQuery.cs
using CRM_Vivid.Application.Common.Models;
using MediatR;

namespace CRM_Vivid.Application.Tasks.Queries
{
  public class GetTasksQuery : IRequest<IEnumerable<TaskDto>>
  {
    public Guid? ContactId { get; set; }
    public Guid? EventId { get; set; }
    // NEW: Add VendorId to allow filtering by vendor
    public Guid? VendorId { get; set; }
  }
}

// =======================================================
// FILE: src/Application/Tasks/Commands/CreateTaskCommand.cs
// =======================================================
// FILE: src/Application/Tasks/Commands/CreateTaskCommand.cs
// src/Application/Tasks/Commands/CreateTaskCommand.cs
using CRM_Vivid.Core.Enum;
using MediatR;

namespace CRM_Vivid.Application.Tasks.Commands
{
  public class CreateTaskCommand : IRequest<Guid>
  {
    public string? Title
    {
      get; set;
    }
    public string? Description { get; set; }
    public Core.Enum.TaskStatus Status
    {
      get; set;
    } = Core.Enum.TaskStatus.NotStarted;
    public TaskPriority Priority { get; set; } = TaskPriority.Medium;
    public DateTime? DueDate
    {
      get; set;
    }

    // --- Original GUID Foreign Keys ---
    public Guid? ContactId { get; set; }
    public Guid? EventId
    {
      get; set;
    }
    public Guid? VendorId
    {
      get; set;
    }

    // --- NEW: PHASE 29 STRING-BASED RESOLUTION FIELDS ---
    public string? ContactEmail { get; set; }
    public string? VendorName { get; set; }
    public string? EventName { get; set; }
  }
}

// =======================================================
// FILE: src/Application/Tasks/Commands/DeleteTaskCommand.cs
// =======================================================
using MediatR;

namespace CRM_Vivid.Application.Tasks.Commands
{
  public class DeleteTaskCommand : IRequest<Unit>
  {
    public Guid Id { get; set; }
  }
}

// =======================================================
// FILE: src/Application/Tasks/Commands/CreateTaskCommandHandler.cs
// =======================================================
// FILE: src/Application/Tasks/Commands/CreateTaskCommandHandler.cs
using AutoMapper;
using CRM_Vivid.Application.Common.Interfaces;
using MediatR;
using Microsoft.EntityFrameworkCore; // Required for FirstOrDefaultAsync

namespace CRM_Vivid.Application.Tasks.Commands;

public class CreateTaskCommandHandler : IRequestHandler<CreateTaskCommand, Guid>
{
  private readonly IApplicationDbContext _context;
  private readonly IMapper _mapper;
  private readonly ICurrentUserService _currentUserService;

  public CreateTaskCommandHandler(IApplicationDbContext context, IMapper mapper, ICurrentUserService currentUserService)
  {
    _context = context;
    _mapper = mapper;
    _currentUserService = currentUserService;
  }

  public async Task<Guid> Handle(CreateTaskCommand request, CancellationToken cancellationToken)
  {
    // --- PHASE 29: Resolve IDs from String Lookups ---

    // 1. Resolve ContactId via Email
    if (request.ContactId == null && !string.IsNullOrWhiteSpace(request.ContactEmail))
    {
      var contact = await _context.Contacts
          .AsNoTracking()
          .FirstOrDefaultAsync(c => c.Email == request.ContactEmail, cancellationToken);
      request.ContactId = contact?.Id;
    }

    // 2. Resolve VendorId via Name
    if (request.VendorId == null && !string.IsNullOrWhiteSpace(request.VendorName))
    {
      var vendor = await _context.Vendors
          .AsNoTracking()
          .FirstOrDefaultAsync(v => v.Name == request.VendorName, cancellationToken);
      request.VendorId = vendor?.Id;
    }

    // 3. Resolve EventId via Name
    if (request.EventId == null && !string.IsNullOrWhiteSpace(request.EventName))
    {
      var eventEntity = await _context.Events
          .AsNoTracking()
          .FirstOrDefaultAsync(e => e.Name == request.EventName, cancellationToken);
      request.EventId = eventEntity?.Id;
    }

    // --- End Resolution ---

    var entity = _mapper.Map<Core.Entities.Task>(request);

    // --- PHASE 37: ASSIGN OWNER ---
    entity.CreatedByUserId = _currentUserService.CurrentUserId;

    // Per Rule #2: Use UTC
    if (request.DueDate.HasValue)
    {
      entity.DueDate = request.DueDate.Value.ToUniversalTime();
    }

    entity.CreatedAt = DateTime.UtcNow;

    await _context.Tasks.AddAsync(entity, cancellationToken);
    await _context.SaveChangesAsync(cancellationToken);

    return entity.Id;
  }
}

// =======================================================
// FILE: src/Application/Tasks/Commands/UpdateTaskCommandHandler.cs
// =======================================================
// FILE: src/Application/Tasks/Commands/UpdateTaskCommandHandler.cs (MODIFIED)
using AutoMapper;
using CRM_Vivid.Application.Exceptions;
using CRM_Vivid.Application.Common.Interfaces;
using MediatR;
using Microsoft.EntityFrameworkCore;
using CRM_Vivid.Core.Entities; // Required for entity lookup

namespace CRM_Vivid.Application.Tasks.Commands
{
  public class UpdateTaskCommandHandler : IRequestHandler<UpdateTaskCommand, Unit>
  {
    private readonly IApplicationDbContext _context;
    private readonly IMapper _mapper;

    public UpdateTaskCommandHandler(IApplicationDbContext context, IMapper mapper)
    {
      _context = context;
      _mapper = mapper;
    }

    public async Task<Unit> Handle(UpdateTaskCommand request, CancellationToken cancellationToken)
    {
      var entity = await _context.Tasks.FindAsync(new object[] { request.Id }, cancellationToken);

      if (entity == null)
      {
        throw new NotFoundException(nameof(Core.Entities.Task), request.Id);
      }

      // --- PHASE 30: HARDENED RESOLUTION LOGIC ---

      // Helper function to handle lookups
      Func<string, Type, Guid?> resolveId = (nameOrEmail, entityType) =>
      {
        if (string.IsNullOrWhiteSpace(nameOrEmail)) return null;

        if (entityType == typeof(Contact))
        {
          var contact = _context.Contacts.AsNoTracking().FirstOrDefault(c => c.Email == nameOrEmail);
          if (contact == null) throw new NotFoundException(nameof(Contact), nameOrEmail);
          return contact.Id;
        }
        if (entityType == typeof(Vendor))
        {
          var vendor = _context.Vendors.AsNoTracking().FirstOrDefault(v => v.Name == nameOrEmail);
          if (vendor == null) throw new NotFoundException(nameof(Vendor), nameOrEmail);
          return vendor.Id;
        }
        if (entityType == typeof(Event))
        {
          var eventEntity = _context.Events.AsNoTracking().FirstOrDefault(e => e.Name == nameOrEmail);
          if (eventEntity == null) throw new NotFoundException(nameof(Event), nameOrEmail);
          return eventEntity.Id;
        }
        return null;
      };

      // 1. Resolve ContactId via Email
      // Only perform lookup if ContactId is null AND ContactEmail is provided
      if (request.ContactId == null && !string.IsNullOrWhiteSpace(request.ContactEmail))
      {
        request.ContactId = resolveId(request.ContactEmail, typeof(Contact));
      }

      // 2. Resolve VendorId via Name
      if (request.VendorId == null && !string.IsNullOrWhiteSpace(request.VendorName))
      {
        request.VendorId = resolveId(request.VendorName, typeof(Vendor));
      }

      // 3. Resolve EventId via Name
      if (request.EventId == null && !string.IsNullOrWhiteSpace(request.EventName))
      {
        request.EventId = resolveId(request.EventName, typeof(Event));
      }

      // --- End Hardening ---

      _mapper.Map(request, entity);

      // Per Rule #2: Use UTC
      if (request.DueDate.HasValue)
      {
        entity.DueDate = request.DueDate.Value.ToUniversalTime();
      }

      // The update command doesn't implicitly clear GUIDs, so we map them manually 
      // from the potentially resolved/nulled request.
      entity.ContactId = request.ContactId;
      entity.EventId = request.EventId;
      entity.VendorId = request.VendorId;

      entity.UpdatedAt = DateTime.UtcNow;

      _context.Tasks.Update(entity);
      await _context.SaveChangesAsync(cancellationToken);

      return Unit.Value;
    }
  }
}

// =======================================================
// FILE: src/Application/Tasks/Commands/CreateTaskCommandValidator.cs
// =======================================================
// FILE: src/Application/Tasks/Commands/CreateTaskCommandValidator.cs
using FluentValidation;

namespace CRM_Vivid.Application.Tasks.Commands
{
  public class CreateTaskCommandValidator : AbstractValidator<CreateTaskCommand>
  {
    public CreateTaskCommandValidator()
    {

      RuleFor(v => v.Title)
          .NotNull()
          .NotEmpty().WithMessage("Title is required.")
          .MaximumLength(200).WithMessage("Title must not exceed 200 characters.");

      RuleFor(v => v.Description)
          .MaximumLength(5000).WithMessage("Description must not exceed 5000 characters.");


      // --- PHASE 29: ENFORCE ID/STRING MUTUAL EXCLUSION & LINKAGE ---

      // 1. Mutual Exclusion Rules
      RuleFor(v => v.ContactId)
          .Empty().When(v => !string.IsNullOrWhiteSpace(v.ContactEmail))
          .WithMessage("Cannot provide both Contact ID and Contact Email.");

      RuleFor(v => v.EventId)
          .Empty().When(v => !string.IsNullOrWhiteSpace(v.EventName))
          .WithMessage("Cannot provide both Event ID and Event Name.");

      RuleFor(v => v.VendorId)
          .Empty().When(v => !string.IsNullOrWhiteSpace(v.VendorName))
          .WithMessage("Cannot provide both Vendor ID and Vendor Name.");

      // 2. Mandatory Linkage Rule
      RuleFor(v => v)
          .Must(HaveAtLeastOneLink)
          .WithMessage("A task must be associated with at least one entity (Contact, Event, or Vendor) via ID or Name/Email.");
    }

    private bool HaveAtLeastOneLink(CreateTaskCommand command)
    {
      // Check if any of the GUID fields OR their corresponding string/email fields are populated
      return command.ContactId.HasValue || !string.IsNullOrWhiteSpace(command.ContactEmail) ||
             command.EventId.HasValue || !string.IsNullOrWhiteSpace(command.EventName) ||
             command.VendorId.HasValue || !string.IsNullOrWhiteSpace(command.VendorName);
    }
  }
}

// =======================================================
// FILE: src/Application/Tasks/Commands/UpdateTaskCommand.cs
// =======================================================
// FILE: src/Application/Tasks/Commands/UpdateTaskCommand.cs (MODIFIED)
using CRM_Vivid.Core.Enum;
using MediatR;

namespace CRM_Vivid.Application.Tasks.Commands
{
  public class UpdateTaskCommand : IRequest<Unit>
  {
    public Guid Id { get; set; }
    public string Title { get; set; } = string.Empty;
    public string? Description { get; set; }
    public Core.Enum.TaskStatus Status { get; set; }
    public TaskPriority Priority { get; set; }
    public DateTime? DueDate { get; set; }

    // Existing GUID Foreign Keys
    public Guid? ContactId { get; set; }
    public Guid? EventId { get; set; }
    public Guid? VendorId { get; set; } // NOTE: Assumed presence from previous phase work

    // --- NEW: PHASE 30 STRING-BASED RESOLUTION FIELDS (Optional) ---
    public string? ContactEmail { get; set; }
    public string? VendorName { get; set; }
    public string? EventName { get; set; }
  }
}

// =======================================================
// FILE: src/Application/Tasks/Commands/UpdateTaskCommandValidator.cs
// =======================================================
// FILE: src/Application/Tasks/Commands/UpdateTaskCommandValidator.cs
using FluentValidation;

namespace CRM_Vivid.Application.Tasks.Commands
{
  public class UpdateTaskCommandValidator : AbstractValidator<UpdateTaskCommand>
  {
    public UpdateTaskCommandValidator()
    {
      RuleFor(v => v.Id).NotEmpty();
      RuleFor(v => v.Title)
          .NotEmpty().WithMessage("Title is required.")
          .MaximumLength(200).WithMessage("Title must not exceed 200 characters.");
      RuleFor(v => v.Description)
          .MaximumLength(5000).WithMessage("Description must not exceed 5000 characters.");

      // --- PHASE 30: ENFORCE ID/STRING MUTUAL EXCLUSION ---

      // Must not provide both ID and name/email for the same entity
      RuleFor(v => v.ContactId)
          .Empty().When(v => !string.IsNullOrWhiteSpace(v.ContactEmail))
          .WithMessage("Cannot provide both Contact ID and Contact Email.");

      RuleFor(v => v.EventId)
          .Empty().When(v => !string.IsNullOrWhiteSpace(v.EventName))
          .WithMessage("Cannot provide both Event ID and Event Name.");

      RuleFor(v => v.VendorId)
          .Empty().When(v => !string.IsNullOrWhiteSpace(v.VendorName))
          .WithMessage("Cannot provide both Vendor ID and Vendor Name.");

      // NOTE: We don't enforce mandatory linkage on UPDATE because a user may only be updating the Title or DueDate.
    }
  }
}

// =======================================================
// FILE: src/Application/Tasks/Commands/DeleteTaskCommandHandler.cs
// =======================================================
using CRM_Vivid.Application.Exceptions;
using CRM_Vivid.Application.Common.Interfaces;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Tasks.Commands
{
  // This should be the ONLY class in this file
  public class DeleteTaskCommandHandler : IRequestHandler<DeleteTaskCommand, Unit>
  {
    private readonly IApplicationDbContext _context;

    public DeleteTaskCommandHandler(IApplicationDbContext context)
    {
      _context = context;
    }

    public async Task<Unit> Handle(DeleteTaskCommand request, CancellationToken cancellationToken)
    {
      var entity = await _context.Tasks
          .FirstOrDefaultAsync(t => t.Id == request.Id, cancellationToken);

      if (entity == null)
      {
        throw new NotFoundException(nameof(Core.Entities.Task), request.Id);
      }

      _context.Tasks.Remove(entity);
      await _context.SaveChangesAsync(cancellationToken);

      return Unit.Value;
    }
  }
}

// =======================================================
// FILE: src/Application/Financials/Queries/GetEventFinancialsQueryHandler.cs
// =======================================================
using AutoMapper;
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Core.Entities;
using CRM_Vivid.Application.Exceptions;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Financials.Queries
{
  public class GetEventFinancialsQueryHandler : IRequestHandler<GetEventFinancialsQuery, EventFinancialsDto>
  {
    private readonly IApplicationDbContext _context;
    private readonly IMapper _mapper;

    public GetEventFinancialsQueryHandler(IApplicationDbContext context, IMapper mapper)
    {
      _context = context;
      _mapper = mapper;
    }

    public async Task<EventFinancialsDto> Handle(GetEventFinancialsQuery request, CancellationToken cancellationToken)
    {
      // 1. Fetch Event with Budget and deep relations (Expenses -> Vendor/Document)
      var eventEntity = await _context.Events
          .Include(e => e.Budget)
          .ThenInclude(b => b!.Expenses)
          .ThenInclude(ex => ex.Vendor)
          .Include(e => e.Budget)
          .ThenInclude(b => b!.Expenses)
          .ThenInclude(ex => ex.LinkedDocument)
          .FirstOrDefaultAsync(e => e.Id == request.EventId, cancellationToken);

      if (eventEntity == null)
      {
        throw new NotFoundException(nameof(Event), request.EventId);
      }

      // 2. Initialize DTO (PHASE 26 FIX HERE)
      var dto = new EventFinancialsDto
      {
        EventId = eventEntity.Id,
        EventName = eventEntity.Name,
        Currency = eventEntity.Budget?.Currency ?? "USD",
        BudgetTotal = eventEntity.Budget?.TotalAmount ?? 0,
        Notes = eventEntity.Budget?.Notes,

        // --- PHASE 26 FIX: EXPOSE ISLOCKED STATUS ---
        IsLocked = eventEntity.Budget?.IsLocked ?? false // ADDED
      };

      // 3. Process Expenses if Budget exists
      if (eventEntity.Budget != null)
      {
        dto.Expenses = _mapper.Map<List<ExpenseDto>>(eventEntity.Budget.Expenses);

        // The Calculator Logic
        dto.TotalSpent = dto.Expenses.Sum(e => e.Amount);
      }

      return dto;
    }
  }
}

// =======================================================
// FILE: src/Application/Financials/Queries/GetEventFinancialsQuery.cs
// =======================================================
using CRM_Vivid.Application.Common.Models;
using MediatR;

namespace CRM_Vivid.Application.Financials.Queries
{
  public record GetEventFinancialsQuery(Guid EventId) : IRequest<EventFinancialsDto>;
}

// =======================================================
// FILE: src/Application/Financials/Commands/UpsertBudgetCommand.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Entities;
using CRM_Vivid.Application.Exceptions;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Financials.Commands
{
  public record UpsertBudgetCommand(Guid EventId, decimal TotalAmount, string Currency, string? Notes) : IRequest<Guid>;

  public class UpsertBudgetCommandHandler : IRequestHandler<UpsertBudgetCommand, Guid>
  {
    private readonly IApplicationDbContext _context;

    public UpsertBudgetCommandHandler(IApplicationDbContext context)
    {
      _context = context;
    }

    public async Task<Guid> Handle(UpsertBudgetCommand request, CancellationToken cancellationToken)
    {
      var eventEntity = await _context.Events
          .Include(e => e.Budget)
          .FirstOrDefaultAsync(e => e.Id == request.EventId, cancellationToken);

      if (eventEntity == null)
      {
        throw new NotFoundException(nameof(Event), request.EventId);
      }

      if (eventEntity.Budget == null)
      {
        // Create
        var budget = new Budget
        {
          Id = Guid.NewGuid(),
          EventId = request.EventId,
          TotalAmount = request.TotalAmount,
          Currency = request.Currency,
          Notes = request.Notes
        };
        _context.Budgets.Add(budget);
        await _context.SaveChangesAsync(cancellationToken);
        return budget.Id;
      }
      else
      {
        // Update
        eventEntity.Budget.TotalAmount = request.TotalAmount;
        eventEntity.Budget.Currency = request.Currency;
        eventEntity.Budget.Notes = request.Notes;

        await _context.SaveChangesAsync(cancellationToken);
        return eventEntity.Budget.Id;
      }
    }
  }
}

// =======================================================
// FILE: src/Application/Financials/Commands/AddExpenseCommand.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Entities;
using CRM_Vivid.Core.Enum;
using CRM_Vivid.Application.Exceptions;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Financials.Commands
{
  public record AddExpenseCommand(
      Guid EventId, // We look up Budget via EventId for safety
      string Description,
      decimal Amount,
      DateTime DateIncurred,
      string Category, // "Catering", "Venue", etc.
      Guid? VendorId,
      int? LinkedDocumentId
  ) : IRequest<Guid>;

  public class AddExpenseCommandHandler : IRequestHandler<AddExpenseCommand, Guid>
  {
    private readonly IApplicationDbContext _context;

    public AddExpenseCommandHandler(IApplicationDbContext context)
    {
      _context = context;
    }

    public async Task<Guid> Handle(AddExpenseCommand request, CancellationToken cancellationToken)
    {
      // 1. Find the Budget for this Event
      var budget = await _context.Budgets
          .FirstOrDefaultAsync(b => b.EventId == request.EventId, cancellationToken);

      if (budget == null)
      {
        // You cannot add an expense if a budget hasn't been initialized (UpsertBudget first)
        throw new NotFoundException("Budget for Event", request.EventId);
      }

      // 2. Create Expense
      var entity = new Expense
      {
        Id = Guid.NewGuid(),
        BudgetId = budget.Id,
        Description = request.Description,
        Amount = request.Amount,
        DateIncurred = request.DateIncurred,
        VendorId = request.VendorId,
        LinkedDocumentId = request.LinkedDocumentId
      };

      // Parse Enum (Case insensitive)
      if (Enum.TryParse<ExpenseCategory>(request.Category, true, out var cat))
      {
        entity.Category = cat;
      }
      else
      {
        entity.Category = ExpenseCategory.General;
      }

      _context.Expenses.Add(entity);
      await _context.SaveChangesAsync(cancellationToken);

      return entity.Id;
    }
  }
}

// =======================================================
// FILE: src/Application/Contacts/Queries/GetContactByIdQuery.cs
// =======================================================
using CRM_Vivid.Application.Common.Models;
using MediatR;

namespace CRM_Vivid.Application.Contacts.Queries;

public record GetContactByIdQuery : IRequest<ContactDto>
{
  public Guid Id { get; set; }
}

// =======================================================
// FILE: src/Application/Contacts/Queries/GetActivityStreamQuery.cs
// =======================================================
// FILE: src/Application/Contacts/Queries/GetActivityStreamQuery.cs (FINAL CORRECTED VERSION)
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Common.Interfaces;
using MediatR;
using Microsoft.EntityFrameworkCore;
using System.Linq;
using System.Collections.Generic; // Required for List

namespace CRM_Vivid.Application.Contacts.Queries;

public record GetActivityStreamQuery(Guid ContactId) : IRequest<List<ActivityDto>>;

public class GetActivityStreamQueryHandler : IRequestHandler<GetActivityStreamQuery, List<ActivityDto>>
{
  private readonly IApplicationDbContext _context;

  public GetActivityStreamQueryHandler(IApplicationDbContext context)
  {
    _context = context;
  }

  public async Task<List<ActivityDto>> Handle(GetActivityStreamQuery request, CancellationToken cancellationToken)
  {
    var contactId = request.ContactId;

    // --- 1. Map Tasks and execute immediately ---
    var taskActivities = await _context.Tasks
        .Where(t => t.ContactId == contactId)
        .Select(t => new ActivityDto
        {
          Id = t.Id,
          Timestamp = t.CreatedAt,
          ActivityType = "TASK",
          Title = t.Title,
          Content = t.Description,
          Status = t.Status.ToString(),
          RelatedEntityId = t.EventId
        })
        .ToListAsync(cancellationToken); // Execute query 1

    // --- 2. Map Notes and execute immediately ---
    var noteActivities = await _context.Notes
        .Where(n => n.ContactId == contactId)
        .Select(n => new ActivityDto
        {
          Id = n.Id,
          Timestamp = n.CreatedAt,
          ActivityType = "NOTE",
          Title = n.Title,
          Content = n.Content,
          Status = "Logged",
          RelatedEntityId = n.EventId
        })
        .ToListAsync(cancellationToken); // Execute query 2

    // --- 3. Map EmailLogs and execute immediately ---
    var emailActivities = await _context.EmailLogs
        .Where(e => e.ContactId == contactId)
        .Select(e => new ActivityDto
        {
          Id = e.Id,
          Timestamp = e.SentAt,
          ActivityType = "EMAIL",
          Title = e.Subject,
          Content = e.Body != null ? (e.Body.Length > 200 ? e.Body.Substring(0, 200) + "..." : e.Body) : null,
          Status = e.IsSuccess ? "Sent Success" : "Sent Failed",
          RelatedEntityId = e.EventId ?? e.TemplateId
        })
        .ToListAsync(cancellationToken); // Execute query 3

    // --- 4. Merge (In Memory) and Order ---
    var activityStream = taskActivities
        .Concat(noteActivities) // Concatenate in memory (C# List<T> operation)
        .Concat(emailActivities) // No more complex LINQ .Union() to break the provider
        .OrderByDescending(a => a.Timestamp)
        .ToList();

    return activityStream;
  }
}

// =======================================================
// FILE: src/Application/Contacts/Queries/GetEventsForContactQueryHandler.cs
// =======================================================
// src/Application/Contacts/Queries/GetEventsForContactQueryHandler.cs (FINAL CORRECTED VERSION)

using AutoMapper;
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Application.Common.Models;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Contacts.Queries;

public record GetEventsForContactQuery : IRequest<List<EventDto>>
{
  public Guid ContactId { get; init; }
}

public class GetEventsForContactQueryHandler : IRequestHandler<GetEventsForContactQuery, List<EventDto>>
{
  private readonly IApplicationDbContext _context;
  private readonly IMapper _mapper;

  public GetEventsForContactQueryHandler(IApplicationDbContext context, IMapper mapper)
  {
    _context = context;
    _mapper = mapper;
  }

  public async Task<List<EventDto>> Handle(GetEventsForContactQuery request, CancellationToken cancellationToken)
  {
    // FIX: Force materialization of the Event entities first (ToListAsync), 
    // then use the standard mapper (.Map) to convert the list to DTOs.
    // This guarantees the Event entity data is loaded before mapping occurs.

    var events = await _context.EventContacts
        .Where(ec => ec.ContactId == request.ContactId)
        .Select(ec => ec.Event)
        .ToListAsync(cancellationToken); // Materialize the list of Event entities here

    // Now map the materialized list of Event entities to EventDto
    return _mapper.Map<List<EventDto>>(events);
  }
}

// =======================================================
// FILE: src/Application/Contacts/Queries/GetContactByIdQueryHandler.cs
// =======================================================
using AutoMapper;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Application.Exceptions;
using MediatR;
using CRM_Vivid.Core.Entities;

namespace CRM_Vivid.Application.Contacts.Queries;

public class GetContactByIdQueryHandler : IRequestHandler<GetContactByIdQuery, ContactDto?>
{
  private readonly IApplicationDbContext _context;
  private readonly IMapper _mapper;

  public GetContactByIdQueryHandler(IApplicationDbContext context, IMapper mapper)
  {
    _context = context;
    _mapper = mapper;
  }

  public async Task<ContactDto?> Handle(GetContactByIdQuery request, CancellationToken cancellationToken)
  {
    var contact = await _context.Contacts.FindAsync(
      new object[] { request.Id },
      cancellationToken: cancellationToken);

    if (contact == null)
    {
      throw new NotFoundException(nameof(Contact), request.Id);
    }

    return _mapper.Map<ContactDto?>(contact);

  }
}

// =======================================================
// FILE: src/Application/Contacts/Queries/GetContactTaskSummaryQuery.cs
// =======================================================
// FILE: src/Application/Contacts/Queries/GetContactTaskSummaryQuery.cs (NEW FILE)
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Application.Exceptions;
using CRM_Vivid.Core.Entities;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Contacts.Queries;

public record GetContactTaskSummaryQuery(Guid ContactId) : IRequest<ContactTaskSummaryDto>;

public class GetContactTaskSummaryQueryHandler : IRequestHandler<GetContactTaskSummaryQuery, ContactTaskSummaryDto>
{
  private readonly IApplicationDbContext _context;

  public GetContactTaskSummaryQueryHandler(IApplicationDbContext context)
  {
    _context = context;
  }

  public async Task<ContactTaskSummaryDto> Handle(GetContactTaskSummaryQuery request, CancellationToken cancellationToken)
  {
    var now = DateTime.UtcNow;

    var result = await _context.Contacts
        .Where(c => c.Id == request.ContactId)
        .Select(c => new ContactTaskSummaryDto
        {
          ContactId = c.Id,
          ContactName = $"{c.FirstName} {c.LastName}",

          // Calculate 1: Total Tasks Assigned (via Tasks back-reference)
          TotalTasksAssigned = c.Tasks.Count(),

          // Calculate 2: Total Tasks Completed
          TotalTasksCompleted = c.Tasks.Count(t => t.Status == Core.Enum.TaskStatus.Completed),

          // Calculate 3: Total Tasks Overdue 
          // Status is NOT Completed AND DueDate is in the past (before now)
          TotalTasksOverdue = c.Tasks.Count(t =>
                  t.Status != Core.Enum.TaskStatus.Completed &&
                  t.DueDate.HasValue &&
                  t.DueDate.Value < now)
        })
        .SingleOrDefaultAsync(cancellationToken);

    if (result == null)
    {
      throw new NotFoundException(nameof(Contact), request.ContactId);
    }

    return result;
  }
}

// =======================================================
// FILE: src/Application/Contacts/Queries/GetContactsQueryHandler.cs
// =======================================================
// FILE: src/Application/Contacts/Queries/GetContactsQueryHandler.cs (MODIFIED)
using AutoMapper;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Common.Interfaces;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Contacts.Queries;

public class GetContactsQueryHandler : IRequestHandler<GetContactsQuery, List<ContactDto>>
{
  private readonly IApplicationDbContext _context;
  private readonly IMapper _mapper;

  public GetContactsQueryHandler(IApplicationDbContext context, IMapper mapper)
  {
    _context = context;
    _mapper = mapper;
  }

  public async Task<List<ContactDto>> Handle(GetContactsQuery request, CancellationToken cancellationToken)
  {
    // --- PHASE 34 FIX: EXPLICITLY PROJECT ALL CONTACT FIELDS TO PREVENT 500 CRASH ---
    return await _context.Contacts
        .AsNoTracking()
        .Select(c => new ContactDto
        {
          Id = c.Id,
          FirstName = c.FirstName,
          LastName = c.LastName,
          Email = c.Email,
          PhoneNumber = c.PhoneNumber,
          Title = c.Title,
          Organization = c.Organization,

          // Phase 25 Fields (Must be projected)
          Stage = c.Stage,
          ConnectionStatus = c.ConnectionStatus,
          IsLead = c.IsLead,
          FollowUpCount = c.FollowUpCount,
          LastContactedAt = c.LastContactedAt,
          Source = c.Source,

          // Phase 34 Role field is intentionally left null here, as this is the global query,
          // where a Contact does not have a role. The event-specific query handles the Role.
          Role = null
        })
        .ToListAsync(cancellationToken);
    // ---------------------------------------------------------------------------------
  }
}

// =======================================================
// FILE: src/Application/Contacts/Queries/GetEmailLogsForContactQuery.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Exceptions;
using CRM_Vivid.Core.Entities;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Contacts.Queries;

public record GetEmailLogsForContactQuery(Guid ContactId) : IRequest<List<EmailLogDto>>;

public class GetEmailLogsForContactQueryHandler : IRequestHandler<GetEmailLogsForContactQuery, List<EmailLogDto>>
{
  private readonly IApplicationDbContext _context;

  public GetEmailLogsForContactQueryHandler(IApplicationDbContext context)
  {
    _context = context;
  }

  public async Task<List<EmailLogDto>> Handle(GetEmailLogsForContactQuery request, CancellationToken cancellationToken)
  {
    // Optional: Validate Contact exists first
    var contactExists = await _context.Contacts
        .AnyAsync(c => c.Id == request.ContactId, cancellationToken);

    if (!contactExists)
    {
      throw new NotFoundException(nameof(Contact), request.ContactId);
    }

    // Fetch Logs
    return await _context.EmailLogs
        .Where(e => e.ContactId == request.ContactId)
        .OrderByDescending(e => e.SentAt)
        .Select(e => new EmailLogDto
        {
          Id = e.Id,
          To = e.To,
          Subject = e.Subject,
          SentAt = e.SentAt,
          IsSuccess = e.IsSuccess,
          ErrorMessage = e.ErrorMessage
        })
        .ToListAsync(cancellationToken);
  }
}

// =======================================================
// FILE: src/Application/Contacts/Queries/GetContactsQuery.cs
// =======================================================
using CRM_Vivid.Application.Common.Models;
using MediatR;

namespace CRM_Vivid.Application.Contacts.Queries
{
  public record GetContactsQuery : IRequest<List<ContactDto>>
  {

  }
}



// =======================================================
// FILE: src/Application/Contacts/Commands/CreateContactCommandValidator.cs
// =======================================================
using CRM_Vivid.Application.Features.Contacts.Commands;
using CRM_Vivid.Application.Common.Interfaces;
using FluentValidation;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Contacts.Commands
{
  public class CreateContactCommandValidator : AbstractValidator<CreateContactCommand>
  {

    private readonly IApplicationDbContext _context;
    public CreateContactCommandValidator(IApplicationDbContext context)
    {
      _context = context;

      RuleFor(x => x.FirstName)
          .NotEmpty().WithMessage("First name is required.")
          .MaximumLength(100).WithMessage("First name must not exceed 100 characters.");

      RuleFor(x => x.LastName)
          .NotEmpty().WithMessage("Last name is required.")
          .MaximumLength(100).WithMessage("Last name must not exceed 100 characters.");

      RuleFor(x => x.Email)
          .NotEmpty().WithMessage("Email is required.")
          .EmailAddress().WithMessage("A valid email address is required.")
          .MustAsync(BeUniqueEmail).WithMessage("This email address is already in use.");

      RuleFor(x => x.PhoneNumber)
          .MaximumLength(20).WithMessage("Phone number must not exceed 20 characters.");

      RuleFor(x => x.Title)
                .MaximumLength(100).WithMessage("Title must not exceed 100 characters.");

      RuleFor(x => x.Organization)
          .MaximumLength(200).WithMessage("Organization must not exceed 200 characters.");

      RuleFor(v => v.Stage).IsInEnum().WithMessage("Invalid Lead Stage value.");
      RuleFor(v => v.ConnectionStatus).IsInEnum().WithMessage("Invalid Connection Status value.");
      RuleFor(v => v.Source).MaximumLength(100).When(v => v.Source != null);
    }

    private async Task<bool> BeUniqueEmail(string email, CancellationToken cancellationToken)
    {
      // Will return true if no contact exists with this email
      return await _context.Contacts
          .AllAsync(c => c.Email != email, cancellationToken);
    }
  }
}

// =======================================================
// FILE: src/Application/Contacts/Commands/DeleteContactCommandHandler.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using MediatR;

namespace CRM_Vivid.Application.Contacts.Commands;

public class DeleteContactCommandHandler : IRequestHandler<DeleteContactCommand, Unit>
{
  private readonly IApplicationDbContext _context;

  public DeleteContactCommandHandler(IApplicationDbContext context)
  {
    _context = context;
  }

  public async Task<Unit> Handle(DeleteContactCommand request, CancellationToken cancellationToken)
  {
    // 1. Find the existing contact by its ID
    var entity = await _context.Contacts.FindAsync(
        new object[] { request.Id },
        cancellationToken: cancellationToken);

    // 2. If it exists, remove it
    if (entity != null)
    {
      _context.Contacts.Remove(entity);
      await _context.SaveChangesAsync(cancellationToken);
    }

    // 3. If it didn't exist, we don't need to do anything.
    // In both cases, we return 'Unit.Value'
    return Unit.Value;
  }
}

// =======================================================
// FILE: src/Application/Contacts/Commands/InitializeTestFixturesCommand.cs
// =======================================================
// FILE: src/Application/Contacts/Commands/InitializeTestFixturesCommand.cs (FINAL CORRECTED VERSION)
using MediatR;
using System;
using CRM_Vivid.Core.Enum;
using CRM_Vivid.Application.Features.Contacts.Commands;
using CRM_Vivid.Application.Common.Interfaces; // Required for User Service/Scoping

namespace CRM_Vivid.Application.Contacts.Commands;

public record InitializeTestFixturesCommand : IRequest<Guid>;

public class InitializeTestFixturesCommandHandler : IRequestHandler<InitializeTestFixturesCommand, Guid>
{
  private readonly ISender _mediator;
  private readonly ICurrentUserService _currentUserService;

  // We inject ISender (Mediator) here so we can chain other commands
  public InitializeTestFixturesCommandHandler(ISender mediator, ICurrentUserService currentUserService)
  {
    _mediator = mediator;
    _currentUserService = currentUserService;
  }

  public async Task<Guid> Handle(InitializeTestFixturesCommand request, CancellationToken cancellationToken)
  {
    // The individual commands (CreateVendorCommand, CreateEventCommand, etc.) 
    // are responsible for setting the CreatedByUserId via the current scope.

    var uniqueSuffix = DateTime.UtcNow.Ticks.ToString();
    // 1. Create a Primary Vendor (ENSURE VALIDATION PASSES)
    var vendorId = await _mediator.Send(new Vendors.Commands.CreateVendorCommand
    {
      Name = "The Test Caterer",
      Email = $"test.vendor.{uniqueSuffix}@vivid.com",
      ServiceType = VendorType.Catering.ToString(),
      // FIX: Correct JSON string for Attributes field.
      Attributes = "{}"
    });

    // 2. Create a Primary Contact 
    var contactId = await _mediator.Send(new CreateContactCommand
    {
      FirstName = "Test",
      LastName = "Client",
      Email = $"test.client.{uniqueSuffix}@vivid.com",
      Stage = LeadStage.InDiscussion
    });

    // 3. Create a Primary Event (ENSURE VALIDATION PASSES)
    var eventId = await _mediator.Send(new Events.Commands.CreateEventCommand
    {
      Name = "Fixture Test Event",
      StartDateTime = DateTime.UtcNow.AddDays(30),
      EndDateTime = DateTime.UtcNow.AddDays(30).AddHours(4),
      IsPublic = false,
      // FIX: Ensure Location is set to pass required validation.
      Location = "Virtual Test Hall",
      Description = "Standard fixture event for audit."
    });

    // 4. Link Contact to Event 
    await _mediator.Send(new Events.Commands.AddContactToEventCommand
    {
      EventId = eventId,
      ContactId = contactId,
      Role = "Client Lead"
    });

    // 5. Link Vendor to Event 
    await _mediator.Send(new Events.Commands.AddVendorToEventCommand
    {
      EventId = eventId,
      VendorId = vendorId,
      Role = "Primary Catering"
    });

    return contactId;
  }
}

// =======================================================
// FILE: src/Application/Contacts/Commands/CreateContactCommand.cs
// =======================================================
using CRM_Vivid.Core.Enum;
using MediatR;

namespace CRM_Vivid.Application.Features.Contacts.Commands;

public class CreateContactCommand : IRequest<Guid>
{
  public string FirstName { get; set; } = string.Empty;
  public string? LastName { get; set; }
  public string Email { get; set; } = string.Empty;
  public string? PhoneNumber { get; set; }
  public string? Title { get; set; }
  public string? Organization { get; set; }

  public LeadStage Stage { get; init; } = Core.Enum.LeadStage.NewLead;
  public ConnectionStatus ConnectionStatus { get; init; } = Core.Enum.ConnectionStatus.NeedToMeet;
  public string? Source { get; init; }
}

// =======================================================
// FILE: src/Application/Contacts/Commands/UpdateContactCommandValidator.cs
// =======================================================
using FluentValidation;

namespace CRM_Vivid.Application.Contacts.Commands;

public class UpdateContactCommandValidator : AbstractValidator<UpdateContactCommand>
{
  public UpdateContactCommandValidator()
  {
    RuleFor(v => v.Id).NotEmpty().WithMessage("Contact ID is required for update.");
    RuleFor(v => v.FirstName).NotEmpty().MaximumLength(100);
    RuleFor(v => v.Email).NotEmpty().EmailAddress().MaximumLength(200);

    // Validation for NEW Pipeline Fields
    RuleFor(v => v.Stage).IsInEnum().WithMessage("Invalid Lead Stage value.");
    RuleFor(v => v.ConnectionStatus).IsInEnum().WithMessage("Invalid Connection Status value.");
    RuleFor(v => v.Source).MaximumLength(100).When(v => v.Source != null);
  }
}

// =======================================================
// FILE: src/Application/Contacts/Commands/UpdateContactCommand.cs
// =======================================================
using CRM_Vivid.Core.Enum;
using MediatR;

namespace CRM_Vivid.Application.Contacts.Commands;

// This command implements IRequest<Unit>, which means it will
// execute and return 'nothing' (a 'Unit' value) upon success.
public class UpdateContactCommand : IRequest<Unit>
{
  // We need the Id to know WHICH contact to update.
  public Guid Id { get; set; }

  // The rest of the fields are the new values.
  public string FirstName { get; set; } = string.Empty;
  public string? LastName { get; set; }
  public string Email { get; set; } = string.Empty;
  public string? PhoneNumber { get; set; }
  public string? Title { get; set; }
  public string? Organization { get; set; }

  public LeadStage Stage { get; init; }
  public ConnectionStatus ConnectionStatus { get; init; }
  public string? Source { get; init; }

  // Explicit action to signal a new follow-up (Diara's "1st, 2nd, 3rd follow ups")
  public bool IncrementFollowUpCount { get; init; } = false;
}

// =======================================================
// FILE: src/Application/Contacts/Commands/UpdateContactCommandHandler.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Application.Exceptions;
using CRM_Vivid.Core.Entities;
using CRM_Vivid.Core.Enum;
using MediatR;

namespace CRM_Vivid.Application.Contacts.Commands;

public class UpdateContactCommandHandler : IRequestHandler<UpdateContactCommand, Unit>
{
  private readonly IApplicationDbContext _context;

  public UpdateContactCommandHandler(IApplicationDbContext context)
  {
    _context = context;
  }

  public async Task<Unit> Handle(UpdateContactCommand request, CancellationToken cancellationToken)
  {
    // 1. Find the existing contact by its ID
    var entity = await _context.Contacts.FindAsync(
        new object[] { request.Id },
        cancellationToken: cancellationToken);

    // 2. Add proper Exception Handling
    if (entity == null)
    {
      throw new NotFoundException(nameof(Contact), request.Id);
    }

    // 3. Map the standard values
    entity.FirstName = request.FirstName;
    entity.LastName = request.LastName;
    entity.Email = request.Email;
    entity.PhoneNumber = request.PhoneNumber;
    entity.Title = request.Title;
    entity.Organization = request.Organization;
    entity.UpdatedAt = DateTime.UtcNow; // Ensure timestamp is updated

    // 4. Map and Process Pipeline Fields (NEW LOGIC)
    entity.Stage = request.Stage;
    entity.ConnectionStatus = request.ConnectionStatus;
    entity.Source = request.Source;

    if (request.IncrementFollowUpCount)
    {
      // Diara's "1st, 2nd, 3rd follow ups" tracking
      entity.FollowUpCount++;
      entity.LastContactedAt = DateTime.UtcNow;
    }

    // Handle Lead/Client Transition based on Stage (High-Value Logic)
    if (request.Stage == LeadStage.Won)
    {
      entity.IsLead = false; // Convert from Lead back to Client
    }
    else if (request.Stage != LeadStage.Won && entity.Stage == LeadStage.Won)
    {
      // If they were 'Won' but are being moved back (e.g., to Negotiating), they are treated as a Lead again.
      entity.IsLead = true;
    }

    // 5. Save the changes
    await _context.SaveChangesAsync(cancellationToken);

    return Unit.Value;
  }
}

// =======================================================
// FILE: src/Application/Contacts/Commands/CreateContactCommandHandler.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Application.Features.Contacts.Commands;
using CRM_Vivid.Core.Entities;
using MediatR;


namespace CRM_Vivid.Application.Contacts.Commands;

public class CreateContactCommandHandler : IRequestHandler<CreateContactCommand, Guid>
{
  private readonly IApplicationDbContext _context;
  private readonly ICurrentUserService _currentUserService;

  public CreateContactCommandHandler(IApplicationDbContext context, ICurrentUserService currentUserService)
  {
    _context = context;
    _currentUserService = currentUserService;
  }

  public async Task<Guid> Handle(CreateContactCommand request, CancellationToken cancellationToken)
  {
    var entity = new Contact
    {
      FirstName = request.FirstName,
      LastName = request.LastName,
      Email = request.Email,
      PhoneNumber = request.PhoneNumber,
      Organization = request.Organization,
      Title = request.Title,

      // --- NEW: Map Pipeline Fields ---
      Stage = request.Stage,
      ConnectionStatus = request.ConnectionStatus,
      Source = request.Source,

      // --- PHASE 37: ASSIGN OWNER ---
      CreatedByUserId = _currentUserService.CurrentUserId,

      // Set initial tracking
      IsLead = request.Stage != Core.Enum.LeadStage.Won,
      FollowUpCount = 0,
      CreatedAt = DateTime.UtcNow,
      UpdatedAt = DateTime.UtcNow
    };

    _context.Contacts.Add(entity);
    await _context.SaveChangesAsync(cancellationToken);

    return entity.Id;
  }
}

// =======================================================
// FILE: src/Application/Contacts/Commands/SubmitLeadCommand.cs
// =======================================================
// FILE: src/Application/Contacts/Commands/SubmitLeadCommand.cs (MODIFIED)

using CRM_Vivid.Core.Entities;
using CRM_Vivid.Core.Enum;
using MediatR;
using FluentValidation;
using CRM_Vivid.Application.Common.Interfaces; // ADDED

namespace CRM_Vivid.Application.Contacts.Commands;

// Command for public form submission
public record SubmitLeadCommand : IRequest<Guid>
{
  // Minimal required info from the external form
  public string FirstName { get; init; } = string.Empty;
  public string? LastName { get; init; }
  public string Email { get; init; } = string.Empty;
  public string? PhoneNumber { get; init; }
  public string? Organization { get; init; }
  public string? Source { get; init; } // e.g., "Website Form"
}

public class SubmitLeadCommandValidator : AbstractValidator<SubmitLeadCommand>
{
  public SubmitLeadCommandValidator()
  {
    RuleFor(v => v.FirstName).NotEmpty().MaximumLength(100);
    RuleFor(v => v.Email).NotEmpty().EmailAddress().MaximumLength(200);
  }
}

public class SubmitLeadCommandHandler : IRequestHandler<SubmitLeadCommand, Guid>
{
  private readonly IApplicationDbContext _context;
  private readonly ICurrentUserService _currentUserService; // ADDED

  public SubmitLeadCommandHandler(IApplicationDbContext context, ICurrentUserService currentUserService) // MODIFIED
  {
    _context = context;
    _currentUserService = currentUserService; // ADDED
  }

  public async Task<Guid> Handle(SubmitLeadCommand request, CancellationToken cancellationToken)
  {
    var entity = new Contact
    {
      FirstName = request.FirstName,
      LastName = request.LastName,
      Email = request.Email,
      PhoneNumber = request.PhoneNumber,
      Organization = request.Organization,
      Source = request.Source,

      // --- Pipeline Defaults (Crucial) ---
      IsLead = true,
      Stage = LeadStage.NewLead,
      ConnectionStatus = ConnectionStatus.NeedToMeet, // New leads need introduction

      // --- PHASE 41 FIX: ASSIGN OWNER ID ---
      CreatedByUserId = _currentUserService.CurrentUserId,
      // ------------------------------------

      CreatedAt = DateTime.UtcNow,
      UpdatedAt = DateTime.UtcNow
    };

    _context.Contacts.Add(entity);
    await _context.SaveChangesAsync(cancellationToken);

    return entity.Id;
  }
}

// =======================================================
// FILE: src/Application/Contacts/Commands/DeleteContactCommand.cs
// =======================================================
using MediatR;

namespace CRM_Vivid.Application.Contacts.Commands;

// This record just needs to hold the ID of the contact to delete.
// It also returns 'Unit' (nothing) on success.
public record DeleteContactCommand(Guid Id) : IRequest<Unit>;

// =======================================================
// FILE: src/Application/Exceptions/NotFoundException.cs
// =======================================================
namespace CRM_Vivid.Application.Exceptions
{
  public class NotFoundException : Exception
  {
    public NotFoundException()
        : base()
    {
    }

    public NotFoundException(string message)
        : base(message)
    {
    }

    public NotFoundException(string message, Exception innerException)
        : base(message, innerException)
    {
    }

    public NotFoundException(string name, object key)
        : base($"Entity \"{name}\" ({key}) was not found.")
    {
    }
  }
}

// =======================================================
// FILE: src/Application/DependencyInjection.cs
// =======================================================
using System.Reflection;
using CRM_Vivid.Application.Common.Behaviours; // Add this
using FluentValidation;
using MediatR;
using Microsoft.Extensions.DependencyInjection;

namespace CRM_Vivid.Application;

public static class DependencyInjection
{
  public static IServiceCollection AddApplicationServices(this IServiceCollection services)
  {
    services.AddAutoMapper(Assembly.GetExecutingAssembly());
    services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());
    services.AddMediatR(cfg =>
    {
      cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());

      // Add the Validation Behaviour
      cfg.AddBehavior(typeof(IPipelineBehavior<,>), typeof(ValidationBehaviour<,>));
    });

    return services;
  }
}

// =======================================================
// FILE: src/Application/Dashboard/Queries/GetDashboardStatsQueryHandler.cs
// =======================================================
using AutoMapper;
using AutoMapper.QueryableExtensions;
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Application.Common.Models;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Dashboard.Queries;

public class GetDashboardStatsQueryHandler : IRequestHandler<GetDashboardStatsQuery, DashboardStatsDto>
{
  private readonly IApplicationDbContext _context;
  private readonly IMapper _mapper;

  public GetDashboardStatsQueryHandler(IApplicationDbContext context, IMapper mapper)
  {
    _context = context;
    _mapper = mapper;
  }

  public async Task<DashboardStatsDto> Handle(GetDashboardStatsQuery request, CancellationToken cancellationToken)
  {
    var now = DateTime.UtcNow;

    // 1. Total Contacts
    var totalContacts = await _context.Contacts.CountAsync(cancellationToken);

    // 2. Active Events (Future dates based on StartDateTime)
    var activeEvents = await _context.Events
        .Where(e => e.StartDateTime >= now)
        .CountAsync(cancellationToken);

    // 3. Pending Tasks (Not Completed)
    var pendingTasks = await _context.Tasks
        .Where(t => t.Status != CRM_Vivid.Core.Enum.TaskStatus.Completed)
        .CountAsync(cancellationToken);

    // 4. Recent Emails (Last 24 Hours)
    var recentEmails = await _context.EmailLogs
        .Where(e => e.SentAt >= now.AddHours(-24))
        .CountAsync(cancellationToken);

    // 5. Upcoming Events List (Next 5)
    var upcomingEvents = await _context.Events
        .Where(e => e.StartDateTime >= now)
        .OrderBy(e => e.StartDateTime)
        .Take(5)
        .ProjectTo<EventDto>(_mapper.ConfigurationProvider)
        .ToListAsync(cancellationToken);

    return new DashboardStatsDto
    {
      TotalContacts = totalContacts,
      ActiveEvents = activeEvents,
      PendingTasks = pendingTasks,
      RecentEmails = recentEmails,
      UpcomingEvents = upcomingEvents
    };
  }
}

// =======================================================
// FILE: src/Application/Dashboard/Queries/GetDashboardStatsQuery.cs
// =======================================================
using CRM_Vivid.Application.Common.Models;
using MediatR;

namespace CRM_Vivid.Application.Dashboard.Queries;

public record GetDashboardStatsQuery : IRequest<DashboardStatsDto>;

// =======================================================
// FILE: src/Application/Common/Models/ContactDto.cs
// =======================================================
// FILE: src/Application/Common/Models/ContactDto.cs (MODIFIED)
using CRM_Vivid.Core.Enum; // Required for LeadStage and ConnectionStatus

namespace CRM_Vivid.Application.Common.Models
{
  public class ContactDto
  {
    public Guid Id { get; set; }
    public string FirstName { get; set; } = string.Empty;
    public string? LastName { get; set; }
    public string Email { get; set; } = string.Empty;
    public string? PhoneNumber { get; set; }

    public string? Title { get; set; }
    public string? Organization { get; set; }

    // --- PHASE 25: LEAD MANAGEMENT FIELDS (Missing and causing CS0117) ---
    public LeadStage Stage { get; set; }
    public ConnectionStatus ConnectionStatus { get; set; }
    public bool IsLead { get; set; }
    public int FollowUpCount { get; set; }
    public DateTime? LastContactedAt { get; set; }
    public string? Source { get; set; }
    // ----------------------------------------------------------------------

    // --- PHASE 34: EVENT GRANULARITY ROLE ---
    public string? Role { get; set; } // Used when listing participants for an Event
  }
}

// =======================================================
// FILE: src/Application/Common/Models/EmailLogDto.cs
// =======================================================
namespace CRM_Vivid.Application.Common.Models
{
  public class EmailLogDto
  {
    public Guid Id { get; set; }
    public string To { get; set; } = string.Empty;
    public string Subject { get; set; } = string.Empty;
    public DateTime SentAt { get; set; }
    public bool IsSuccess { get; set; }
    public string? ErrorMessage { get; set; }
  }
}

// =======================================================
// FILE: src/Application/Common/Models/ExpenseDto.cs
// =======================================================
namespace CRM_Vivid.Application.Common.Models
{
  public class ExpenseDto
  {
    public Guid Id { get; set; }
    public Guid BudgetId { get; set; }

    public string Description { get; set; } = string.Empty;
    public decimal Amount { get; set; }
    public DateTime DateIncurred { get; set; }
    public string Category { get; set; } = string.Empty; // Mapped from Enum

    // Vendor Info (if linked)
    public Guid? VendorId { get; set; }
    public string? VendorName { get; set; }

    // Invoice Info (if linked)
    public int? LinkedDocumentId { get; set; }
    public string? LinkedDocumentName { get; set; }
  }
}

// =======================================================
// FILE: src/Application/Common/Models/TaskDto.cs
// =======================================================
namespace CRM_Vivid.Application.Common.Models
{
  public class TaskDto
  {
    public Guid Id { get; set; }
    public string Title { get; set; } = string.Empty;
    public string? Description { get; set; }
    public string Status { get; set; } = string.Empty; // Enums will be mapped to strings
    public string Priority { get; set; } = string.Empty;
    public DateTime? DueDate { get; set; }
    public DateTime CreatedAt { get; set; }
    public Guid? ContactId { get; set; }
    public Guid? EventId { get; set; }
    public Guid? VendorId { get; set; }
    public string? VendorName { get; set; }

  }
}

// =======================================================
// FILE: src/Application/Common/Models/ActivityDto.cs
// =======================================================
// FILE: src/Application/Common/Models/ActivityDto.cs (NEW FILE)
namespace CRM_Vivid.Application.Common.Models;

/// <summary>
/// A unified DTO for displaying tasks, notes, and email logs in a single timeline.
/// </summary>
public class ActivityDto
{
  public Guid Id { get; set; }

  // The timestamp used for chronological ordering
  public DateTime Timestamp { get; set; }

  // The type of activity (e.g., "TASK", "NOTE", "EMAIL")
  public string ActivityType { get; set; } = string.Empty;

  // A short summary or title
  public string Title { get; set; } = string.Empty;

  // The main content/description (optional)
  public string? Content { get; set; }

  // Status/Metadata specific to the type (e.g., "Completed", "Sent", "Vendor Inquiry")
  public string? Status { get; set; }

  // Optional foreign key to a related entity, if applicable
  public Guid? RelatedEntityId { get; set; }
}

// =======================================================
// FILE: src/Application/Common/Models/VendorSummaryDto.cs
// =======================================================
// FILE: src/Application/Common/Models/VendorSummaryDto.cs (NEW FILE)
namespace CRM_Vivid.Application.Common.Models;

public class VendorSummaryDto
{
  public Guid VendorId { get; set; }
  public string VendorName { get; set; } = string.Empty;

  // Phase 35 Reporting Metrics
  public int TotalEventsHiredFor { get; set; }
  public decimal TotalExpensesPaid { get; set; } // Sum of all expenses linked to this vendor
}

// =======================================================
// FILE: src/Application/Common/Models/DocumentDto.cs
// =======================================================
namespace CRM_Vivid.Application.Common.Models;

public class DocumentDto
{
  public int Id { get; set; }
  public required string FileName { get; set; }
  public required string ContentType { get; set; }
  public long Size { get; set; }
  public DateTime UploadedAt { get; set; }
  public required string Url { get; set; }
  public Guid RelatedEntityId { get; set; }
  public required string RelatedEntityType { get; set; }

  // --- NEW ---
  public required string Category { get; set; }
}

// =======================================================
// FILE: src/Application/Common/Models/NoteDto.cs
// =======================================================
namespace CRM_Vivid.Application.Common.Models;

public class NoteDto
{
  public Guid Id { get; set; }
  public string Content { get; set; } = string.Empty;
  public DateTime CreatedAt { get; set; }
  public DateTime? UpdatedAt { get; set; }
  // Simple FKs for the DTO
  public Guid? ContactId { get; set; }
  public Guid? EventId { get; set; }
  public Guid? TaskId { get; set; }
  public Guid? VendorId { get; set; }
  public string? VendorName { get; set; }
}

// =======================================================
// FILE: src/Application/Common/Models/EventFinancialDto.cs
// =======================================================
namespace CRM_Vivid.Application.Common.Models
{
  public class EventFinancialsDto
  {
    public Guid EventId { get; set; }
    public string EventName { get; set; } = string.Empty;

    // Budget Settings
    public decimal BudgetTotal { get; set; }
    public string Currency { get; set; } = "USD";
    public string? Notes { get; set; }

    // --- PHASE 26 ADDITION: Budget Lock Status ---
    public bool IsLocked { get; set; } = false; // NEW

    // The Ledger
    public List<ExpenseDto> Expenses { get; set; } = new List<ExpenseDto>();

    // The Calculator (Computed Properties)
    public decimal TotalSpent { get; set; }
    public decimal RemainingBudget => BudgetTotal - TotalSpent;

    // Progress (0.0 to 1.0) for UI Bars
    public double BurnRate => BudgetTotal == 0 ? 0 : (double)(TotalSpent / BudgetTotal);
  }
}

// =======================================================
// FILE: src/Application/Common/Models/ContactTaskSummaryDto.cs
// =======================================================
// FILE: src/Application/Common/Models/ContactTaskSummaryDto.cs (NEW FILE)
namespace CRM_Vivid.Application.Common.Models;

public class ContactTaskSummaryDto
{
  public Guid ContactId { get; set; }
  public string ContactName { get; set; } = string.Empty;

  // Phase 35 Reporting Metrics
  public int TotalTasksAssigned { get; set; }
  public int TotalTasksCompleted { get; set; }
  public int TotalTasksOverdue { get; set; }
}

// =======================================================
// FILE: src/Application/Common/Models/TemplateDto.cs
// =======================================================
namespace CRM_Vivid.Application.Common.Models;

public class TemplateDto
{
  public Guid Id { get; set; }
  public string Name { get; set; } = string.Empty;
  public string? Subject { get; set; }
  public string Content { get; set; } = string.Empty;
  public string Type { get; set; } = string.Empty;
}

// =======================================================
// FILE: src/Application/Common/Models/DashboardDto.cs
// =======================================================
namespace CRM_Vivid.Application.Common.Models;

public class DashboardStatsDto
{
  public int TotalContacts { get; set; }
  public int ActiveEvents { get; set; }
  public int PendingTasks { get; set; }
  public int RecentEmails { get; set; }
  public List<EventDto> UpcomingEvents { get; set; } = new();
}

// =======================================================
// FILE: src/Application/Common/Models/EventDto.cs
// =======================================================
namespace CRM_Vivid.Application.Common.Models
{
  public class EventDto
  {
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    public DateTime StartDateTime { get; set; }
    public DateTime EndDateTime { get; set; }
    public string? Location { get; set; }
    public bool IsPublic { get; set; }
    public string Status { get; set; } = string.Empty; // AutoMapper will map the Enum to a string
  }
}

// =======================================================
// FILE: src/Application/Common/Models/VendorDto.cs
// =======================================================
// FILE: src/Application/Common/Models/VendorDto.cs
namespace CRM_Vivid.Application.Common.Models;

public class VendorDto
{
  public Guid Id { get; set; }
  public string Name
  {
    get; set;
  } = string.Empty;
  public string? PhoneNumber { get; set; }
  public string? Email
  {
    get; set;
  }
  public string ServiceType { get; set; } = string.Empty;
  public string? Attributes { get; set; }
  public string? Role { get; set; }
}

// =======================================================
// FILE: src/Application/Common/Behaviors/ValidationBehavior.cs
// =======================================================
using FluentValidation;
using MediatR;

namespace CRM_Vivid.Application.Common.Behaviours;

public class ValidationBehaviour<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
     where TRequest : notnull
{
  private readonly IEnumerable<IValidator<TRequest>> _validators;

  public ValidationBehaviour(IEnumerable<IValidator<TRequest>> validators)
  {
    _validators = validators;
  }

  public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
  {
    if (_validators.Any())
    {
      var context = new ValidationContext<TRequest>(request);

      var validationResults = await Task.WhenAll(
          _validators.Select(v => v.ValidateAsync(context, cancellationToken)));

      var failures = validationResults
          .SelectMany(r => r.Errors)
          .Where(f => f != null)
          .ToList();

      if (failures.Count != 0)
      {
        throw new ValidationException(failures);
      }
    }
    return await next();
  }
}

// =======================================================
// FILE: src/Application/Common/Mappings/MappingProfile.cs
// =======================================================
// FILE: src/Application/Common/Mappings/MappingProfile.cs (COMPLETE FILE)
using AutoMapper;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Core.Entities;
using CRM_Vivid.Application.Tasks.Commands;
using CRM_Vivid.Application.Vendors.Commands;
using CRM_Vivid.Core.Enum;
using CRM_Vivid.Application.Notes.Commands;

namespace CRM_Vivid.Application.Common.Mappings
{
    public class MappingProfile : Profile
    {
        public MappingProfile()
        {
            CreateMap<Contact, ContactDto>();
            CreateMap<Event, EventDto>();
            CreateMap<TaskDto, Core.Entities.Task>();

            CreateMap<Core.Entities.Task, TaskDto>()
                      .ForMember(d => d.Status, opt => opt.MapFrom(s => s.Status.ToString()))
                      .ForMember(d => d.Priority, opt => opt.MapFrom(s => s.Priority.ToString()))
                      .ForMember(d => d.VendorName, opt => opt.MapFrom(s => s.Vendor != null ? s.Vendor.Name : null));

            CreateMap<CreateTaskCommand, Core.Entities.Task>();

            // --- NEW: PHASE 30 UPDATE TASK MAPPING FIX (Replaces manual GUID assignment in handler) ---
            CreateMap<UpdateTaskCommand, Core.Entities.Task>()
                // If the string field is used (ContactEmail), map the GUID field to null.
                // The handler logic will later resolve the correct GUID into the request.
                .ForMember(d => d.ContactId, opt => opt.MapFrom(s => s.ContactEmail != null ? (Guid?)null : s.ContactId))
                .ForMember(d => d.EventId, opt => opt.MapFrom(s => s.EventName != null ? (Guid?)null : s.EventId))
                .ForMember(d => d.VendorId, opt => opt.MapFrom(s => s.VendorName != null ? (Guid?)null : s.VendorId));

            // End UpdateTaskCommand Mapping Fix ---

            CreateMap<Vendor, VendorDto>()
                .ForMember(d => d.ServiceType, opt => opt.MapFrom(s => s.ServiceType.ToString()));
            CreateMap<CreateVendorCommand, Vendor>()
                .ForMember(d => d.ServiceType, opt => opt.MapFrom(s => Enum.Parse<VendorType>(s.ServiceType, true)));
            CreateMap<UpdateVendorCommand, Vendor>()
                .ForMember(d => d.ServiceType, opt => opt.MapFrom(s => Enum.Parse<VendorType>(s.ServiceType, true)));

            CreateMap<Note, NoteDto>()
                .ForMember(d => d.VendorName, opt => opt.MapFrom(s => s.Vendor != null ? s.Vendor.Name : null));

            CreateMap<CreateNoteCommand, Note>();
            CreateMap<UpdateNoteCommand, Note>()
                .ForMember(d => d.Content, opt => opt.MapFrom(s => s.Content));

            CreateMap<Template, TemplateDto>()
                .ForMember(d => d.Type, opt => opt.MapFrom(s => s.Type.ToString()));

            // --- Financial Mappings ---
            CreateMap<Expense, ExpenseDto>()
                .ForMember(d => d.Category, opt => opt.MapFrom(s => s.Category.ToString()))
                .ForMember(d => d.VendorName, opt => opt.MapFrom(s => s.Vendor != null ? s.Vendor.Name : null))
                .ForMember(d => d.LinkedDocumentName, opt => opt.MapFrom(s => s.LinkedDocument != null ? s.LinkedDocument.FileName : null));
        }
    }
}

// =======================================================
// FILE: src/Application/Common/Interfaces/IFileStorageService.cs
// =======================================================
namespace CRM_Vivid.Application.Common.Interfaces
{
  public interface IFileStorageService
  {
    Task<string> UploadAsync(Stream fileStream, string fileName);
    Task DeleteAsync(string storedFileName);
    string GetFileUrl(string storedFileName);
  }
}

// =======================================================
// FILE: src/Application/Common/Interfaces/ITelephonyService.cs
// =======================================================
namespace CRM_Vivid.Application.Common.Interfaces;

public interface ITelephonyService
{
  /// <summary>
  /// Sends an SMS message to a single recipient.
  /// </summary>
  /// <param name="toPhoneNumber">The recipient's phone number in E.164 format (e.g., +15551234567).</param>
  /// <param name="body">The message content.</param>
  /// <returns>True if the message was successfully queued for sending.</returns>
  Task<bool> SendSmsAsync(string toPhoneNumber, string body);

  /// <summary>
  /// Sends a standardized alert notification (for critical events like contract changes).
  /// </summary>
  /// <param name="toPhoneNumber">The recipient's phone number.</param>
  /// <param name="alertMessage">The content of the critical alert.</param>
  /// <returns>True if the alert was successfully queued.</returns>
  Task<bool> SendCriticalAlertAsync(string toPhoneNumber, string alertMessage);
}

// =======================================================
// FILE: src/Application/Common/Interfaces/IEmailSender.cs
// =======================================================
namespace CRM_Vivid.Application.Common.Interfaces;

public interface IEmailSender
{
  Task SendEmailAsync(
      string to,
      string subject,
      string body,
      Guid? templateId = null, // NEW
      Guid? eventId = null);   // NEW
}


// =======================================================
// FILE: src/Application/Common/Interfaces/IBackgroundJobService.cs
// =======================================================
using System.Linq.Expressions;

namespace CRM_Vivid.Application.Common.Interfaces;

public interface IBackgroundJobService
{
  /// <summary>
  /// Enqueues a job to execute once at a specified future time.
  /// </summary>
  /// <param name="methodCall">The method to call (e.g., () => IEmailSender.SendEmailAsync(...))</param>
  /// <param name="enqueueAt">The date and time to execute the job.</param>
  /// <returns>The Hangfire Job ID.</returns>
  string Schedule(Expression<System.Action> methodCall, DateTimeOffset enqueueAt);

  /// <summary>
  /// Enqueues a job for immediate, reliable execution.
  /// </summary>
  /// <param name="methodCall">The method to call.</param>
  /// <returns>The Hangfire Job ID.</returns>
  string Enqueue(Expression<System.Action> methodCall);
}

// =======================================================
// FILE: src/Application/Common/Interfaces/ITemplateMerger.cs
// =======================================================
namespace CRM_Vivid.Application.Common.Interfaces;

public interface ITemplateMerger
{
  /// <summary>
  /// Merges a template string with a dictionary of placeholders.
  /// Supports both {Key} and {{Key}} formats.
  /// </summary>
  /// <param name="templateContent">The raw HTML/Text template.</param>
  /// <param name="placeholders">Dictionary where Key is the placeholder name (e.g. "EventName") and Value is the replacement text.</param>
  /// <returns>The merged string.</returns>
  string Merge(string templateContent, Dictionary<string, string> placeholders);
}

// =======================================================
// FILE: src/Application/Common/Interfaces/IApplicationDbContext.cs
// =======================================================
using CRM_Vivid.Core.Entities;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Common.Interfaces;

public interface IApplicationDbContext
{
  DbSet<Contact> Contacts { get; }
  DbSet<Event> Events { get; }
  DbSet<EventContact> EventContacts { get; }
  DbSet<Core.Entities.Task> Tasks { get; }
  DbSet<Vendor> Vendors { get; }
  DbSet<Note> Notes { get; }
  DbSet<EventVendor> EventVendors { get; }
  DbSet<Template> Templates { get; }
  DbSet<EmailLog> EmailLogs { get; }
  DbSet<Document> Documents { get; }

  DbSet<Budget> Budgets { get; }
  DbSet<Expense> Expenses { get; }

  Task<int> SaveChangesAsync(CancellationToken cancellationToken);
}

// =======================================================
// FILE: src/Application/Common/Interfaces/IContractGenerator.cs
// =======================================================
namespace CRM_Vivid.Application.Common.Interfaces;

public interface IContractGenerator
{
  /// <summary>
  /// Generates a structured multi-page contract for a specific event.
  /// </summary>
  /// <param name="eventId">The ID of the event containing necessary data (timeline, contacts, financials).</param>
  /// <returns>The PDF document as a byte array.</returns>
  Task<byte[]> GenerateContractAsync(Guid eventId);
}

// =======================================================
// FILE: src/Application/Common/Interfaces/ICurrentUserService.cs
// =======================================================
// FILE: src/Application/Common/Interfaces/ICurrentUserService.cs (NEW FILE)
namespace CRM_Vivid.Application.Common.Interfaces;

/// <summary>
/// Provides access to the current authenticated user's ID.
/// </summary>
public interface ICurrentUserService
{
  Guid CurrentUserId { get; }
  bool IsAuthenticated { get; }
}

// =======================================================
// FILE: src/Application/Notes/Queries/GetNoteByIdQuery.cs
// =======================================================
using CRM_Vivid.Application.Common.Models;
using MediatR;

namespace CRM_Vivid.Application.Notes.Queries;

public class GetNoteByIdQuery : IRequest<NoteDto>
{
  public Guid Id { get; set; }
}

// =======================================================
// FILE: src/Application/Notes/Queries/GetNotesQueryHandler.cs
// =======================================================
// FILE: src/Application/Notes/Queries/GetNotesQueryHandler.cs (MODIFIED)
using AutoMapper;
using AutoMapper.QueryableExtensions;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Common.Interfaces;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Notes.Queries;

public class GetNotesQueryHandler : IRequestHandler<GetNotesQuery, IEnumerable<NoteDto>>
{
  private readonly IApplicationDbContext _context;
  private readonly IMapper _mapper;

  public GetNotesQueryHandler(IApplicationDbContext context, IMapper mapper)
  {
    _context = context;
    _mapper = mapper;
  }

  public async Task<IEnumerable<NoteDto>> Handle(GetNotesQuery request, CancellationToken cancellationToken)
  {
    var query = _context.Notes.AsNoTracking();

    // --- PHASE 32 FIX: EAGER LOAD VENDOR FOR DTO MAPPING ---
    query = query.Include(n => n.Vendor);
    // -----------------------------------------------------

    if (request.ContactId.HasValue)
    {
      query = query.Where(n => n.ContactId == request.ContactId);
    }
    else if (request.EventId.HasValue)
    {
      query = query.Where(n => n.EventId == request.EventId);
    }
    else if (request.TaskId.HasValue)
    {
      query = query.Where(n => n.TaskId == request.TaskId);
    }
    else if (request.VendorId.HasValue)
    {
      query = query.Where(n => n.VendorId == request.VendorId);
    }

    // If no filter is provided, it returns all notes

    return await query
        .OrderByDescending(n => n.CreatedAt)
        .ProjectTo<NoteDto>(_mapper.ConfigurationProvider)
        .ToListAsync(cancellationToken);
  }
}

// =======================================================
// FILE: src/Application/Notes/Queries/GetNoteByIdQueryHandler.cs
// =======================================================
using AutoMapper;
using AutoMapper.QueryableExtensions;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Exceptions;
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Entities;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Notes.Queries;

public class GetNoteByIdQueryHandler : IRequestHandler<GetNoteByIdQuery, NoteDto>
{
  private readonly IApplicationDbContext _context;
  private readonly IMapper _mapper;

  public GetNoteByIdQueryHandler(IApplicationDbContext context, IMapper mapper)
  {
    _context = context;
    _mapper = mapper;
  }

  public async Task<NoteDto> Handle(GetNoteByIdQuery request, CancellationToken cancellationToken)
  {
    var note = await _context.Notes
        .AsNoTracking()
        .Where(n => n.Id == request.Id)
        .ProjectTo<NoteDto>(_mapper.ConfigurationProvider)
        .SingleOrDefaultAsync(cancellationToken);

    if (note == null)
    {
      throw new NotFoundException(nameof(Note), request.Id);
    }

    return note;
  }
}

// =======================================================
// FILE: src/Application/Notes/Queries/GetNotesQuery.cs
// =======================================================
using CRM_Vivid.Application.Common.Models;
using MediatR;

namespace CRM_Vivid.Application.Notes.Queries;

// This query allows fetching all notes, or filtering by a specific parent entity
public class GetNotesQuery : IRequest<IEnumerable<NoteDto>>
{
  public Guid? ContactId { get; set; }
  public Guid? EventId { get; set; }
  public Guid? TaskId { get; set; }
  public Guid? VendorId { get; set; }
}

// =======================================================
// FILE: src/Application/Notes/Commands/UpdateNoteCommand.cs
// =======================================================
using MediatR;

namespace CRM_Vivid.Application.Notes.Commands;

public class UpdateNoteCommand : IRequest
{
  public Guid Id { get; set; }
  public string Content { get; set; } = string.Empty;

  // Note: We are only allowing Content to be updated.
  // Re-associating a note is a complex business rule
  // (e.g., delete and recreate).
}

// =======================================================
// FILE: src/Application/Notes/Commands/CreateNoteCommand.cs
// =======================================================
// FILE: src/Application/Notes/Commands/CreateNoteCommand.cs
using CRM_Vivid.Application.Common.Models;
using MediatR;

namespace CRM_Vivid.Application.Notes.Commands;

public class CreateNoteCommand : IRequest<NoteDto>
{
  public string Content { get; set; } = string.Empty;

  // --- Original GUID Foreign Keys ---
  public Guid? ContactId
  {
    get;
    set;
  }
  public Guid? EventId { get; set; }
  public Guid? TaskId
  {
    get; set;
  }
  public Guid? VendorId { get; set; }

  // --- NEW: PHASE 29 STRING-BASED RESOLUTION FIELDS ---
  public string? ContactEmail { get; set; }
  public string? VendorName { get; set; }
  public string? EventName { get; set; }
  public string? TaskTitle { get; set; } // Notes can attach to tasks, so we need task resolution
}

// =======================================================
// FILE: src/Application/Notes/Commands/DeleteNoteCommandHandler.cs
// =======================================================
using CRM_Vivid.Application.Exceptions;
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Entities;
using MediatR;

namespace CRM_Vivid.Application.Notes.Commands;

public class DeleteNoteCommandHandler : IRequestHandler<DeleteNoteCommand>
{
  private readonly IApplicationDbContext _context;

  public DeleteNoteCommandHandler(IApplicationDbContext context)
  {
    _context = context;
  }

  // --- FIX IS HERE ---
  // Fully qualify the 'Task' return type to avoid ambiguity
  public async System.Threading.Tasks.Task Handle(DeleteNoteCommand request, CancellationToken cancellationToken)
  {
    var note = await _context.Notes.FindAsync(new object[] { request.Id }, cancellationToken);

    if (note == null)
    {
      throw new NotFoundException(nameof(Note), request.Id);
    }

    _context.Notes.Remove(note);
    await _context.SaveChangesAsync(cancellationToken);
  }
}

// =======================================================
// FILE: src/Application/Notes/Commands/CreateNoteCommandHandler.cs
// =======================================================
// FILE: src/Application/Notes/Commands/CreateNoteCommandHandler.cs (MODIFIED)
using AutoMapper;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Entities;
using MediatR;
using Microsoft.EntityFrameworkCore;
using CRM_Vivid.Application.Exceptions; // NEW: Ensure this is used

namespace CRM_Vivid.Application.Notes.Commands;

public class CreateNoteCommandHandler : IRequestHandler<CreateNoteCommand, NoteDto>
{
  private readonly IApplicationDbContext _context;
  private readonly IMapper _mapper;

  private readonly ICurrentUserService _currentUserService;

  public CreateNoteCommandHandler(IApplicationDbContext context, IMapper mapper, ICurrentUserService currentUserService)
  {
    _context = context;
    _mapper = mapper;
    _currentUserService = currentUserService;
  }

  public async Task<NoteDto> Handle(CreateNoteCommand request, CancellationToken cancellationToken)
  {
    // --- PHASE 30: HARDENED RESOLUTION LOGIC ---

    // 1. Resolve ContactId via Email
    if (request.ContactId == null && !string.IsNullOrWhiteSpace(request.ContactEmail))
    {
      var contact = await _context.Contacts.AsNoTracking().FirstOrDefaultAsync(c => c.Email == request.ContactEmail, cancellationToken);
      if (contact == null) throw new NotFoundException(nameof(Contact), request.ContactEmail);
      request.ContactId = contact.Id;
    }

    // 2. Resolve VendorId via Name
    if (request.VendorId == null && !string.IsNullOrWhiteSpace(request.VendorName))
    {
      var vendor = await _context.Vendors.AsNoTracking().FirstOrDefaultAsync(v => v.Name == request.VendorName, cancellationToken);
      if (vendor == null) throw new NotFoundException(nameof(Vendor), request.VendorName);
      request.VendorId = vendor.Id;
    }

    // 3. Resolve EventId via Name
    if (request.EventId == null && !string.IsNullOrWhiteSpace(request.EventName))
    {
      var eventEntity = await _context.Events.AsNoTracking().FirstOrDefaultAsync(e => e.Name == request.EventName, cancellationToken);
      if (eventEntity == null) throw new NotFoundException(nameof(Event), request.EventName);
      request.EventId = eventEntity.Id;
    }

    // 4. Resolve TaskId via Title
    if (request.TaskId == null && !string.IsNullOrWhiteSpace(request.TaskTitle))
    {
      var task = await _context.Tasks.AsNoTracking().FirstOrDefaultAsync(t => t.Title == request.TaskTitle, cancellationToken);
      // NOTE: We allow non-unique titles, but fail if *nothing* is found.
      if (task == null) throw new NotFoundException(nameof(Core.Entities.Task), request.TaskTitle);
      request.TaskId = task.Id;
    }

    // --- End Hardening ---

    var note = _mapper.Map<Note>(request);

    // --- PHASE 37: ASSIGN OWNER ---
    note.CreatedByUserId = _currentUserService.CurrentUserId;

    note.CreatedAt = DateTime.UtcNow;

    _context.Notes.Add(note);
    await _context.SaveChangesAsync(cancellationToken);

    var createdNote = await _context.Notes
        .Include(n => n.Vendor)
        .FirstOrDefaultAsync(n => n.Id == note.Id, cancellationToken);

    return _mapper.Map<NoteDto>(createdNote);
  }
}

// =======================================================
// FILE: src/Application/Notes/Commands/UpdateNoteCommandHandler.cs
// =======================================================
using CRM_Vivid.Application.Exceptions;
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Entities;
using MediatR;

namespace CRM_Vivid.Application.Notes.Commands;

public class UpdateNoteCommandHandler : IRequestHandler<UpdateNoteCommand>
{
  private readonly IApplicationDbContext _context;

  public UpdateNoteCommandHandler(IApplicationDbContext context)
  {
    _context = context;
  }

  // --- FIX IS HERE ---
  // Fully qualify the 'Task' return type to avoid ambiguity
  public async System.Threading.Tasks.Task Handle(UpdateNoteCommand request, CancellationToken cancellationToken)
  {
    var note = await _context.Notes.FindAsync(new object[] { request.Id }, cancellationToken);

    if (note == null)
    {
      throw new NotFoundException(nameof(Note), request.Id);
    }

    note.Content = request.Content;
    note.UpdatedAt = DateTime.UtcNow;

    await _context.SaveChangesAsync(cancellationToken);
  }
}

// =======================================================
// FILE: src/Application/Notes/Commands/DeleteNoteCommand.cs
// =======================================================
using MediatR;

namespace CRM_Vivid.Application.Notes.Commands;

public class DeleteNoteCommand : IRequest
{
  public Guid Id { get; set; }
}

// =======================================================
// FILE: src/Application/Notes/Validators/UpdateNoteCommandValidator.cs
// =======================================================
using FluentValidation;

namespace CRM_Vivid.Application.Notes.Validators;

public class UpdateNoteCommandValidator : AbstractValidator<Commands.UpdateNoteCommand>
{
  public UpdateNoteCommandValidator()
  {
    RuleFor(v => v.Content)
        .NotEmpty().WithMessage("Content is required.")
        .MaximumLength(2000).WithMessage("Content must not exceed 2000 characters.");
  }
}

// =======================================================
// FILE: src/Application/Notes/Validators/CreateNoteCommandValidator.cs
// =======================================================
// FILE: src/Application/Notes/Validators/CreateNoteCommandValidator.cs
using FluentValidation;
using CRM_Vivid.Application.Notes.Commands; // Ensure correct namespace for command

namespace CRM_Vivid.Application.Notes.Validators;

public class CreateNoteCommandValidator : AbstractValidator<CreateNoteCommand>
{
  public CreateNoteCommandValidator()
  {
    RuleFor(v => v.Content)
        .NotEmpty().WithMessage("Content is required.")
        .MaximumLength(2000).WithMessage("Content must not exceed 2000 characters.");

    // --- PHASE 29: ENFORCE ID/NAME MUTUAL EXCLUSION & LINKAGE ---

    // Must not provide both ID and name/email/title for the same entity
    RuleFor(v => v.ContactId).Empty().When(v => !string.IsNullOrWhiteSpace(v.ContactEmail))
        .WithMessage("Cannot provide both ContactId and ContactEmail.");
    RuleFor(v => v.EventId).Empty().When(v => !string.IsNullOrWhiteSpace(v.EventName))
        .WithMessage("Cannot provide both EventId and EventName.");
    RuleFor(v => v.VendorId).Empty().When(v => !string.IsNullOrWhiteSpace(v.VendorName))
        .WithMessage("Cannot provide both VendorId and VendorName.");
    RuleFor(v => v.TaskId).Empty().When(v => !string.IsNullOrWhiteSpace(v.TaskTitle))
        .WithMessage("Cannot provide both TaskId and TaskTitle.");

    // Must link to at least one entity (GUID or resolved string)
    RuleFor(v => v)
        .Must(HaveAtLeastOneLink)
        .WithMessage("A note must be associated with at least one entity (Contact, Event, Task, or Vendor).");
  }

  private bool HaveAtLeastOneLink(CreateNoteCommand command)
  {
    return command.ContactId.HasValue || !string.IsNullOrWhiteSpace(command.ContactEmail) ||
           command.EventId.HasValue || !string.IsNullOrWhiteSpace(command.EventName) ||
           command.TaskId.HasValue || !string.IsNullOrWhiteSpace(command.TaskTitle) ||
           command.VendorId.HasValue || !string.IsNullOrWhiteSpace(command.VendorName);
  }
}

// =======================================================
// FILE: src/Application/Templates/Queries/GetTemplatesQuery.cs
// =======================================================
using AutoMapper;
using AutoMapper.QueryableExtensions;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Common.Interfaces;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Templates.Queries;

public record GetTemplatesQuery : IRequest<List<TemplateDto>>;

public class GetTemplatesQueryHandler : IRequestHandler<GetTemplatesQuery, List<TemplateDto>>
{
  private readonly IApplicationDbContext _context;
  private readonly IMapper _mapper;

  public GetTemplatesQueryHandler(IApplicationDbContext context, IMapper mapper)
  {
    _context = context;
    _mapper = mapper;
  }

  public async Task<List<TemplateDto>> Handle(GetTemplatesQuery request, CancellationToken cancellationToken)
  {
    return await _context.Templates
        .AsNoTracking()
        .ProjectTo<TemplateDto>(_mapper.ConfigurationProvider)
        .OrderBy(t => t.Name)
        .ToListAsync(cancellationToken);
  }
}

// =======================================================
// FILE: src/Application/Templates/Queries/GetTemplateByIdQuery.cs
// =======================================================
using AutoMapper;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Exceptions;
using CRM_Vivid.Application.Common.Interfaces;
using MediatR;

namespace CRM_Vivid.Application.Templates.Queries;

public record GetTemplateByIdQuery(Guid Id) : IRequest<TemplateDto>;

public class GetTemplateByIdQueryHandler : IRequestHandler<GetTemplateByIdQuery, TemplateDto>
{
  private readonly IApplicationDbContext _context;
  private readonly IMapper _mapper;

  public GetTemplateByIdQueryHandler(IApplicationDbContext context, IMapper mapper)
  {
    _context = context;
    _mapper = mapper;
  }

  public async Task<TemplateDto> Handle(GetTemplateByIdQuery request, CancellationToken cancellationToken)
  {
    var entity = await _context.Templates
        .FindAsync(new object[] { request.Id }, cancellationToken);

    if (entity == null)
    {
      throw new NotFoundException(nameof(Core.Entities.Template), request.Id);
    }

    return _mapper.Map<TemplateDto>(entity);
  }
}

// =======================================================
// FILE: src/Application/Templates/Commands/SendEmailTemplateCommand.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Application.Exceptions; // Fixed Namespace
using MediatR;
using Microsoft.EntityFrameworkCore;
using FluentValidation;

namespace CRM_Vivid.Application.Templates.Commands;

public enum RecipientType
{
  Contact,
  Vendor
}

public record SendTemplateEmailCommand : IRequest<bool>
{
  public Guid EventId { get; init; }
  public Guid TemplateId { get; init; }
  public Guid TargetEntityId { get; init; }
  public RecipientType RecipientType { get; init; }
}

public class SendTemplateEmailCommandValidator : AbstractValidator<SendTemplateEmailCommand>
{
  public SendTemplateEmailCommandValidator()
  {
    RuleFor(v => v.EventId).NotEmpty();
    RuleFor(v => v.TemplateId).NotEmpty();
    RuleFor(v => v.TargetEntityId).NotEmpty();
  }
}

public class SendTemplateEmailCommandHandler : IRequestHandler<SendTemplateEmailCommand, bool>
{
  private readonly IApplicationDbContext _context;
  private readonly ITemplateMerger _merger;
  private readonly IEmailSender _emailSender;

  public SendTemplateEmailCommandHandler(
      IApplicationDbContext context,
      ITemplateMerger merger,
      IEmailSender emailSender)
  {
    _context = context;
    _merger = merger;
    _emailSender = emailSender;
  }

  public async Task<bool> Handle(SendTemplateEmailCommand request, CancellationToken cancellationToken)
  {
    // 1. Fetch Event
    var evt = await _context.Events
        .FirstOrDefaultAsync(e => e.Id == request.EventId, cancellationToken);

    if (evt == null) throw new NotFoundException("Event", request.EventId);

    // 2. Fetch Template
    var template = await _context.Templates
        .FindAsync(new object[] { request.TemplateId }, cancellationToken);

    if (template == null) throw new NotFoundException("Template", request.TemplateId);

    // 3. Resolve Recipient & Build Dictionary
    string targetEmail = string.Empty;
    string targetName = string.Empty;

    // Map Event Data
    var placeholders = new Dictionary<string, string>
        {
            { "EventName", evt.Name },
            { "EventDescription", evt.Description ?? "" },
            { "EventDate", evt.StartDateTime.ToShortDateString() }, // Fixed Property
            { "EventLocation", evt.Location ?? "" }
        };

    if (request.RecipientType == RecipientType.Vendor)
    {
      var vendor = await _context.Vendors.FindAsync(new object[] { request.TargetEntityId }, cancellationToken);
      if (vendor == null) throw new NotFoundException("Vendor", request.TargetEntityId);

      targetEmail = vendor.Email ?? string.Empty;
      targetName = vendor.Name;

      placeholders.Add("VendorName", vendor.Name);
      placeholders.Add("ContactName", vendor.Name);
      placeholders.Add("VendorType", vendor.ServiceType.ToString()); // Fixed Property
    }
    else if (request.RecipientType == RecipientType.Contact)
    {
      var contact = await _context.Contacts.FindAsync(new object[] { request.TargetEntityId }, cancellationToken);
      if (contact == null) throw new NotFoundException("Contact", request.TargetEntityId);

      targetEmail = contact.Email ?? string.Empty;
      targetName = $"{contact.FirstName} {contact.LastName}";

      placeholders.Add("ContactName", targetName);
      placeholders.Add("FirstName", contact.FirstName ?? "");
      placeholders.Add("LastName", contact.LastName ?? "");
      placeholders.Add("Organization", contact.Organization ?? "");
    }

    if (string.IsNullOrEmpty(targetEmail))
    {
      // Log or throw? For now, throw to alert the user.
      throw new Exception($"Recipient {targetName} has no email address.");
    }

    // 4. Merge Content
    // Fixed Property: template.Content instead of template.Body
    var mergedSubject = _merger.Merge(template.Subject ?? "No Subject", placeholders);
    var mergedBody = _merger.Merge(template.Content ?? "", placeholders);

    // 5. Send
    await _emailSender.SendEmailAsync(
      targetEmail,
      mergedSubject,
      mergedBody,
      templateId: request.TemplateId,
      eventId: request.EventId
      );

    return true;
  }
}

// =======================================================
// FILE: src/Application/Templates/Commands/UpdateTemplateCommand.cs
// =======================================================
using MediatR;

namespace CRM_Vivid.Application.Templates.Commands;

public record UpdateTemplateCommand : IRequest
{
  public Guid Id { get; set; }
  public string Name { get; set; } = string.Empty;
  public string? Subject { get; set; }
  public string Content { get; set; } = string.Empty;
  public string Type { get; set; } = string.Empty;
}

// =======================================================
// FILE: src/Application/Templates/Commands/CreateTemplateCommads.cs
// =======================================================
using MediatR;

namespace CRM_Vivid.Application.Templates.Commands;

public record CreateTemplateCommand : IRequest<Guid>
{
  public string Name { get; set; } = string.Empty;
  public string? Subject { get; set; }
  public string Content { get; set; } = string.Empty;
  public string Type { get; set; } = string.Empty;
}

// =======================================================
// FILE: src/Application/Templates/Commands/DeleteTemplateCommand.cs
// =======================================================
using CRM_Vivid.Application.Exceptions;
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Entities;
using MediatR;
using Task = System.Threading.Tasks.Task; // Fix ambiguity here too just in case

namespace CRM_Vivid.Application.Templates.Commands;

public record DeleteTemplateCommand(Guid Id) : IRequest;

public class DeleteTemplateCommandHandler : IRequestHandler<DeleteTemplateCommand>
{
  private readonly IApplicationDbContext _context;

  public DeleteTemplateCommandHandler(IApplicationDbContext context)
  {
    _context = context;
  }

  public async Task Handle(DeleteTemplateCommand request, CancellationToken cancellationToken)
  {
    var entity = await _context.Templates
        .FindAsync(new object[] { request.Id }, cancellationToken);

    if (entity == null)
    {
      throw new NotFoundException(nameof(Template), request.Id);
    }

    _context.Templates.Remove(entity);
    await _context.SaveChangesAsync(cancellationToken);
  }
}

// =======================================================
// FILE: src/Application/Templates/Commands/UpdateTemplateCommandHandler.cs
// =======================================================
using CRM_Vivid.Application.Exceptions; // FIX: Correct namespace
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Entities;
using CRM_Vivid.Core.Enum;
using MediatR;
using Task = System.Threading.Tasks.Task; // FIX: Resolve ambiguity with Entity Task

namespace CRM_Vivid.Application.Templates.Commands;

public class UpdateTemplateCommandHandler : IRequestHandler<UpdateTemplateCommand>
{
  private readonly IApplicationDbContext _context;

  public UpdateTemplateCommandHandler(IApplicationDbContext context)
  {
    _context = context;
  }

  public async Task Handle(UpdateTemplateCommand request, CancellationToken cancellationToken)
  {
    var entity = await _context.Templates
        .FindAsync(new object[] { request.Id }, cancellationToken);

    if (entity == null)
    {
      throw new NotFoundException(nameof(Template), request.Id);
    }

    entity.Name = request.Name;
    entity.Subject = request.Subject;
    entity.Content = request.Content;

    // Ensure Enum parsing handles the case-insensitive string
    if (Enum.TryParse<TemplateType>(request.Type, true, out var typeEnum))
    {
      entity.Type = typeEnum;
    }

    await _context.SaveChangesAsync(cancellationToken);
  }
}

// =======================================================
// FILE: src/Application/Templates/Commands/CreateTemplateCommandHandler.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Entities;
using CRM_Vivid.Core.Enum;
using MediatR;

namespace CRM_Vivid.Application.Templates.Commands;

public class CreateTemplateCommandHandler : IRequestHandler<CreateTemplateCommand, Guid>
{
  private readonly IApplicationDbContext _context;

  public CreateTemplateCommandHandler(IApplicationDbContext context)
  {
    _context = context;
  }

  public async Task<Guid> Handle(CreateTemplateCommand request, CancellationToken cancellationToken)
  {
    var entity = new Template
    {
      Id = Guid.NewGuid(),
      Name = request.Name,
      Subject = request.Subject,
      Content = request.Content,
      Type = Enum.Parse<TemplateType>(request.Type, true)
    };

    _context.Templates.Add(entity);
    await _context.SaveChangesAsync(cancellationToken);

    return entity.Id;
  }
}

// =======================================================
// FILE: src/Application/Templates/Validators/CreateTemplateCommandValidator.cs
// =======================================================
using CRM_Vivid.Application.Templates.Commands;
using CRM_Vivid.Core.Enum;
using FluentValidation;

namespace CRM_Vivid.Application.Templates.Validators;

public class CreateTemplateCommandValidator : AbstractValidator<CreateTemplateCommand>
{
  public CreateTemplateCommandValidator()
  {
    RuleFor(v => v.Name)
        .NotEmpty().WithMessage("Name is required.")
        .MaximumLength(200).WithMessage("Name must not exceed 200 characters.");

    RuleFor(v => v.Content)
        .NotEmpty().WithMessage("Content is required.");

    RuleFor(v => v.Type)
        .NotEmpty().WithMessage("Type is required.")
        .IsEnumName(typeof(TemplateType), caseSensitive: false)
        .WithMessage("Type must be either 'Email' or 'SMS'.");
  }
}

// =======================================================
// FILE: src/Application/Automation/Commands/ScheduleEmailCommand.cs
// =======================================================
using CRM_Vivid.Application.Common.Models;
using MediatR;

namespace CRM_Vivid.Application.Automation.Commands;

public class ScheduleEmailCommand : IRequest<bool>
{
  public ContactDto Contact { get; set; } = new();
  public string TemplateContent { get; set; } = string.Empty;
  public string Subject { get; set; } = string.Empty;
  public DateTime ScheduleTime { get; set; }
}

// =======================================================
// FILE: src/Application/Automation/Commands/ScheduleEmailCommandValidator.cs
// =======================================================
using FluentValidation;

namespace CRM_Vivid.Application.Automation.Commands;

public class ScheduleEmailCommandValidator : AbstractValidator<ScheduleEmailCommand>
{
  public ScheduleEmailCommandValidator()
  {
    RuleFor(v => v.Contact)
        .NotNull().WithMessage("Contact information is required.");

    RuleFor(v => v.Contact.Email)
        .NotEmpty().WithMessage("Contact email is required.")
        .EmailAddress().WithMessage("A valid email address is required.")
        .When(v => v.Contact != null);

    RuleFor(v => v.Subject)
        .NotEmpty().WithMessage("Subject is required.");

    RuleFor(v => v.TemplateContent)
        .NotEmpty().WithMessage("Template content is required.");

    RuleFor(v => v.ScheduleTime)
        .GreaterThan(DateTime.UtcNow).WithMessage("Schedule time must be in the future.");
  }
}

// =======================================================
// FILE: src/Application/Automation/Commands/ScheduleEmailCommandHandler.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using MediatR;

namespace CRM_Vivid.Application.Automation.Commands;

public class ScheduleEmailCommandHandler : IRequestHandler<ScheduleEmailCommand, bool>
{
  private readonly ITemplateMerger _merger;
  private readonly IEmailSender _emailSender;
  private readonly IApplicationDbContext _context;

  public ScheduleEmailCommandHandler(
      ITemplateMerger merger,
      IEmailSender emailSender,
      IApplicationDbContext context)
  {
    _merger = merger;
    _emailSender = emailSender;
    _context = context;
  }

  public async Task<bool> Handle(ScheduleEmailCommand request, CancellationToken cancellationToken)
  {
    // NOTE: This is a legacy handler. Ideally, we fetch data here. 
    // For now, we assume the request has what we need or we construct a basic dictionary.

    // Create the dictionary for the merger
    var placeholders = new Dictionary<string, string>
        {
            { "FirstName", request.Contact.FirstName ?? "" },
            { "LastName", request.Contact.LastName ?? "" },
            { "Organization", request.Contact.Organization ?? "" },
            { "Title", request.Contact.Title ?? "" },
            { "ContactName", $"{request.Contact.FirstName} {request.Contact.LastName}" }
        };

    var mergedBody = _merger.Merge(request.TemplateContent, placeholders);

    await _emailSender.SendEmailAsync(request.Contact.Email, request.Subject, mergedBody);

    return true;
  }
}

// =======================================================
// FILE: src/Application/Automation/Commands/ScheduleFollowUpCommand.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Enum;
using MediatR;
using FluentValidation;
using System.Linq.Expressions;
using CRM_Vivid.Application.Exceptions;
using CRM_Vivid.Core.Entities; // <-- FIX 1: ADDED MISSING ENTITY REFERENCE

namespace CRM_Vivid.Application.Automation.Commands;

// This command is the main request object
public record ScheduleFollowUpCommand : IRequest<string>
{
  public Guid ContactId { get; init; }
  public Guid? EventId { get; init; }
  public Guid TemplateId { get; init; }

  public DateTime ScheduleTime { get; init; }
  public CommunicationType Type { get; init; } // Email or SMS (future-proofing)
}

public class ScheduleFollowUpCommandValidator : AbstractValidator<ScheduleFollowUpCommand>
{
  public ScheduleFollowUpCommandValidator()
  {
    RuleFor(v => v.ContactId).NotEmpty().WithMessage("Contact ID is required for follow-up scheduling.");
    RuleFor(v => v.TemplateId).NotEmpty().WithMessage("Template ID is required.");
    RuleFor(v => v.ScheduleTime).NotEmpty().GreaterThan(DateTime.UtcNow).WithMessage("Schedule time must be in the future.");
    RuleFor(v => v.Type).IsInEnum().WithMessage("Invalid communication type specified.");
  }
}

public class ScheduleFollowUpCommandHandler : IRequestHandler<ScheduleFollowUpCommand, string>
{
  private readonly IBackgroundJobService _jobService;
  private readonly IApplicationDbContext _context;
  private readonly ITemplateMerger _merger;
  private readonly IEmailSender _emailSender;
  // private readonly ITelephonyService _smsSender; // Deferred until multi-tenancy is solved

  public ScheduleFollowUpCommandHandler(
      IBackgroundJobService jobService,
      IApplicationDbContext context,
      ITemplateMerger merger,
      IEmailSender emailSender)
  {
    _jobService = jobService;
    _context = context;
    _merger = merger;
    _emailSender = emailSender;
  }

  public async Task<string> Handle(ScheduleFollowUpCommand request, CancellationToken cancellationToken)
  {
    // 1. Fetch Contact and Template (Necessary for Merge Context)
    var contact = await _context.Contacts.FindAsync(new object[] { request.ContactId }, cancellationToken);
    var template = await _context.Templates.FindAsync(new object[] { request.TemplateId }, cancellationToken);

    if (contact == null) throw new NotFoundException(nameof(Contact), request.ContactId);
    if (template == null) throw new NotFoundException(nameof(template), request.TemplateId);
    if (string.IsNullOrWhiteSpace(contact.Email)) throw new Exception($"Contact {contact.FirstName} has no email address for scheduling.");

    // 2. Prepare Placeholder Dictionary (Simplified for now)
    var placeholders = new Dictionary<string, string>
        {
            { "FirstName", contact.FirstName ?? "" },
            { "EventId", request.EventId?.ToString() ?? "N/A" }
        };
    var mergedBody = _merger.Merge(template.Content ?? "", placeholders);
    var mergedSubject = _merger.Merge(template.Subject ?? "", placeholders);

    // 3. Define the Job Call (The job that Hangfire will execute)
    Expression<Action> jobCall = () => _emailSender.SendEmailAsync(
        contact.Email,
        mergedSubject,
        mergedBody,
        request.TemplateId, // Pass the TemplateId
        request.EventId
        );

    // 4. Schedule the Job using IBackgroundJobService (Hangfire)
    var jobId = _jobService.Schedule(jobCall, request.ScheduleTime);

    // 5. Optionally, log the schedule in a new EmailLog entry, referencing the jobId.

    return jobId;
  }
}

// =======================================================
// FILE: src/Application/Documents/Queries/GetDocumentsQuery.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Application.Common.Models;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Documents.Queries;

public class GetDocumentsQuery : IRequest<List<DocumentDto>>
{
  public Guid RelatedEntityId { get; set; }
  public required string RelatedEntityType { get; set; }
}

public class GetDocumentsQueryHandler : IRequestHandler<GetDocumentsQuery, List<DocumentDto>>
{
  private readonly IApplicationDbContext _context;
  private readonly IFileStorageService _fileStorage;

  public GetDocumentsQueryHandler(IApplicationDbContext context, IFileStorageService fileStorage)
  {
    _context = context;
    _fileStorage = fileStorage;
  }

  public async Task<List<DocumentDto>> Handle(GetDocumentsQuery request, CancellationToken cancellationToken)
  {
    var documents = await _context.Documents
        .Where(d => d.RelatedEntityId == request.RelatedEntityId && d.RelatedEntityType == request.RelatedEntityType)
        .OrderByDescending(d => d.UploadedAt)
        .ToListAsync(cancellationToken);

    var dtos = documents.Select(d => new DocumentDto
    {
      Id = d.Id,
      FileName = d.FileName,
      ContentType = d.ContentType,
      Size = d.Size,
      UploadedAt = d.UploadedAt,
      RelatedEntityId = d.RelatedEntityId,
      RelatedEntityType = d.RelatedEntityType,
      Category = d.Category, // Map the Category
      Url = _fileStorage.GetFileUrl(d.StoredFileName)
    }).ToList();

    return dtos;
  }
}

// =======================================================
// FILE: src/Application/Documents/Commands/SimulatedWebhooksRequest.cs
// =======================================================
using System.ComponentModel.DataAnnotations;

namespace CRM_Vivid.Application.Documents.Commands
{
  /// <summary>
  /// DTO representing a simulated contract provider webhook payload.
  /// </summary>
  public class SimulatedWebhookRequest
  {
    // DocumentId is used to look up the document in our system.
    [Required]
    public int DocumentId { get; set; }

    // The status reported by the external provider.
    // We will map this string to our internal ContractStatus enum.
    [Required]
    [MaxLength(20)]
    public required string Status { get; set; }

    // Security check: A secret key or token that the external system uses for validation.
    [Required]
    public required string WebhookSecret { get; set; }
  }
}

// =======================================================
// FILE: src/Application/Documents/Commands/UpdateDocumentStatus.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Application.Exceptions;
using CRM_Vivid.Core.Entities;
using CRM_Vivid.Core.Enum;
using MediatR;
using Microsoft.EntityFrameworkCore;
using TTask = System.Threading.Tasks.Task;

namespace CRM_Vivid.Application.Documents.Commands
{
  public record UpdateDocumentStatusCommand(
      int DocumentId,
      ContractStatus NewStatus) : IRequest;

  public class UpdateDocumentStatusCommandHandler : IRequestHandler<UpdateDocumentStatusCommand>
  {
    private readonly IApplicationDbContext _context;

    public UpdateDocumentStatusCommandHandler(IApplicationDbContext context)
    {
      _context = context;
    }

    public async TTask Handle(UpdateDocumentStatusCommand request, CancellationToken cancellationToken)
    {
      // 1. Find the Document (must be tracked for SaveChanges)
      var document = await _context.Documents
          .FirstOrDefaultAsync(d => d.Id == request.DocumentId, cancellationToken);

      if (document == null)
      {
        throw new NotFoundException(nameof(Document), request.DocumentId.ToString());
      }

      document.Status = request.NewStatus;

      if (request.NewStatus == ContractStatus.Signed)
      {
        document.SignedAt = DateTime.UtcNow;

        // --- INTERNAL COMPLETION LOGIC TRIGGER: LOCK BUDGET (STRING COMPARISON FIX) ---

        // Load the Budget entity with tracking. We are enforcing the Guid comparison 
        // by converting both sides to string to overcome subtle EF tracking/comparison issues.
        var budget = await _context.Budgets
            .FirstOrDefaultAsync(
                b => b.EventId.ToString() == document.RelatedEntityId.ToString(),
                cancellationToken);

        if (budget != null)
        {
          if (!budget.IsLocked)
          {
            // Update tracked entity directly
            budget.IsLocked = true;
          }
        }
        // If the budget doesn't exist, we silently proceed (Document status still updated).
      }

      // Save changes for both the Document (Status) and the Budget (IsLocked)
      await _context.SaveChangesAsync(cancellationToken);
    }
  }
}

// =======================================================
// FILE: src/Application/Documents/Commands/CreateContractCommand.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Application.Exceptions;
using MediatR;
using FluentValidation;
using Microsoft.EntityFrameworkCore;
using CRM_Vivid.Core.Entities; // Required for AnyAsync

namespace CRM_Vivid.Application.Documents.Commands;

// Command returns the raw PDF bytes
public record GenerateContractCommand : IRequest<byte[]>
{
  public Guid EventId { get; init; }
}

public class GenerateContractCommandValidator : AbstractValidator<GenerateContractCommand>
{
  public GenerateContractCommandValidator()
  {
    RuleFor(v => v.EventId)
        .NotEmpty().WithMessage("Event ID is required to generate a contract.");
  }
}

public class GenerateContractCommandHandler : IRequestHandler<GenerateContractCommand, byte[]>
{
  private readonly IContractGenerator _contractGenerator;
  private readonly IApplicationDbContext _context;

  public GenerateContractCommandHandler(IContractGenerator contractGenerator, IApplicationDbContext context)
  {
    _contractGenerator = contractGenerator;
    _context = context;
  }

  public async Task<byte[]> Handle(GenerateContractCommand request, CancellationToken cancellationToken)
  {
    // Sanity check: Ensure the event exists before generating a contract for it.
    var eventExists = await _context.Events.AnyAsync(e => e.Id == request.EventId, cancellationToken);

    if (!eventExists)
    {
      throw new NotFoundException(nameof(Event), request.EventId);
    }

    // Call the service to create the document
    var pdfBytes = await _contractGenerator.GenerateContractAsync(request.EventId);

    return pdfBytes;
  }
}

// =======================================================
// FILE: src/Application/Documents/Commands/UploadDocumentCommand.cs
// =======================================================
using AutoMapper;
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Core.Entities;
using FluentValidation;
using MediatR;

namespace CRM_Vivid.Application.Documents.Commands
{
  public class UploadDocumentCommand : IRequest<DocumentDto>
  {
    public required string FileName { get; set; }
    public required string ContentType { get; set; }
    public long Size { get; set; }
    public required Stream FileContent { get; set; }
    public Guid RelatedEntityId { get; set; }
    public required string RelatedEntityType { get; set; }

    // --- NEW ---
    public string Category { get; set; } = "General";
  }

  public class UploadDocumentCommandValidator : AbstractValidator<UploadDocumentCommand>
  {
    public UploadDocumentCommandValidator()
    {
      RuleFor(v => v.FileName).NotEmpty().MaximumLength(255);
      RuleFor(v => v.ContentType).NotEmpty();
      RuleFor(v => v.RelatedEntityId).NotEmpty();
      RuleFor(v => v.RelatedEntityType).NotEmpty().MaximumLength(50);
      RuleFor(v => v.FileContent).NotNull();
      RuleFor(v => v.Size).GreaterThan(0);
      RuleFor(v => v.Category).MaximumLength(50);
    }
  }

  public class UploadDocumentCommandHandler : IRequestHandler<UploadDocumentCommand, DocumentDto>
  {
    private readonly IApplicationDbContext _context;
    private readonly IFileStorageService _fileStorage;
    private readonly IMapper _mapper;

    public UploadDocumentCommandHandler(IApplicationDbContext context, IFileStorageService fileStorage, IMapper mapper)
    {
      _context = context;
      _fileStorage = fileStorage;
      _mapper = mapper;
    }

    public async Task<DocumentDto> Handle(UploadDocumentCommand request, CancellationToken cancellationToken)
    {
      // 1. Upload physical file
      var storedFileName = await _fileStorage.UploadAsync(request.FileContent, request.FileName);

      // 2. Create Entity
      var document = new Document
      {
        FileName = request.FileName,
        StoredFileName = storedFileName,
        ContentType = request.ContentType,
        Size = request.Size,
        RelatedEntityId = request.RelatedEntityId,
        RelatedEntityType = request.RelatedEntityType,
        Category = request.Category ?? "General", // Default if null
        UploadedAt = DateTime.UtcNow
      };

      _context.Documents.Add(document);
      await _context.SaveChangesAsync(cancellationToken);

      // 3. Map and return
      var dto = new DocumentDto
      {
        Id = document.Id,
        FileName = document.FileName,
        ContentType = document.ContentType,
        Size = document.Size,
        UploadedAt = document.UploadedAt,
        RelatedEntityId = document.RelatedEntityId,
        RelatedEntityType = document.RelatedEntityType,
        Category = document.Category, // Map the new field
        Url = _fileStorage.GetFileUrl(storedFileName)
      };

      return dto;
    }
  }
}

// =======================================================
// FILE: src/Application/Documents/Commands/DeleteDocumentCommand.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Application.Exceptions; // Corrected Namespace
using CRM_Vivid.Core.Entities;
using MediatR;

// Protocol 10: The Task Alias (Resolves Ambiguity with Core.Entities.Task)
using Task = System.Threading.Tasks.Task;

namespace CRM_Vivid.Application.Documents.Commands;

public record DeleteDocumentCommand(int Id) : IRequest;

public class DeleteDocumentCommandHandler : IRequestHandler<DeleteDocumentCommand>
{
  private readonly IApplicationDbContext _context;
  private readonly IFileStorageService _fileStorage;

  public DeleteDocumentCommandHandler(IApplicationDbContext context, IFileStorageService fileStorage)
  {
    _context = context;
    _fileStorage = fileStorage;
  }

  public async Task Handle(DeleteDocumentCommand request, CancellationToken cancellationToken)
  {
    var entity = await _context.Documents.FindAsync(new object[] { request.Id }, cancellationToken);

    if (entity == null)
    {
      throw new NotFoundException(nameof(Document), request.Id);
    }

    // 1. Delete from Disk (The Shredder)
    await _fileStorage.DeleteAsync(entity.StoredFileName);

    // 2. Delete from Database
    _context.Documents.Remove(entity);

    await _context.SaveChangesAsync(cancellationToken);
  }
}

// =======================================================
// FILE: src/Application/Events/Queries/GetEventsQueryHandler.cs
// =======================================================
using AutoMapper;
using AutoMapper.QueryableExtensions;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Common.Interfaces;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Events.Queries
{
  public class GetEventsQueryHandler : IRequestHandler<GetEventsQuery, List<EventDto>>
  {
    private readonly IApplicationDbContext _context;
    private readonly IMapper _mapper;

    public GetEventsQueryHandler(IApplicationDbContext context, IMapper mapper)
    {
      _context = context;
      _mapper = mapper;
    }

    public async Task<List<EventDto>> Handle(GetEventsQuery request, CancellationToken cancellationToken)
    {
      // We'll add .AsNoTracking() for a read-only query, which is more efficient.
      return await _context.Events
          .ProjectTo<EventDto>(_mapper.ConfigurationProvider)
          .ToListAsync(cancellationToken);
    }
  }
}

// =======================================================
// FILE: src/Application/Events/Queries/GetVendorsForEventQueryHandler.cs
// =======================================================
// FILE: src/Application/Events/Queries/GetVendorsForEventQueryHandler.cs (NEW FILE)
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Application.Common.Models;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Events.Queries;

// Query is defined to fetch vendors for a specific event
public class GetVendorsForEventQuery : IRequest<List<VendorDto>>
{
  public Guid EventId { get; set; }
}

public class GetVendorsForEventQueryHandler : IRequestHandler<GetVendorsForEventQuery, List<VendorDto>>
{
  private readonly IApplicationDbContext _context;

  public GetVendorsForEventQueryHandler(IApplicationDbContext context)
  {
    _context = context;
  }

  public async Task<List<VendorDto>> Handle(GetVendorsForEventQuery request, CancellationToken cancellationToken)
  {
    // Select vendors linked to the event, projecting the Role from the join table
    return await _context.EventVendors
        .Where(ev => ev.EventId == request.EventId)
        .Select(ev => new VendorDto
        {
          Id = ev.Vendor!.Id,
          Name = ev.Vendor.Name,
          PhoneNumber = ev.Vendor.PhoneNumber,
          Email = ev.Vendor.Email,
          // NOTE: We rely on AutoMapper/ToString() conventions for enums here,
          // or ensure explicit mapping in MappingProfile for ServiceType.
          ServiceType = ev.Vendor.ServiceType.ToString(),
          Attributes = ev.Vendor.Attributes,

          // CRITICAL: Inject the Role from the join entity (ev) into the DTO
          Role = ev.Role
        })
        .ToListAsync(cancellationToken);
  }
}

// =======================================================
// FILE: src/Application/Events/Queries/GetContactsForEventQueryHandler.cs
// =======================================================
// FILE: src/Application/Events/Queries/GetContactsForEventQueryHandler.cs (MODIFIED)
// src/Application/Events/Queries/GetContactsForEventQueryHandler.cs
using AutoMapper;
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Application.Common.Models;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Events.Queries;

public class GetContactsForEventQueryHandler : IRequestHandler<GetContactsForEventQuery, List<ContactDto>>
{
  private readonly IApplicationDbContext _context;
  private readonly IMapper _mapper;

  public GetContactsForEventQueryHandler(IApplicationDbContext context, IMapper mapper)
  {
    _context = context;
    _mapper = mapper;
  }

  public async Task<List<ContactDto>> Handle(GetContactsForEventQuery request, CancellationToken cancellationToken)
  {
    // --- PHASE 34 FIX: PROJECTING ROLE FROM JOIN TABLE ---
    return await _context.EventContacts
        .Where(ec => ec.EventId == request.EventId)
        // Select the Contact entity, but project the Role from the join table
        .Select(ec => new ContactDto
        {
          Id = ec.Contact.Id,
          FirstName = ec.Contact.FirstName,
          LastName = ec.Contact.LastName,
          Email = ec.Contact.Email,
          PhoneNumber = ec.Contact.PhoneNumber,
          Title = ec.Contact.Title,
          Organization = ec.Contact.Organization,
          Stage = ec.Contact.Stage,
          ConnectionStatus = ec.Contact.ConnectionStatus,
          IsLead = ec.Contact.IsLead,
          FollowUpCount = ec.Contact.FollowUpCount,
          LastContactedAt = ec.Contact.LastContactedAt,
          Source = ec.Contact.Source,

          // CRITICAL: Inject the Role from the join entity (ec) into the DTO
          Role = ec.Role
        })
        .ToListAsync(cancellationToken);
    // -----------------------------------------------------------------
  }
}

// =======================================================
// FILE: src/Application/Events/Queries/GetEventsForVendorQuery.cs
// =======================================================
// src/Application/Vendors/Queries/GetEventsForVendorQuery.cs
using CRM_Vivid.Application.Common.Models;
using MediatR;

namespace CRM_Vivid.Application.Vendors.Queries
{
  public class GetEventsForVendorQuery : IRequest<List<EventDto>>
  {
    public Guid VendorId { get; set; }
  }
}

// =======================================================
// FILE: src/Application/Events/Queries/GetEventsForVendorQueryHandler.cs
// =======================================================
// src/Application/Vendors/Queries/GetEventsForVendorQueryHandler.cs
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Common.Interfaces;
using AutoMapper;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Vendors.Queries
{
  public class GetEventsForVendorQueryHandler : IRequestHandler<GetEventsForVendorQuery, List<EventDto>>
  {
    private readonly IApplicationDbContext _context;
    private readonly IMapper _mapper;

    public GetEventsForVendorQueryHandler(IApplicationDbContext context, IMapper mapper)
    {
      _context = context;
      _mapper = mapper;
    }

    public async Task<List<EventDto>> Handle(GetEventsForVendorQuery request, CancellationToken cancellationToken)
    {

      var events = await _context.EventVendors
          .Where(ev => ev.VendorId == request.VendorId)
          .Select(ev => ev.Event)
          // FIX: Use the correct property name 'StartDateTime'
          .OrderBy(e => e!.StartDateTime)
          .ToListAsync(cancellationToken);

      return _mapper.Map<List<EventDto>>(events);
    }
  }
}

// =======================================================
// FILE: src/Application/Events/Queries/GetEventByIdQuery.cs
// =======================================================
// src/Application/Events/Queries/GetEventByIdQuery.cs
using CRM_Vivid.Application.Common.Models;
using MediatR;

namespace CRM_Vivid.Application.Events.Queries;

public class GetEventByIdQuery : IRequest<EventDto?>
{
  public Guid Id { get; set; }
}

// =======================================================
// FILE: src/Application/Events/Queries/GetContactsForEventQuery.cs
// =======================================================
// src/Application/Events/Queries/GetContactsForEventQuery.cs
using CRM_Vivid.Application.Common.Models;
using MediatR;

namespace CRM_Vivid.Application.Events.Queries
{
  public class GetContactsForEventQuery : IRequest<List<ContactDto>>
  {
    public Guid EventId { get; set; }
  }
}



// =======================================================
// FILE: src/Application/Events/Queries/GetEventByIdQueryHandler.cs
// =======================================================
// src/Application/Events/Queries/GetEventByIdQueryHandler.cs
using AutoMapper;
using CRM_Vivid.Application.Common.Models;
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Application.Exceptions;
using MediatR;
using Microsoft.EntityFrameworkCore;
using CRM_Vivid.Core.Entities;

namespace CRM_Vivid.Application.Events.Queries;

public class GetEventByIdQueryHandler : IRequestHandler<GetEventByIdQuery, EventDto?>
{
  private readonly IApplicationDbContext _context;
  private readonly IMapper _mapper;

  public GetEventByIdQueryHandler(IApplicationDbContext context, IMapper mapper)
  {
    _context = context;
    _mapper = mapper;
  }

  public async Task<EventDto?> Handle(GetEventByIdQuery request, CancellationToken cancellationToken)
  {
    var eventItem = await _context.Events
        .AsNoTracking() // Use AsNoTracking for read-only operations
        .FirstOrDefaultAsync(e => e.Id == request.Id, cancellationToken);

    if (eventItem == null)
    {
      throw new NotFoundException(nameof(Event), request.Id);
    }

    return _mapper.Map<EventDto?>(eventItem);
  }
}

// =======================================================
// FILE: src/Application/Events/Queries/GetEventsQuery.cs
// =======================================================
using CRM_Vivid.Application.Common.Models;
using MediatR;

namespace CRM_Vivid.Application.Events.Queries
{
  // This query will fetch all events, so it doesn't need any properties.
  // We're returning a list of Event entities directly for now.
  public record GetEventsQuery : IRequest<List<EventDto>>
  {

  }
}

// =======================================================
// FILE: src/Application/Events/Commands/CreateEventCommandValidator.cs
// =======================================================
using FluentValidation;

namespace CRM_Vivid.Application.Events.Commands
{
  public class CreateEventCommandValidator : AbstractValidator<CreateEventCommand>
  {
    public CreateEventCommandValidator()
    {
      RuleFor(x => x.Name)
          .NotEmpty().WithMessage("Event name is required.")
          .MaximumLength(200).WithMessage("Event name must not exceed 200 characters.");

      RuleFor(x => x.StartDateTime)
          .NotEmpty().WithMessage("Event date is required.")
          .GreaterThan(DateTime.UtcNow).WithMessage("Event date must be in the future.");

      RuleFor(x => x.EndDateTime)
                .NotEmpty().WithMessage("End date/time is required.")
                .GreaterThan(x => x.StartDateTime).WithMessage("End time must be after the start time.");

      RuleFor(x => x.Location)
          .MaximumLength(300).WithMessage("Location must not exceed 300 characters.");

      RuleFor(x => x.Description)
        .MaximumLength(500).WithMessage("Description must not exceed 500 characters.");
    }
  }
}

// =======================================================
// FILE: src/Application/Events/Commands/DeleteVendorFromEventCommandHandler.cs
// =======================================================
// src/Application/Events/Commands/DeleteVendorFromEventCommandHandler.cs
using CRM_Vivid.Application.Common.Interfaces;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Events.Commands
{
  // FIX: Ensure IRequestHandler is returning the correct Task type (Task<Unit>)
  public class DeleteVendorFromEventCommandHandler : IRequestHandler<DeleteVendorFromEventCommand>
  {
    private readonly IApplicationDbContext _context;

    public DeleteVendorFromEventCommandHandler(IApplicationDbContext context)
    {
      _context = context;
    }

    // The method signature must match exactly
    public async Task<Unit> Handle(DeleteVendorFromEventCommand request, CancellationToken cancellationToken)
    {
      var eventVendor = await _context.EventVendors
          .FirstOrDefaultAsync(ev => ev.EventId == request.EventId && ev.VendorId == request.VendorId, cancellationToken);

      if (eventVendor == null)
      {
        return Unit.Value;
      }

      _context.EventVendors.Remove(eventVendor);
      await _context.SaveChangesAsync(cancellationToken);

      return Unit.Value;
    }

    System.Threading.Tasks.Task IRequestHandler<DeleteVendorFromEventCommand>.Handle(DeleteVendorFromEventCommand request, CancellationToken cancellationToken)
    {
      return Handle(request, cancellationToken);
    }
  }
}

// =======================================================
// FILE: src/Application/Events/Commands/CreateEventCommand.cs
// =======================================================
using MediatR;

namespace CRM_Vivid.Application.Events.Commands
{
  public record CreateEventCommand : IRequest<Guid>
  {
    public string Name { get; init; } = string.Empty;
    public DateTime StartDateTime { get; init; }
    public DateTime EndDateTime { get; init; }
    public bool IsPublic { get; init; }
    public string? Description { get; init; }
    public string? Location { get; init; }
  }
}

// =======================================================
// FILE: src/Application/Events/Commands/CreateEventCommandHandler.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Entities;
using MediatR;
using CRM_Vivid.Core.Enums;

namespace CRM_Vivid.Application.Events.Commands
{
  public class CreateEventCommandHandler : IRequestHandler<CreateEventCommand, Guid>
  {
    private readonly IApplicationDbContext _context;

    public CreateEventCommandHandler(IApplicationDbContext context)
    {
      _context = context;
    }

    public async Task<Guid> Handle(CreateEventCommand request, CancellationToken cancellationToken)
    {

      var newEvent = new Event
      {
        Id = Guid.NewGuid(),
        Name = request.Name,
        Status = EventStatus.Planned,
        StartDateTime = request.StartDateTime.ToUniversalTime(),
        EndDateTime = request.EndDateTime.ToUniversalTime(),
        IsPublic = request.IsPublic,
        Description = request.Description,
        Location = request.Location
      };

      _context.Events.Add(newEvent);

      await _context.SaveChangesAsync(cancellationToken);

      return newEvent.Id;
    }
  }
}

// =======================================================
// FILE: src/Application/Events/Commands/DeleteContactFromEventCommandaHandler.cs
// =======================================================
// src/Application/Events/Commands/DeleteContactFromEventCommandHandler.cs

using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Application.Exceptions;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Events.Commands;

public record DeleteContactFromEventCommand : IRequest<Unit>
{
  public Guid EventId { get; init; }
  public Guid ContactId { get; init; }
}

public class DeleteContactFromEventCommandHandler : IRequestHandler<DeleteContactFromEventCommand, Unit>
{
  private readonly IApplicationDbContext _context;

  public DeleteContactFromEventCommandHandler(IApplicationDbContext context)
  {
    _context = context;
  }

  public async Task<Unit> Handle(DeleteContactFromEventCommand request, CancellationToken cancellationToken)
  {
    // Find the specific join entity (EventContact)
    var entity = await _context.EventContacts
        .FirstOrDefaultAsync(ec => ec.EventId == request.EventId && ec.ContactId == request.ContactId, cancellationToken);

    if (entity == null)
    {
      throw new NotFoundException($"Contact with ID {request.ContactId} is not linked to Event with ID {request.EventId}.");
    }

    _context.EventContacts.Remove(entity);

    await _context.SaveChangesAsync(cancellationToken);

    return Unit.Value; // Protocol 2 Compliance: Returns Unit for a Command with no return data
  }
}

// =======================================================
// FILE: src/Application/Events/Commands/AddVendorToEventCommandHandler.cs
// =======================================================
// FILE: src/Application/Events/Commands/AddVendorToEventCommandHandler.cs (MODIFIED)
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Entities;
using MediatR;
using CRM_Vivid.Application.Exceptions;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Events.Commands
{
  public class AddVendorToEventCommandHandler : IRequestHandler<AddVendorToEventCommand, Guid>
  {
    private readonly IApplicationDbContext _context;

    public AddVendorToEventCommandHandler(IApplicationDbContext context)
    {
      _context = context;
    }

    public async Task<Guid> Handle(AddVendorToEventCommand request, CancellationToken cancellationToken)
    {
      // 1. Check if Event exists
      if (await _context.Events.FindAsync(new object[] { request.EventId }, cancellationToken) == null)
      {
        throw new NotFoundException(nameof(Event), request.EventId);
      }

      // 2. Check if Vendor exists
      if (await _context.Vendors.FindAsync(new object[] { request.VendorId }, cancellationToken) == null)
      {
        throw new NotFoundException(nameof(Vendor), request.VendorId);
      }

      // 3. Check for existing link (Unique constraint enforcement)
      var linkExists = await _context.EventVendors
          .AnyAsync(ev => ev.EventId == request.EventId && ev.VendorId == request.VendorId, cancellationToken);

      if (linkExists)
      {
        throw new ArgumentException($"Vendor with ID {request.VendorId} is already linked to event {request.EventId}.");
      }

      // 4. Create join entity and assign role
      var eventVendor = new EventVendor
      {
        EventId = request.EventId,
        VendorId = request.VendorId,
        // --- NEW: PHASE 34 ASSIGN THE ROLE ---
        Role = request.Role
      };

      await _context.EventVendors.AddAsync(eventVendor, cancellationToken);
      await _context.SaveChangesAsync(cancellationToken);

      return eventVendor.Id;
    }
  }
}

// =======================================================
// FILE: src/Application/Events/Commands/UpdateEventCommandValidator.cs
// =======================================================
// FILE: src/Application/Events/Commands/UpdateEventCommandValidator.cs
using FluentValidation;

namespace CRM_Vivid.Application.Events.Commands;

public class UpdateEventCommandValidator : AbstractValidator<UpdateEventCommand>
{
  public UpdateEventCommandValidator()
  {
    RuleFor(x => x.Id).NotEmpty().WithMessage("Event ID is required for update.");
    RuleFor(x => x.Name)
        .NotEmpty().WithMessage("Event name is required.")
        .MaximumLength(200).WithMessage("Event name must not exceed 200 characters.");

    // --- PHASE 33 FIX: RELAX FUTURE DATE CONSTRAINT ON UPDATE ---
    // Constraint removed: GreaterThan(DateTime.UtcNow) 
    RuleFor(x => x.StartDateTime)
        .NotEmpty().WithMessage("Event start date/time is required.");

    RuleFor(x => x.EndDateTime)
        .NotEmpty().WithMessage("End date/time is required.")
        .GreaterThan(x => x.StartDateTime).WithMessage("End time must be after the start time.");
    // -------------------------------------------------------------

    RuleFor(x => x.Status)
        .NotEmpty().WithMessage("Status is required.");
  }
}

// =======================================================
// FILE: src/Application/Events/Commands/UpdateEventCommandHandler.cs
// =======================================================
// src/Application/Events/Commands/UpdateEventCommandHandler.cs
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Enums; // <-- Import the enum
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Events.Commands;

public class UpdateEventCommandHandler : IRequestHandler<UpdateEventCommand>
{
  private readonly IApplicationDbContext _context;

  public UpdateEventCommandHandler(IApplicationDbContext context)
  {
    _context = context;
  }

  public async Task Handle(UpdateEventCommand request, CancellationToken cancellationToken)
  {
    var eventItem = await _context.Events
        .FirstOrDefaultAsync(e => e.Id == request.Id, cancellationToken);

    if (eventItem == null)
    {
      // Later, we can replace this with a custom NotFoundException
      throw new Exception($"Event with ID {request.Id} not found.");
    }

    // --- Parse the status string ---
    if (!Enum.TryParse<EventStatus>(request.Status, true, out var eventStatus))
    {
      throw new ArgumentException($"Invalid event status: {request.Status}. Valid values are Planned, InProgress, Completed, Postponed, Cancelled.");
    }
    // -------------------------------

    // Update properties based on your Event.cs file
    eventItem.Name = request.Name;
    eventItem.Status = eventStatus; // Use the parsed enum
    eventItem.StartDateTime = request.StartDateTime.ToUniversalTime();
    eventItem.EndDateTime = request.EndDateTime.ToUniversalTime();
    eventItem.IsPublic = request.IsPublic;
    eventItem.Description = request.Description;
    eventItem.Location = request.Location;
    // We don't have an 'UpdatedAt' field on your entity, so we'll skip it.


    await _context.SaveChangesAsync(cancellationToken);
  }
}

// =======================================================
// FILE: src/Application/Events/Commands/AddVendorToEventCommand.cs
// =======================================================
// src/Application/Events/Commands/AddVendorToEventCommand.cs
using MediatR;

namespace CRM_Vivid.Application.Events.Commands
{
  public class AddVendorToEventCommand : IRequest<Guid>
  {
    public Guid EventId { get; set; }
    public Guid VendorId { get; set; }
    public string? Role { get; set; }
  }

}

// =======================================================
// FILE: src/Application/Events/Commands/AddContactToEventCommandHandler.cs
// =======================================================
// FILE: src/Application/Events/Commands/AddContactToEventCommandHandler.cs (MODIFIED)
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Entities;
using MediatR;
using Microsoft.EntityFrameworkCore;
using CRM_Vivid.Application.Exceptions; // NEW: Import the custom exception

namespace CRM_Vivid.Application.Events.Commands;

public class AddContactToEventCommandHandler : IRequestHandler<AddContactToEventCommand>
{
  private readonly IApplicationDbContext _context;
  private readonly ICurrentUserService _currentUserService;

  public AddContactToEventCommandHandler(IApplicationDbContext context, ICurrentUserService currentUserService)
  {
    _context = context;
    _currentUserService = currentUserService;
  }

  public async System.Threading.Tasks.Task Handle(AddContactToEventCommand request, CancellationToken cancellationToken)
  {
    // 1. Check if the Event exists
    var eventExists = await _context.Events
        .AnyAsync(e => e.Id == request.EventId, cancellationToken);
    if (!eventExists)
    {
      // FIX 1: Use NotFoundException
      throw new NotFoundException(nameof(Event), request.EventId);
    }

    // 2. Check if the Contact exists
    var contactExists = await _context.Contacts
        .AnyAsync(c => c.Id == request.ContactId, cancellationToken);
    if (!contactExists)
    {
      // FIX 2: Use NotFoundException
      throw new NotFoundException(nameof(Contact), request.ContactId);
    }

    // Optional: Check if the link already exists
    var linkExists = await _context.EventContacts
        .AnyAsync(ec => ec.EventId == request.EventId && ec.ContactId == request.ContactId, cancellationToken);
    if (linkExists)
    {
      // FIX 3: Use ArgumentException for business logic violation
      throw new ArgumentException($"Contact with ID {request.ContactId} is already linked to event {request.EventId}.");
    }

    // 3. Create the new EventContact entity
    var eventContact = new EventContact
    {
      EventId = request.EventId,
      ContactId = request.ContactId,
      // Role mapping is correct for Phase 34
      Role = request.Role ?? string.Empty,
      CreatedByUserId = _currentUserService.CurrentUserId
    };

    // 4. Add it to the DbSet
    _context.EventContacts.Add(eventContact);

    // 5. Save changes
    await _context.SaveChangesAsync(cancellationToken);
  }
}

// =======================================================
// FILE: src/Application/Events/Commands/DeleteEventCommandHandler.cs
// =======================================================
// src/Application/Events/Commands/DeleteEventCommandHandler.cs
using CRM_Vivid.Application.Common.Interfaces;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CRM_Vivid.Application.Events.Commands;

public class DeleteEventCommandHandler : IRequestHandler<DeleteEventCommand>
{
  private readonly IApplicationDbContext _context;

  public DeleteEventCommandHandler(IApplicationDbContext context)
  {
    _context = context;
  }

  public async Task Handle(DeleteEventCommand request, CancellationToken cancellationToken)
  {
    var eventItem = await _context.Events
        .FirstOrDefaultAsync(e => e.Id == request.Id, cancellationToken);

    if (eventItem == null)
    {
      // We can replace this with a custom NotFoundException later
      throw new Exception($"Event with ID {request.Id} not found.");
    }

    _context.Events.Remove(eventItem);

    await _context.SaveChangesAsync(cancellationToken);
  }
}

// =======================================================
// FILE: src/Application/Events/Commands/DeleteVendorFromEventCommand.cs
// =======================================================
// src/Application/Events/Commands/DeleteVendorFromEventCommand.cs
using MediatR;

namespace CRM_Vivid.Application.Events.Commands
{
  public class DeleteVendorFromEventCommand : IRequest
  {
    public Guid EventId { get; set; }
    public Guid VendorId { get; set; }
  }
}

// =======================================================
// FILE: src/Application/Events/Commands/UpdateEventCommand.cs
// =======================================================
// src/Application/Events/Commands/UpdateEventCommand.cs
using MediatR;

namespace CRM_Vivid.Application.Events.Commands;

public class UpdateEventCommand : IRequest
{
  public Guid Id { get; set; }
  public string Name { get; set; } = string.Empty;
  public string Status { get; set; } = string.Empty;
  public DateTime StartDateTime { get; set; }
  public DateTime EndDateTime { get; set; }
  public string? Location { get; set; }
  public string? Description { get; set; }

  public bool IsPublic { get; set; }
  public string? Attributes { get; set; }
}

// =======================================================
// FILE: src/Application/Events/Commands/AddContactToEventCommand.cs
// =======================================================
// src/Application/Events/Commands/AddContactToEventCommand.cs
using MediatR;

namespace CRM_Vivid.Application.Events.Commands;

public class AddContactToEventCommand : IRequest
{
  public Guid EventId { get; set; }
  public Guid ContactId { get; set; }
  public string? Role { get; set; }
}

// =======================================================
// FILE: src/Application/Events/Commands/DeleteEventCommand.cs
// =======================================================
// src/Application/Events/Commands/DeleteEventCommand.cs
using MediatR;

namespace CRM_Vivid.Application.Events.Commands;

public class DeleteEventCommand : IRequest
{
  public Guid Id { get; set; }
}

// =======================================================
// FILE: src/Infrastructure/DependencyInjection.cs
// =======================================================
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Infrastructure.Persistence;
using CRM_Vivid.Infrastructure.Services;
using Hangfire;
using Hangfire.Redis.StackExchange;
using Microsoft.AspNetCore.Http;

namespace CRM_Vivid.Infrastructure;

public static class DependencyInjection
{
  public static IServiceCollection AddInfrastructureServices(this IServiceCollection services, IConfiguration configuration)
  {
    // 1. Database Configuration
    services.AddDbContext<ApplicationDbContext>(options =>
        options.UseNpgsql(
            configuration.GetConnectionString("DefaultConnection"),
            b => b.MigrationsAssembly(typeof(ApplicationDbContext).Assembly.FullName)));

    // 2. Bind the Interface to the Concrete Context
    services.AddScoped<IApplicationDbContext>(provider => provider.GetRequiredService<ApplicationDbContext>());

    services.AddSingleton<IHttpContextAccessor, HttpContextAccessor>();

    services.AddScoped<ICurrentUserService, CurrentUserService>();

    // 3. Communication Services
    services.AddTransient<IEmailSender, SendGridEmailSender>();
    // Note: ITelephonyService registration is deferred for now.

    // 4. Core Services
    services.AddTransient<ITemplateMerger, TemplateMerger>();
    services.AddTransient<IContractGenerator, ContractGenerator>();

    // 5. Background Job Processing (FIX: Using fully qualified name to force resolution)
    services.AddTransient<IBackgroundJobService, HangfireJobService>();

    // 6. Hangfire & Redis Configuration (Preserved)
    services.AddHangfire(config => config
        .SetDataCompatibilityLevel(CompatibilityLevel.Version_180)
        .UseSimpleAssemblyNameTypeSerializer()
        .UseRecommendedSerializerSettings()
        .UseRedisStorage(configuration.GetConnectionString("RedisConnection")));

    services.AddHangfireServer();

    // 7. File Storage
    services.AddScoped<IFileStorageService, LocalFileStorageService>();

    return services;
  }
}

// =======================================================
// FILE: src/Infrastructure/Persistence/Configurations/TemplateConfiguration.cs
// =======================================================
using CRM_Vivid.Core.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CRM_Vivid.Infrastructure.Persistence.Configurations;

public class TemplateConfiguration : IEntityTypeConfiguration<Template>
{
  public void Configure(EntityTypeBuilder<Template> builder)
  {
    builder.HasKey(t => t.Id);

    builder.Property(t => t.Name)
        .IsRequired()
        .HasMaxLength(200);

    builder.Property(t => t.Subject)
        .HasMaxLength(200);

    builder.Property(t => t.Content)
        .IsRequired();

    builder.Property(t => t.Type)
        .IsRequired()
        .HasConversion<string>();
  }
}

// =======================================================
// FILE: src/Infrastructure/Persistence/Configurations/ContactConfiguration.cs
// =======================================================
using CRM_Vivid.Core.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CRM_Vivid.Infrastructure.Persistence.Configurations;

public class ContactConfiguration : IEntityTypeConfiguration<Contact>
{
  public void Configure(EntityTypeBuilder<Contact> builder)
  {
    builder.ToTable("Contacts");
    builder.HasKey(c => c.Id);

    // Critical: Prevent duplicate emails
    builder.HasIndex(c => c.Email).IsUnique();

    // New: Index for Pipeline Performance
    builder.HasIndex(c => c.IsLead);
    builder.HasIndex(c => c.Stage);

    builder.Property(c => c.FirstName).IsRequired().HasMaxLength(100);
    builder.Property(c => c.LastName).HasMaxLength(100);
    builder.Property(c => c.Email).IsRequired().HasMaxLength(256);
    builder.Property(c => c.PhoneNumber).HasMaxLength(50);
    builder.Property(c => c.Title).HasMaxLength(100);
    builder.Property(c => c.Organization).HasMaxLength(100);

    // Preserved PostgreSQL specific timestamp logic
    builder.Property(c => c.CreatedAt)
        .IsRequired()
        .HasDefaultValueSql("now()");

    builder.Property(c => c.UpdatedAt)
        .IsRequired()
        .HasDefaultValueSql("now()");
  }
}

// =======================================================
// FILE: src/Infrastructure/Persistence/Configurations/EmailLogConfiguration.cs
// =======================================================
using CRM_Vivid.Core.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CRM_Vivid.Infrastructure.Persistence.Configurations
{
  public class EmailLogConfiguration : IEntityTypeConfiguration<EmailLog>
  {
    public void Configure(EntityTypeBuilder<EmailLog> builder)
    {
      builder.HasKey(e => e.Id);

      builder.Property(e => e.To)
          .IsRequired()
          .HasMaxLength(256);

      builder.Property(e => e.Subject)
          .IsRequired()
          .HasMaxLength(500);

      builder.Property(e => e.Body)
          .IsRequired();

      builder.Property(e => e.IsSuccess)
          .IsRequired();

      builder.Property(e => e.ErrorMessage)
          .IsRequired(false);

      // FIX: Explicitly map relationship to Contact.EmailLogs
      builder.HasOne(e => e.Contact)
          .WithMany(c => c.EmailLogs) // <--- FIX: Pointing to the ICollection on Contact
          .HasForeignKey(e => e.ContactId)
          .OnDelete(DeleteBehavior.SetNull);
    }
  }
}

// =======================================================
// FILE: src/Infrastructure/Persistence/Configurations/EventContactConfiguration.cs
// =======================================================
using CRM_Vivid.Core.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CRM_Vivid.Infrastructure.Persistence.Configurations
{
  public class EventContactConfiguration : IEntityTypeConfiguration<EventContact>
  {
    public void Configure(EntityTypeBuilder<EventContact> builder)
    {
      // Set primary key
      builder.HasKey(ec => new { ec.EventId, ec.ContactId });

      builder.Property(ec => ec.Role)
          .HasMaxLength(100);

      // Configure the many-to-many relationship

      // Relationship from Event -> EventContact
      builder.HasOne(ec => ec.Event)
          .WithMany(e => e.EventContacts) // Event has 'EventContacts' collection
          .HasForeignKey(ec => ec.EventId);
      // We can remove OnDelete cascade, EF's default is fine

      // Relationship from Contact -> EventContact
      builder.HasOne(ec => ec.Contact)
          .WithMany(c => c.EventContacts) // Contact has 'EventContacts' collection
          .HasForeignKey(ec => ec.ContactId);
    }
  }
}

// =======================================================
// FILE: src/Infrastructure/Persistence/Configurations/EventVendorConfiguration.cs
// =======================================================
// src/Infrastructure/Persistence/Configurations/EventVendorConfiguration.cs
using CRM_Vivid.Core.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CRM_Vivid.Infrastructure.Persistence.Configurations
{
  public class EventVendorConfiguration : IEntityTypeConfiguration<EventVendor>
  {
    public void Configure(EntityTypeBuilder<EventVendor> builder)
    {
      // Set Id as the Primary Key
      builder.HasKey(ev => ev.Id);

      // Event relationship
      builder
          .HasOne(ev => ev.Event)
          // FIX: Used the correct navigation property name 'EventVendors'
          .WithMany(e => e.EventVendors)
          .HasForeignKey(ev => ev.EventId)
          .IsRequired();

      // Vendor relationship
      builder
          .HasOne(ev => ev.Vendor)
          // FIX: Used the correct navigation property name 'EventVendors'
          .WithMany(v => v.EventVendors)
          .HasForeignKey(ev => ev.VendorId)
          .IsRequired();

      // Unique constraint to prevent duplicate links: one vendor can only be linked to an event once.
      builder.HasIndex(ev => new { ev.EventId, ev.VendorId }).IsUnique();
    }
  }
}

// =======================================================
// FILE: src/Infrastructure/Persistence/Configurations/BudgetConfiguration.cs
// =======================================================
using CRM_Vivid.Core.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CRM_Vivid.Infrastructure.Persistence.Configurations
{
  public class BudgetConfiguration : IEntityTypeConfiguration<Budget>
  {
    public void Configure(EntityTypeBuilder<Budget> builder)
    {
      builder.HasKey(b => b.Id);

      // Money Precision (Critical for Financials)
      builder.Property(b => b.TotalAmount)
          .HasPrecision(18, 2);

      builder.Property(b => b.Currency)
          .HasMaxLength(3)
          .IsRequired();

      // 1:1 Relationship: Event -> Budget
      // If Event is deleted, the Budget is deleted.
      builder.HasOne(b => b.Event)
          .WithOne(e => e.Budget)
          .HasForeignKey<Budget>(b => b.EventId)
          .OnDelete(DeleteBehavior.Cascade);
    }
  }
}

// =======================================================
// FILE: src/Infrastructure/Persistence/Configurations/EventConfiguration.cs
// =======================================================
using CRM_Vivid.Core.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CRM_Vivid.Infrastructure.Persistence.Configurations
{
  public class EventConfiguration : IEntityTypeConfiguration<Event>
  {
    public void Configure(EntityTypeBuilder<Event> builder)
    {
      // Set primary key
      builder.HasKey(e => e.Id);

      // Configure propertiess
      builder.Property(e => e.Name)
          .IsRequired()
          .HasMaxLength(256);

      builder.Property(e => e.Status)
          .IsRequired()
          .HasConversion<string>()
          .HasMaxLength(50);

      builder.Property(e => e.Location)
      .HasMaxLength(300);

      builder.Property(e => e.Description)
          .HasMaxLength(500);
      // This configures the navigation property.
      // EF Core will automatically handle the foreign key relationship
      // when we configure the EventContact side.

    }
  }
}

// =======================================================
// FILE: src/Infrastructure/Persistence/Configurations/ExpenseConfiguration.cs
// =======================================================
using CRM_Vivid.Core.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CRM_Vivid.Infrastructure.Persistence.Configurations
{
  public class ExpenseConfiguration : IEntityTypeConfiguration<Expense>
  {
    public void Configure(EntityTypeBuilder<Expense> builder)
    {
      builder.HasKey(e => e.Id);

      builder.Property(e => e.Description)
          .IsRequired()
          .HasMaxLength(200);

      // Money Precision
      builder.Property(e => e.Amount)
          .HasPrecision(18, 2);

      // Relationship: Budget -> Expenses
      builder.HasOne(e => e.Budget)
          .WithMany(b => b.Expenses)
          .HasForeignKey(e => e.BudgetId)
          .OnDelete(DeleteBehavior.Cascade);

      // Relationship: Vendor (Optional)
      // If Vendor is deleted, keep the expense history but null the reference.
      builder.HasOne(e => e.Vendor)
          .WithMany(v => v.Expenses)
          .HasForeignKey(e => e.VendorId)
          .OnDelete(DeleteBehavior.SetNull);

      // Relationship: Document/Invoice (Optional)
      // Documents have 'int' PK.
      builder.HasOne(e => e.LinkedDocument)
          .WithMany()
          .HasForeignKey(e => e.LinkedDocumentId)
          .OnDelete(DeleteBehavior.SetNull);
    }
  }
}

// =======================================================
// FILE: src/Infrastructure/Persistence/Configurations/VendorConfiguraton.cs
// =======================================================
// FILE: src/Infrastructure/Persistence/Configurations/VendorConfiguraton.cs
using CRM_Vivid.Core.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion; // NEW: Required for ValueConverter

namespace CRM_Vivid.Infrastructure.Persistence.Configurations;

public class VendorConfiguration : IEntityTypeConfiguration<Vendor>
{
    public void Configure(EntityTypeBuilder<Vendor> builder)
    {
        builder.HasKey(v => v.Id);
        builder.Property(v => v.Name)
                    .HasMaxLength(200)
                    .IsRequired();
        builder.Property(v => v.PhoneNumber)
                    .HasMaxLength(20);
        builder.Property(v => v.Email)
                    .HasMaxLength(100);

        builder.Property(v => v.ServiceType)
            .HasConversion<string>()
            .HasMaxLength(50);

        // --- PHASE 32 FINAL FIX: Explicit Conversion + ColumnType + Nullability ---
        builder.Property(v => v.Attributes)
            .HasConversion(
                new ValueConverter<string?, string?>(
                    v => v, // C# string to DB string
                    v => v  // DB string back to C# string
                )
            )
            .HasColumnType("jsonb") // CRITICAL: Re-state the column type
            .IsRequired(false); // CRITICAL: Ensure nulls are handled correctly
    }
}

// =======================================================
// FILE: src/Infrastructure/Persistence/Configurations/NoteConfiguration.cs
// =======================================================
using CRM_Vivid.Core.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CRM_Vivid.Infrastructure.Persistence.Configurations;

public class NoteConfiguration : IEntityTypeConfiguration<Note>
{
    public void Configure(EntityTypeBuilder<Note> builder)
    {
        builder.HasKey(n => n.Id);

        builder.Property(n => n.Content)
            .IsRequired()
            .HasMaxLength(2000);

        builder.Property(n => n.CreatedAt)
            .IsRequired();

        // --- FIX: Explicitly map to Contact.Notes ---
        // This removes the ContactId1 shadow property warning.
        builder.HasOne(n => n.Contact)
            .WithMany(c => c.Notes) // <--- FIX: Pointing to the ICollection on Contact
            .HasForeignKey(n => n.ContactId)
            .OnDelete(DeleteBehavior.Cascade);

        // --- Polymorphic Relationships (Preserved) ---
        builder.HasOne(n => n.Event)
            .WithMany() // Since Event.cs doesn't have an ICollection<Note> yet
            .HasForeignKey(n => n.EventId)
            .OnDelete(DeleteBehavior.Cascade);

        builder.HasOne(n => n.Task)
            .WithMany()
            .HasForeignKey(n => n.TaskId)
            .OnDelete(DeleteBehavior.Cascade);

        builder.HasOne(n => n.Vendor)
            .WithMany()
            .HasForeignKey(n => n.VendorId)
            .OnDelete(DeleteBehavior.Cascade);
    }
}

// =======================================================
// FILE: src/Infrastructure/Persistence/Configurations/DocumentConfiguration.cs
// =======================================================
using CRM_Vivid.Core.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CRM_Vivid.Infrastructure.Persistence.Configurations
{
  public class DocumentConfiguration : IEntityTypeConfiguration<Document>
  {
    public void Configure(EntityTypeBuilder<Document> builder)
    {
      builder.HasKey(t => t.Id);

      builder.Property(t => t.FileName)
          .HasMaxLength(255)
          .IsRequired();

      builder.Property(t => t.StoredFileName)
          .HasMaxLength(255)
          .IsRequired();

      builder.Property(t => t.ContentType)
          .HasMaxLength(100)
          .IsRequired();

      builder.Property(t => t.RelatedEntityType)
          .HasMaxLength(50)
          .IsRequired();

      builder.HasIndex(t => new { t.RelatedEntityId, t.RelatedEntityType });
    }
  }
}

// =======================================================
// FILE: src/Infrastructure/Persistence/Configurations/TaskConfiguration.cs
// =======================================================
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace CRM_Vivid.Infrastructure.Persistence.Configurations
{
    public class TaskConfiguration : IEntityTypeConfiguration<Core.Entities.Task>
    {
        public void Configure(EntityTypeBuilder<Core.Entities.Task> builder)
        {
            builder.HasKey(t => t.Id);

            builder.Property(t => t.Title)
                .IsRequired()
                .HasMaxLength(200);

            builder.Property(t => t.Description)
                .HasMaxLength(5000);

            // Configure Enum to string conversion for the database
            builder.Property(t => t.Status)
                .HasConversion(
                    v => v.ToString(),
                    v => Enum.Parse<Core.Enum.TaskStatus>(v));

            builder.Property(t => t.Priority)
                .HasConversion(
                    v => v.ToString(),
                    v => Enum.Parse<Core.Enum.TaskPriority>(v));

            // FIX: Explicitly map relationship to Contact.Tasks
            builder.HasOne(t => t.Contact)
                .WithMany(c => c.Tasks) // <--- FIX: Pointing to the ICollection on Contact
                .HasForeignKey(t => t.ContactId)
                .OnDelete(DeleteBehavior.SetNull)
                .IsRequired(false);

            // Configure optional relationship with Event (Preserved)
            builder.HasOne(t => t.Event)
                .WithMany()
                .HasForeignKey(t => t.EventId)
                .OnDelete(DeleteBehavior.SetNull)
                .IsRequired(false);
        }
    }
}

// =======================================================
// FILE: src/Infrastructure/Persistence/ApplicationDbContextFactory.cs
// =======================================================
// FILE: src/Infrastructure/Persistence/ApplicationDbContextFactory.cs (FINAL, BUILD-SAFE VERSION)
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Design;
using Microsoft.Extensions.Configuration;

// No using CRM_Vivid.Api; needed here!

namespace CRM_Vivid.Infrastructure.Persistence;

public class ApplicationDbContextFactory : IDesignTimeDbContextFactory<ApplicationDbContext>
{
  // WARNING: In a real environment, you must manually set the "UserSecretsId" in 
  // the Api project's .csproj file to match this string if the secrets were not 
  // generated automatically.
  private const string ApiUserSecretsId = "crm-vivid-api-secrets";

  public ApplicationDbContext CreateDbContext(string[] args)
  {
    var apiProjectPath = Path.Combine(Directory.GetCurrentDirectory(), "..", "Api");

    IConfigurationRoot configuration = new ConfigurationBuilder()
        .SetBasePath(apiProjectPath)
        .AddJsonFile("appsettings.json", optional: false)
        .AddJsonFile("appsettings.Development.json", optional: true)
        .AddEnvironmentVariables()
        // CRITICAL FIX: Use AddUserSecrets(assemblyName) method, passing the 
        // secrets ID string directly. This avoids the need for the marker class.
        .AddUserSecrets(ApiUserSecretsId)
        .Build();

    var builder = new DbContextOptionsBuilder<ApplicationDbContext>();

    var connectionString = configuration.GetConnectionString("DefaultConnection");

    if (string.IsNullOrEmpty(connectionString))
    {
      throw new InvalidOperationException("Connection string 'DefaultConnection' not found. Ensure it is set in appsettings.json or user secrets.");
    }

    builder.UseNpgsql(
        connectionString,
        b => b.MigrationsAssembly(typeof(ApplicationDbContext).Assembly.FullName));

    return new ApplicationDbContext(builder.Options);
  }
}

// =======================================================
// FILE: src/Infrastructure/Persistence/ApplicationDbContext.cs
// =======================================================
using CRM_Vivid.Core.Entities;
using Microsoft.EntityFrameworkCore;
using CRM_Vivid.Application.Common.Interfaces;

namespace CRM_Vivid.Infrastructure.Persistence;

public class ApplicationDbContext : DbContext, IApplicationDbContext
{
  private readonly ICurrentUserService? _currentUserService;
  public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options, ICurrentUserService? currentUserService = null)
      : base(options)
  {
    _currentUserService = currentUserService;
  }

  public DbSet<Contact> Contacts { get; set; }
  public DbSet<Event> Events { get; set; }
  public DbSet<EventContact> EventContacts => Set<EventContact>();
  public DbSet<Note> Notes { get; set; } = null!;
  public DbSet<Core.Entities.Task> Tasks { get; set; }
  public DbSet<Vendor> Vendors { get; set; } = null!;
  public DbSet<Template> Templates { get; set; } = null!;
  public DbSet<EventVendor> EventVendors { get; set; } = null!;
  public DbSet<EmailLog> EmailLogs { get; set; } = null!;
  public DbSet<Document> Documents { get; set; }

  // --- NEW: The Ledger ---
  public DbSet<Budget> Budgets { get; set; }
  public DbSet<Expense> Expenses { get; set; }

  protected override void OnModelCreating(ModelBuilder modelBuilder)
  {
    modelBuilder.ApplyConfigurationsFromAssembly(typeof(ApplicationDbContext).Assembly);

    if (_currentUserService != null) // Only apply filter if service is present
    {
      var scopedEntityTypes = modelBuilder.Model.GetEntityTypes()
          .Where(e => e.ClrType.GetInterfaces().Contains(typeof(IUserScopedEntity)));

      foreach (var entityType in scopedEntityTypes)
      {
        var parameter = System.Linq.Expressions.Expression.Parameter(entityType.ClrType, "entity");

        var filter = System.Linq.Expressions.Expression.Lambda(
            System.Linq.Expressions.Expression.Equal(
                System.Linq.Expressions.Expression.Property(parameter, nameof(IUserScopedEntity.CreatedByUserId)),
                System.Linq.Expressions.Expression.Constant(_currentUserService.CurrentUserId)
            ),
            parameter
        );
        modelBuilder.Entity(entityType.ClrType).HasQueryFilter(filter);
      }
    }

    base.OnModelCreating(modelBuilder);
  }
}

// =======================================================
// FILE: src/Infrastructure/Services/TemplateMerger.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using System.Text;

namespace CRM_Vivid.Infrastructure.Services;

public class TemplateMerger : ITemplateMerger
{
  public string Merge(string templateContent, Dictionary<string, string> placeholders)
  {
    if (string.IsNullOrWhiteSpace(templateContent) || placeholders == null || placeholders.Count == 0)
    {
      return templateContent ?? string.Empty;
    }

    var sb = new StringBuilder(templateContent);

    foreach (var kvp in placeholders)
    {
      var key = kvp.Key;
      var value = kvp.Value ?? string.Empty;

      // Support {{Key}} (Standard Mustache/Handlebars style)
      sb.Replace($"{{{{{key}}}}}", value);

      // Support {Key} (Legacy style)
      sb.Replace($"{{{key}}}", value);
    }

    return sb.ToString();
  }
}

// =======================================================
// FILE: src/Infrastructure/Services/HangfireJobService.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using Hangfire;
using System.Linq.Expressions;

namespace CRM_Vivid.Infrastructure.Services;

public class HangfireJobService : IBackgroundJobService
{
  public string Schedule(Expression<System.Action> methodCall, DateTimeOffset enqueueAt)
  {
    // Hangfire implementation for delayed job
    return BackgroundJob.Schedule(methodCall, enqueueAt);
  }

  public string Enqueue(Expression<System.Action> methodCall)
  {
    // Hangfire implementation for immediate, reliable job
    return BackgroundJob.Enqueue(methodCall);
  }
}

// =======================================================
// FILE: src/Infrastructure/Services/LocalFileStorageService.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using Microsoft.AspNetCore.Hosting;

namespace CRM_Vivid.Infrastructure.Services
{
  public class LocalFileStorageService : IFileStorageService
  {
    private readonly IWebHostEnvironment _environment;
    private readonly string _uploadsFolder;

    public LocalFileStorageService(IWebHostEnvironment environment)
    {
      _environment = environment;

      // FIX: WebRootPath is null if wwwroot doesn't exist or isn't configured.
      // We fallback to combining ContentRootPath (project root) with "wwwroot".
      var webRoot = _environment.WebRootPath ?? Path.Combine(_environment.ContentRootPath, "wwwroot");

      _uploadsFolder = Path.Combine(webRoot, "uploads");

      // Ensure the directory hierarchy exists
      if (!Directory.Exists(_uploadsFolder))
      {
        Directory.CreateDirectory(_uploadsFolder);
      }
    }

    public async Task<string> UploadAsync(Stream fileStream, string fileName)
    {
      var extension = Path.GetExtension(fileName);
      var uniqueFileName = $"{Guid.NewGuid()}{extension}";
      var filePath = Path.Combine(_uploadsFolder, uniqueFileName);

      using (var targetStream = new FileStream(filePath, FileMode.Create))
      {
        await fileStream.CopyToAsync(targetStream);
      }

      return uniqueFileName;
    }

    public Task DeleteAsync(string storedFileName)
    {
      var filePath = Path.Combine(_uploadsFolder, storedFileName);
      if (File.Exists(filePath))
      {
        File.Delete(filePath);
      }
      return Task.CompletedTask;
    }

    public string GetFileUrl(string storedFileName)
    {
      return $"/uploads/{storedFileName}";
    }
  }
}

// =======================================================
// FILE: src/Infrastructure/Services/SendGridEmailSender.cs
// =======================================================
// FILE: src/Infrastructure/Services/SendGridEmailSender.cs

using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Entities; // For EmailLog
using Microsoft.EntityFrameworkCore; // For querying Contacts
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using SendGrid;
using SendGrid.Helpers.Mail;
using Task = System.Threading.Tasks.Task;

namespace CRM_Vivid.Infrastructure.Services;

public class SendGridEmailSender : IEmailSender
{
  private readonly IConfiguration _configuration;
  private readonly ILogger<SendGridEmailSender> _logger;
  private readonly IApplicationDbContext _context;

  public SendGridEmailSender(
      IConfiguration configuration,
      ILogger<SendGridEmailSender> logger,
      IApplicationDbContext context)
  {
    _configuration = configuration;
    _logger = logger;
    _context = context;
  }

  // --- FIX: IMPLEMENT INTERFACE METHOD WITH ALL NEW OPTIONAL PARAMETERS ---
  public async Task SendEmailAsync(
      string email,
      string subject,
      string htmlMessage,
      Guid? templateId = null, // NEW: Added optional parameter
      Guid? eventId = null)    // NEW: Added optional parameter
  {
    var apiKey = _configuration["SendGrid:ApiKey"];

    // 1. Prepare the Log Entry
    var emailLog = new EmailLog
    {
      Id = Guid.NewGuid(),
      To = email,
      Subject = subject,
      Body = htmlMessage,
      SentAt = DateTime.UtcNow,
      IsSuccess = false, // Default to false until proven otherwise

      // --- PHASE 38 FIX: ASSIGN TEMPLATE AND EVENT CONTEXT ---
      TemplateId = templateId,
      EventId = eventId
      // --------------------------------------------------------
    };

    // 2. Try to link to a Contact
    try
    {
      var contact = await _context.Contacts
          .FirstOrDefaultAsync(c => c.Email == email);

      if (contact != null)
      {
        emailLog.ContactId = contact.Id;
      }
    }
    catch (Exception ex)
    {
      _logger.LogWarning(ex, "Failed to resolve Contact ID for email logging.");
    }

    // 3. Validation Check
    if (string.IsNullOrEmpty(apiKey))
    {
      var error = "SendGrid API Key is missing.";
      _logger.LogWarning("{Error} Email to {Email} was not sent.", error, email);

      emailLog.ErrorMessage = error;
      _context.EmailLogs.Add(emailLog);
      await _context.SaveChangesAsync(CancellationToken.None);
      return;
    }

    // 4. Attempt Send
    try
    {
      var client = new SendGridClient(apiKey);
      var fromEmail = _configuration["SendGrid:FromEmail"] ?? "noreply@crmvivid.com";
      var fromName = _configuration["SendGrid:FromName"] ?? "CRM Vivid";

      var from = new EmailAddress(fromEmail, fromName);
      var to = new EmailAddress(email);
      var msg = MailHelper.CreateSingleEmail(from, to, subject, htmlMessage, htmlMessage);

      var response = await client.SendEmailAsync(msg);

      if (response.IsSuccessStatusCode)
      {
        _logger.LogInformation("Email successfully queued/sent to {Email} via SendGrid.", email);
        emailLog.IsSuccess = true;
      }
      else
      {
        var errorMsg = $"SendGrid Error: {response.StatusCode}";
        _logger.LogError("Failed to send email to {Email}. {Status}", email, errorMsg);
        emailLog.ErrorMessage = errorMsg;
        emailLog.IsSuccess = false;
      }
    }
    catch (Exception ex)
    {
      _logger.LogError(ex, "Exception while sending email to {Email}", email);
      emailLog.ErrorMessage = ex.Message;
      emailLog.IsSuccess = false;

      // We rethrow if we want Hangfire to retry, 
      // BUT we must save the log first or we lose the record of the attempt.
    }

    // 5. Save Log
    _context.EmailLogs.Add(emailLog);
    await _context.SaveChangesAsync(CancellationToken.None);
  }
}

// =======================================================
// FILE: src/Infrastructure/Services/CurrentUserService.cs
// =======================================================
// FILE: src/Infrastructure/Services/CurrentUserService.cs (NEW FILE)
// Placeholder implementation
using CRM_Vivid.Application.Common.Interfaces;
using Microsoft.AspNetCore.Http;

namespace CRM_Vivid.Infrastructure.Services;

public class CurrentUserService : ICurrentUserService
{
  // NOTE: This implementation relies on HttpContext and Authentication Middleware (Clerk).
  // For now, we return a simple mock GUID for compilation.
  private readonly IHttpContextAccessor _httpContextAccessor;

  public CurrentUserService(IHttpContextAccessor httpContextAccessor)
  {
    _httpContextAccessor = httpContextAccessor;
  }

  public Guid CurrentUserId
  {
    get
    {
      // In a live app, this would extract the UserId from ClaimsPrincipal:
      // var userIdClaim = _httpContextAccessor.HttpContext?.User.FindFirst("user_id");
      // if (userIdClaim != null && Guid.TryParse(userIdClaim.Value, out var id)) return id;

      // For now, return a fixed GUID to enable the Global Filter to function
      // (You must ensure this ID matches a user ID when testing)
      return new Guid("11111111-2222-3333-4444-555555555555");
    }
  }

  public bool IsAuthenticated => true; // Assume authenticated for [Authorize] paths
}

// =======================================================
// FILE: src/Infrastructure/Services/ContractGenerator.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using CRM_Vivid.Core.Entities;
using QuestPDF.Fluent;
using QuestPDF.Helpers;
using QuestPDF.Infrastructure;
using Microsoft.EntityFrameworkCore;

// --- Entity Aliases ---
using Document = QuestPDF.Fluent.Document;

namespace CRM_Vivid.Infrastructure.Services;

public class ContractGenerator : IContractGenerator
{
  private readonly IApplicationDbContext _context;

  public ContractGenerator(IApplicationDbContext context)
  {
    _context = context;
  }

  // Task signature assumed to be clean now, relying on user's fix
  public System.Threading.Tasks.Task<byte[]> GenerateContractAsync(Guid eventId)
  {
    // 1. Fetch Composite Data (Simulating Run of Show Data Fetch)
    var eventEntity = _context.Events
        .Include(e => e.EventVendors)
        .ThenInclude(ev => ev.Vendor)
        .FirstOrDefault(e => e.Id == eventId);

    if (eventEntity == null)
    {
      throw new Exception($"Event with ID {eventId} not found for contract generation.");
    }

    var primaryVendor = eventEntity.EventVendors.FirstOrDefault()?.Vendor ?? new Vendor { Name = "TBD Vendor" };

    // 2. Define the Document Structure
    var document = Document.Create(container =>
    {
      container.Page(page =>
          {
            page.Margin(50);
            page.Size(PageSizes.A4);

            page.Header().Element(header => CreateHeader(header, eventEntity));

            page.Content().Column(column =>
                {
                  column.Spacing(25);

                  // --- PAGE 1: Contact/Run of Show Summary ---
                  column.Item().Text("SECTION 1: EVENT AND PARTNER SUMMARY").Style(Styles.H1);
                  column.Item().Element(content => CreateRunOfShowSummary(content, eventEntity, primaryVendor));

                  column.Item().PageBreak();

                  // --- PAGE 2: LCD ENTERTAINMENT POLICIES ---
                  column.Item().Text("SECTION 2: LCD ENTERTAINMENT POLICIES").Style(Styles.H1);
                  column.Item().Element(content => CreatePolicySection(content, "VIVID/LCD General Policies", "Here lie the policies regarding payment terms, cancellation, insurance, and compliance with local ordinances.", Colors.Red.Medium)); // Call to policy section


                  column.Item().PageBreak();

                  // --- PAGE 3: Venue/Vendor Specific Policies ---
                  column.Item().Text($"SECTION 3: {primaryVendor.Name.ToUpper()} POLICIES").Style(Styles.H1);
                  column.Item().Element(content => CreatePolicySection(content, "External Vendor Policies", "This section contains venue-specific riders, load-in/out schedules, and technical requirements provided by the vendor.", Colors.Blue.Medium)); // Call to policy section


                  column.Item().PageBreak();

                  // --- LAST PAGE: Signature Blocks ---
                  column.Item().Text("SECTION 4: EXECUTION AND AGREEMENT").Style(Styles.H1);
                  column.Item().Element(content => CreateSignatureBlock(content, eventEntity, primaryVendor));
                });

            // Reusable Footer
            page.Footer().Text(x =>
                {
                  x.CurrentPageNumber().FontSize(10).SemiBold();
                  x.Span(" / ").FontSize(10).SemiBold();
                  x.TotalPages().FontSize(10).SemiBold();
                });
          });
    });

    // 3. Generate the document bytes
    byte[] pdfBytes = document.GeneratePdf();

    return System.Threading.Tasks.Task.FromResult(pdfBytes);
  }

  // --- PRIVATE COMPONENT CREATORS ---

  private static class Styles
  {
    public static TextStyle H1 => TextStyle.Default.FontSize(14).SemiBold().FontColor(Colors.Grey.Darken3).Underline();
    public static TextStyle H2 => TextStyle.Default.FontSize(12).SemiBold().FontColor(Colors.Grey.Darken2);
    public static TextStyle Label => TextStyle.Default.FontSize(10).SemiBold().FontColor(Colors.Grey.Medium);
    public static TextStyle Value => TextStyle.Default.FontSize(11).FontColor(Colors.Black);
  }

  private static void CreateHeader(IContainer container, Event eventEntity)
  {
    container.Row(row =>
    {
      row.RelativeItem().Column(col =>
          {
            col.Item().Text("LCD ENTERTAINMENT").Style(Styles.H1);
            col.Item().Text("VIVID EVENT CONTRACT").Style(Styles.H2);
            col.Item().Text($"Draft Date: {DateTime.Now:MMMM dd, yyyy}").Style(Styles.Label);
          });

      row.ConstantItem(100).AlignRight().Text("VIVID").SemiBold().FontSize(30).FontColor(Colors.Red.Medium);
    });
  }

  private static void CreateRunOfShowSummary(IContainer container, Event eventEntity, Vendor primaryVendor)
  {
    container.Column(col =>
    {
      // Event Details
      col.Item().Text("1. EVENT OVERVIEW").Style(Styles.H2);
      col.Item().Table(table =>
          {
            table.ColumnsDefinition(columns =>
                {
                  columns.RelativeColumn(1);
                  columns.RelativeColumn(2);
                });

            // Using Element(container => ...) delegate to correctly wrap table cell content.
            table.Cell().Element(container => container.PaddingVertical(5).PaddingHorizontal(5).Column(col => { col.Item().Text("Event Name:").Style(Styles.Label); }));
            table.Cell().Element(container => container.PaddingVertical(5).PaddingHorizontal(5).Column(col => { col.Item().Text(eventEntity.Name).Style(Styles.Value); }));

            table.Cell().Element(container => container.PaddingVertical(5).PaddingHorizontal(5).Column(col => { col.Item().Text("Start Date/Time:").Style(Styles.Label); }));
            table.Cell().Element(container => container.PaddingVertical(5).PaddingHorizontal(5).Column(col => { col.Item().Text($"{eventEntity.StartDateTime:MM/dd/yyyy h:mm tt}").Style(Styles.Value); }));

            table.Cell().Element(container => container.PaddingVertical(5).PaddingHorizontal(5).Column(col => { col.Item().Text("Venue/Location:").Style(Styles.Label); }));
            table.Cell().Element(container => container.PaddingVertical(5).PaddingHorizontal(5).Column(col => { col.Item().Text(eventEntity.Location ?? "To Be Determined").Style(Styles.Value); }));

            table.Cell().Element(container => container.PaddingVertical(5).PaddingHorizontal(5).Column(col => { col.Item().Text("Primary Partner:").Style(Styles.Label); }));
            table.Cell().Element(container => container.PaddingVertical(5).PaddingHorizontal(5).Column(col => { col.Item().Text(primaryVendor.Name).Style(Styles.Value); }));

            table.Cell().Element(container => container.PaddingVertical(5).PaddingHorizontal(5).Column(col => { col.Item().Text("Timeline Status:").Style(Styles.Label); }));
            table.Cell().Element(container => container.PaddingVertical(5).PaddingHorizontal(5).Column(col => { col.Item().Text("AGREED (Latest Version)").Style(Styles.Value.FontColor(Colors.Green.Darken2)); }));
          });
    });
  }

  private static void CreatePolicySection(IContainer container, string title, string content, string color)
  {
    container.Column(col =>
    {
      col.Item().Text($"1. {title}").Style(Styles.H2);

      // FIX: Separate BorderLeft and BorderColor to resolve Argument 3 error
      col.Item().PaddingTop(5).BorderLeft(1).BorderColor(color).PaddingLeft(10)
              .Text(content).Style(Styles.Value);

      col.Item().PaddingTop(15).Text("--- FULL POLICY TEXT GOES HERE ---").Style(Styles.Label.FontSize(9));
      col.Item().Text(Placeholders.LoremIpsum()).Style(Styles.Value.FontSize(9));
    });
  }

  private static void CreateSignatureBlock(IContainer container, Event eventEntity, Vendor primaryVendor)
  {
    container.PaddingTop(50).Column(col =>
    {
      col.Item().Text("AGREED & ACCEPTED").Style(Styles.H2.Underline());
      col.Item().PaddingVertical(20).Text("By signing below, all parties confirm agreement with the Timeline and Policies attached.").Style(Styles.Value.FontSize(10));

      col.Item().Row(row =>
          {
            // Signer 1: LCD/VIVID
            row.RelativeItem().Column(c =>
                {
                  c.Item().BorderBottom(1).PaddingBottom(5).Text(" ").Style(Styles.Value);
                  c.Item().PaddingTop(5).Text("For LCD Entertainment / VIVID (Authorized Signer)").Style(Styles.Label);
                  c.Item().Text($"Signature Date: {DateTime.Now:MM/dd/yyyy}").Style(Styles.Label);
                });

            row.ConstantItem(50); // Spacer

            // Signer 2: Partner/Vendor
            row.RelativeItem().Column(c =>
                {
                  c.Item().BorderBottom(1).PaddingBottom(5).Text(" ").Style(Styles.Value);
                  c.Item().PaddingTop(5).Text($"For {primaryVendor.Name} (Authorized Signer)").Style(Styles.Label);
                  c.Item().Text($"Signature Date: {DateTime.Now:MM/dd/yyyy}").Style(Styles.Label);
                });
          });
    });
  }
}

// =======================================================
// FILE: src/Infrastructure/Services/MockEmailSender.cs
// =======================================================
// FILE: src/Infrastructure/Services/MockEmailSender.cs (MODIFIED)
using CRM_Vivid.Application.Common.Interfaces;
using Microsoft.Extensions.Logging;
using System; // Required for Guid
using Task = System.Threading.Tasks.Task;

namespace CRM_Vivid.Infrastructure.Services;

public class MockEmailSender : IEmailSender
{
  private readonly ILogger<MockEmailSender> _logger;

  public MockEmailSender(ILogger<MockEmailSender> logger)
  {
    _logger = logger;
  }

  // --- FIX: Implement the full interface signature (Phase 38) ---
  public Task SendEmailAsync(
      string to,
      string subject,
      string body,
      Guid? templateId = null, // NEW: Added optional parameter
      Guid? eventId = null)    // NEW: Added optional parameter
  {
    _logger.LogInformation("--------------------------------------------------");
    _logger.LogInformation("--> [MOCK EMAIL SENDER] Triggered");
    _logger.LogInformation($"--> To: {to}");
    _logger.LogInformation($"--> Subject: {subject}");
    _logger.LogInformation($"--> Body: {body}");

    // Log the new context for auditing purposes
    if (templateId.HasValue)
    {
      _logger.LogInformation($"--> Template ID: {templateId}");
    }
    if (eventId.HasValue)
    {
      _logger.LogInformation($"--> Event ID: {eventId}");
    }

    _logger.LogInformation("--------------------------------------------------");

    return Task.CompletedTask;
  }
}

// =======================================================
// FILE: src/Infrastructure/Services/TwilioTelephonyService.cs
// =======================================================
using CRM_Vivid.Application.Common.Interfaces;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Twilio;
using Twilio.Rest.Api.V2010.Account;

namespace CRM_Vivid.Infrastructure.Services;

public class TwilioTelephonyService : ITelephonyService
{
  private readonly IConfiguration _configuration;
  private readonly ILogger<TwilioTelephonyService> _logger;
  private readonly string _accountSid;
  private readonly string _authToken;
  private readonly string _twilioPhoneNumber;

  public TwilioTelephonyService(IConfiguration configuration, ILogger<TwilioTelephonyService> logger)
  {
    _configuration = configuration;
    _logger = logger;

    // Load credentials from configuration
    _accountSid = _configuration["Twilio:AccountSid"] ??
                  throw new ArgumentNullException("Twilio:AccountSid is missing.");
    _authToken = _configuration["Twilio:AuthToken"] ??
                 throw new ArgumentNullException("Twilio:AuthToken is missing.");
    _twilioPhoneNumber = _configuration["Twilio:PhoneNumber"] ??
                         throw new ArgumentNullException("Twilio:PhoneNumber is missing.");

    // Initialize the Twilio client once per service instance
    TwilioClient.Init(_accountSid, _authToken);
  }

  private async Task<bool> SendMessage(string toPhoneNumber, string body)
  {
    if (string.IsNullOrWhiteSpace(toPhoneNumber))
    {
      _logger.LogWarning("Skipping SMS send: Recipient phone number is empty.");
      return false;
    }

    try
    {
      var message = await MessageResource.CreateAsync(
          to: new Twilio.Types.PhoneNumber(toPhoneNumber),
          from: new Twilio.Types.PhoneNumber(_twilioPhoneNumber),
          body: body
      );

      if (message.Status == MessageResource.StatusEnum.Queued || message.Status == MessageResource.StatusEnum.Sending)
      {
        _logger.LogInformation("SMS successfully queued via Twilio. SID: {Sid}", message.Sid);
        return true;
      }

      _logger.LogError("Twilio failed to send message. Status: {Status}, Error: {Error}", message.Status, message.ErrorMessage);
      return false;
    }
    catch (Exception ex)
    {
      _logger.LogError(ex, "Exception while sending SMS via Twilio to {Phone}", toPhoneNumber);
      return false;
    }
  }

  public Task<bool> SendSmsAsync(string toPhoneNumber, string body)
  {
    return SendMessage(toPhoneNumber, body);
  }

  public Task<bool> SendCriticalAlertAsync(string toPhoneNumber, string alertMessage)
  {
    // Prepend a critical identifier for easy filtering/logging
    string body = $"[VIVID ALERT] {alertMessage}";
    return SendMessage(toPhoneNumber, body);
  }
}