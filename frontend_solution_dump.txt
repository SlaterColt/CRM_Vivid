

// =======================================================
// FILE: frontend_harness/src/App.tsx
// =======================================================
import {
  SignedIn,
  SignedOut,
  UserButton,
  useAuth,
  RedirectToSignIn,
} from "@clerk/clerk-react";
import { apiClient } from "./apiClient";
import { useEffect, useState } from "react";

import DashboardPage from "./components/DashboardPage"; // NEW IMPORT
import ContactsPage from "./components/ContactsPage";
import EventsPage from "./components/EventsPage";
import TasksPage from "./components/TasksPage";
import VendorsPage from "./components/VendorsPage";
import NotesPage from "./components/NotesPage";
import TemplatesPage from "./components/TemplatesPage";

import { SelectionProvider } from "./context/SelectionProvider";

type PageView =
  | "dashboard" // NEW TYPE
  | "contacts"
  | "events"
  | "tasks"
  | "vendors"
  | "notes"
  | "templates";

function App() {
  const [isApiReady, setIsApiReady] = useState(false);
  // CHANGED: Default to "dashboard"
  const [currentPage, setCurrentPage] = useState<PageView>("dashboard");
  const { getToken } = useAuth();

  useEffect(() => {
    const setupAxiosInterceptor = async () => {
      const interceptorId = apiClient.interceptors.request.use(
        async (config) => {
          const token = await getToken();

          if (token) {
            config.headers.Authorization = `Bearer ${token}`;
          }
          return config;
        },
        (error) => {
          return Promise.reject(error);
        }
      );

      setIsApiReady(true);

      return () => {
        apiClient.interceptors.request.eject(interceptorId);
        setIsApiReady(false);
      };
    };
    setupAxiosInterceptor();
  }, [getToken]);

  const renderPage = () => {
    switch (currentPage) {
      case "dashboard": // NEW CASE
        return <DashboardPage />;
      case "contacts":
        return <ContactsPage />;
      case "events":
        return <EventsPage />;
      case "tasks":
        return <TasksPage />;
      case "vendors":
        return <VendorsPage />;
      case "notes":
        return <NotesPage />;
      case "templates":
        return <TemplatesPage />;
      default:
        return <DashboardPage />;
    }
  };

  return (
    <SelectionProvider>
      <div>
        <header
          style={{
            padding: "1rem",
            display: "flex",
            justifyContent: "flex-end",
            borderBottom: "1px solid #333",
            marginBottom: "1rem",
          }}>
          <SignedIn>
            <UserButton />
          </SignedIn>
        </header>
        <main style={{ padding: "1rem" }}>
          <SignedIn>
            <div
              style={{
                display: "flex",
                alignItems: "center",
                justifyContent: "space-between",
                marginBottom: "1rem",
              }}>
              <h1>CRM_Vivid Command Center</h1>
            </div>

            <nav
              className="harness-nav"
              style={{
                marginBottom: "2rem",
                display: "flex",
                gap: "0.5rem",
                flexWrap: "wrap",
              }}>
              <button
                onClick={() => setCurrentPage("dashboard")}
                disabled={currentPage === "dashboard"}
                style={{
                  fontWeight: currentPage === "dashboard" ? "bold" : "normal",
                }}>
                ðŸ“Š Dashboard
              </button>
              <button
                onClick={() => setCurrentPage("contacts")}
                disabled={currentPage === "contacts"}>
                Contacts
              </button>
              <button
                onClick={() => setCurrentPage("events")}
                disabled={currentPage === "events"}>
                Events
              </button>
              <button
                onClick={() => setCurrentPage("tasks")}
                disabled={currentPage === "tasks"}>
                Tasks
              </button>
              <button
                onClick={() => setCurrentPage("vendors")}
                disabled={currentPage === "vendors"}>
                Vendors
              </button>
              <button
                onClick={() => setCurrentPage("notes")}
                disabled={currentPage === "notes"}>
                Notes
              </button>
              <button
                onClick={() => setCurrentPage("templates")}
                disabled={currentPage === "templates"}>
                Templates
              </button>
            </nav>

            <main className="harness-main">
              {isApiReady ? renderPage() : <p>Initializing API client...</p>}
            </main>
          </SignedIn>

          <SignedOut>
            <RedirectToSignIn />
          </SignedOut>
        </main>
      </div>
    </SelectionProvider>
  );
}

export default App;


// =======================================================
// FILE: frontend_harness/src/main.tsx
// =======================================================
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.tsx";
import "./index.css";
import { ClerkProvider } from "@clerk/clerk-react";

// Import your env variable
const PUBLISHABLE_KEY = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY;

if (!PUBLISHABLE_KEY) {
  throw new Error("Missing Publishable Key");
}

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ClerkProvider publishableKey={PUBLISHABLE_KEY}>
      <App />
    </ClerkProvider>
  </React.StrictMode>
);


// =======================================================
// FILE: frontend_harness/src/context/useSelectionContext.tsx
// =======================================================
import { useContext } from "react";
// Import the raw context from its new, separate file
import { SelectionContext } from "./internalContext";

// This is the only export, and it's a hook.
// This also satisfies the linter.
export const useSelectionContext = () => {
  const context = useContext(SelectionContext);
  if (context === undefined) {
    throw new Error(
      "useSelectionContext must be used within a SelectionProvider"
    );
  }
  return context;
};


// =======================================================
// FILE: frontend_harness/src/context/SelectionProvider.tsx
// =======================================================
// frontend_harness/src/context/SelectionProvider.tsx (FULL FILE - Corrected)
import React, { useState, useMemo } from "react";
import { SelectionContext } from "./internalContext";
import type { Guid } from "../types"; // FIX: Added 'type' keyword (TS1484)

interface SelectionProviderProps {
  children: React.ReactNode;
}

export const SelectionProvider: React.FC<SelectionProviderProps> = ({
  children,
}) => {
  const [selectedContactId, setSelectedContactId] = useState<Guid | null>(null);
  const [selectedEventId, setSelectedEventId] = useState<Guid | null>(null);
  // NEW: State for selected vendor
  const [selectedVendorId, setSelectedVendorId] = useState<Guid | null>(null);

  const contextValue = useMemo(
    () => ({
      selectedContactId,
      setSelectedContactId,
      selectedEventId,
      setSelectedEventId,
      selectedVendorId, // NEW: Include in context value
      setSelectedVendorId, // NEW: Include in context value
    }),
    [selectedContactId, selectedEventId, selectedVendorId]
  ); // NEW: Include in dependency array

  return (
    <SelectionContext.Provider value={contextValue}>
      {children}
    </SelectionContext.Provider>
  );
};


// =======================================================
// FILE: frontend_harness/src/context/internalContext.tsx
// =======================================================
// frontend_harness/src/context/internalContext.tsx
import { createContext } from "react";

// Define the shape of the context state
export interface SelectionContextType {
  selectedContactId: string | null;
  setSelectedContactId: (id: string | null) => void;
  selectedEventId: string | null;
  setSelectedEventId: (id: string | null) => void;
  // NEW: Vendor selection properties
  selectedVendorId: string | null;
  setSelectedVendorId: (id: string | null) => void;
}

// Create the context with an initial undefined value
export const SelectionContext = createContext<SelectionContextType | undefined>(
  undefined
);


// =======================================================
// FILE: frontend_harness/src/types.ts
// =======================================================
// =======================================================
// FILE: frontend_harness/src/types.ts
// =======================================================

// --- ENUMS REPLACED WITH CONST OBJECTS (Erasable Syntax Compliant) ---

export const VendorType = {
  Catering: "Catering",
  Venue: "Venue",
  Security: "Security",
  Entertainment: "Entertainment",
  Florist: "Florist",
  Photography: "Photography",
  Videography: "Videography",
  Other: "Other"
} as const;
export type VendorType = typeof VendorType[keyof typeof VendorType];

export const LeadStage = {
  NewLead: 0,
  InDiscussion: 1,
  ProposalSent: 2,
  Negotiating: 3,
  Won: 4,
  Lost: 5
} as const;
export type LeadStage = typeof LeadStage[keyof typeof LeadStage];

export const ConnectionStatus = {
  Unknown: 0,
  NeedToMeet: 1,
  MetAlready: 2,
  DoesntNeed: 3,
  NeedAndDoesntHave: 4,
  NeedAndHas: 5,
  HasAndNeedsToMeet: 6
} as const;
export type ConnectionStatus = typeof ConnectionStatus[keyof typeof ConnectionStatus];

export const TaskStatus = {
  NotStarted: "NotStarted",
  InProgress: "InProgress",
  Completed: "Completed",
  Deferred: "Deferred"
} as const;
export type TaskStatus = typeof TaskStatus[keyof typeof TaskStatus];

export const TaskPriority = {
  Low: "Low",
  Medium: "Medium",
  High: "High",
  Urgent: "Urgent"
} as const;
export type TaskPriority = typeof TaskPriority[keyof typeof TaskPriority];

// --- DTOs ---

export interface ContactDto {
  id: string;
  firstName: string;
  lastName: string | null;
  email: string;
  phoneNumber: string | null;
  title: string | null;
  organization: string | null;
  
  // --- NEW: Pipeline Fields (Phase 25) ---
  stage: LeadStage;
  connectionStatus: ConnectionStatus;
  isLead: boolean;
  followUpCount: number;
  lastContactedAt: string | null; // ISO Date
  source: string | null;
}

export interface VendorDto {
  id: string;
  name: string;
  phoneNumber: string | null;
  email: string | null;
  serviceType: VendorType;
  attributes: string | null;
}

export interface EventDto {
  id: string;
  name: string;
  description: string | null;
  startDateTime: string; // ISO 8601 string
  endDateTime: string; // ISO 8601 string
  location: string | null;
  isPublic: boolean;
  status: string; 
}

export interface TaskDto {
  id: string;
  title: string;
  description: string | null;
  status: TaskStatus;
  priority: TaskPriority;
  dueDate: string | null;
  createdAt: string;
  contactId: string | null;
  eventId: string | null;
  vendorId: string | null;
  vendorName: string | null;
  contactEmail?: string;
  eventName?: string;
  vendorNameForLookup?: string;
}

export interface NoteDto {
  id: string;
  content: string;
  createdAt: string;
  updatedAt: string | null;
  contactId: string | null;
  eventId: string | null;
  taskId: string | null;
  vendorId: string | null;
  vendorName: string | null;
  contactEmail?: string;
  eventName?: string;
  vendorNameForLookup?: string;
  taskTitle?: string;
}

export interface TemplateDto {
  id: string;
  name: string;
  subject: string | null;
  content: string;
  type: string;
}

export interface EmailLogDto {
  id: string;
  to: string;
  subject: string;
  sentAt: string;
  isSuccess: boolean;
  errorMessage: string | null;
}

// --- NEW: DASHBOARD DTO (PHASE 31 FIX) ---
export interface DashboardStatsDto {
  totalContacts: number;
  activeEvents: number;
  pendingTasks: number;
  recentEmails: number;
  upcomingEvents: EventDto[]; // Uses the EventDto defined above
}

// --- DOCUMENT & FINANCIALS (Phase 26) ---

export type ContractStatus = 1 | 2 | 3 | 4 | 5;

export const ContractStatusName: Record<ContractStatus, string> = {
    1: "Draft",
    2: "Sent",
    3: "Viewed",
    4: "Signed",
    5: "Voided"
};

export interface Document {
  id: number;
  fileName: string;
  contentType: string;
  size: number;
  uploadedAt: string;
  url: string;
  relatedEntityId: string;
  relatedEntityType: string;
  category: string;
  status: ContractStatus;
  signedAt: string | null;
}

export type ExpenseCategory = 
    | "General" | "Venue" | "Catering" | "Talent" 
    | "Production" | "Marketing" | "Travel" | "Admin" | "Legal";

export interface Expense {
    id: string;
    budgetId: string;
    description: string;
    amount: number;
    dateIncurred: string;
    category: ExpenseCategory;
    vendorId?: string;
    vendorName?: string;
    linkedDocumentId?: number;
    linkedDocumentName?: string;
}

export interface EventFinancials {
    eventId: string;
    eventName: string;
    budgetTotal: number;
    currency: string;
    notes?: string;
    isLocked: boolean;
    expenses: Expense[];
    totalSpent: number;
    remainingBudget: number;
    burnRate: number;
}

// --- COMMANDS ---

export const RecipientType = {
  Contact: 0,
  Vendor: 1
} as const;
export type RecipientType = typeof RecipientType[keyof typeof RecipientType];

export interface SendTemplateEmailCommand {
  eventId: string;
  templateId: string;
  targetEntityId: string;
  recipientType: RecipientType;
}

export interface SubmitLeadCommand {
  firstName: string;
  lastName?: string;
  email: string;
  phoneNumber?: string;
  organization?: string;
  source?: string;
}

// Type aliases for CREATE DTOs
export type CreateContactDto = Omit<ContactDto, 'id'>;
export type CreateEventDto = Omit<EventDto, 'id' | 'createdAt'>;
export type CreateTaskDto = Omit<TaskDto, 'id' | 'createdAt'>;
export type CreateVendorDto = Omit<VendorDto, 'id' | 'createdAt'>;
export type CreateNoteDto = Omit<NoteDto, 'id' | 'createdAt' | 'updatedAt'>;
export type CreateTemplateDto = Omit<TemplateDto, 'id'>;

export type Guid = string;

// =======================================================
// FILE: frontend_harness/src/components/TemplatesPage.tsx
// =======================================================
import { useEffect, useState } from "react";
import { apiClient } from "../apiClient";
import type { TemplateDto, CreateTemplateDto } from "../types"; // FIX: Added 'type' keyword

export default function TemplatesPage() {
  const [templates, setTemplates] = useState<TemplateDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");

  // Form State
  const [formData, setFormData] = useState<CreateTemplateDto>({
    name: "",
    subject: "",
    content: "",
    type: "Email", // Default
  });

  useEffect(() => {
    fetchTemplates();
  }, []);

  const fetchTemplates = async () => {
    try {
      const response = await apiClient.get<TemplateDto[]>("/api/templates");
      setTemplates(response.data);
    } catch (err) {
      console.error(err);
      setError("Failed to load templates.");
    } finally {
      setLoading(false);
    }
  };

  const handleCreate = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await apiClient.post("/api/templates", formData);
      // Reset form
      setFormData({
        name: "",
        subject: "",
        content: "",
        type: "Email",
      });
      fetchTemplates();
    } catch (err) {
      console.error(err);
      alert("Failed to create template.");
    }
  };

  const handleDelete = async (id: string) => {
    if (!confirm("Are you sure you want to delete this template?")) return;
    try {
      await apiClient.delete(`/api/templates/${id}`);
      fetchTemplates();
    } catch (err) {
      console.error(err);
      alert("Failed to delete template.");
    }
  };

  return (
    <div className="p-4">
      <h2 className="text-xl font-bold mb-4">Templates</h2>

      {/* CREATE FORM */}
      <div className="mb-8 p-4 border rounded shadow-sm bg-gray-50">
        <h3 className="font-semibold mb-2">New Template</h3>
        <form onSubmit={handleCreate} className="space-y-3">
          <div>
            <label className="block text-sm font-medium">Name (Internal)</label>
            <input
              className="border p-1 w-full"
              value={formData.name}
              onChange={(e) =>
                setFormData({ ...formData, name: e.target.value })
              }
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium">Type</label>
            <select
              className="border p-1 w-full"
              value={formData.type}
              onChange={(e) =>
                setFormData({ ...formData, type: e.target.value })
              }>
              <option value="Email">Email</option>
              <option value="SMS">SMS</option>
            </select>
          </div>

          {formData.type === "Email" && (
            <div>
              <label className="block text-sm font-medium">Subject Line</label>
              <input
                className="border p-1 w-full"
                value={formData.subject || ""}
                onChange={(e) =>
                  setFormData({ ...formData, subject: e.target.value })
                }
              />
            </div>
          )}

          <div>
            <label className="block text-sm font-medium">Content Body</label>
            <textarea
              className="border p-1 w-full h-24"
              value={formData.content}
              onChange={(e) =>
                setFormData({ ...formData, content: e.target.value })
              }
              required
            />
          </div>

          <button
            type="submit"
            className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">
            Save Template
          </button>
        </form>
      </div>

      {/* LIST */}
      {loading ? (
        <p>Loading...</p>
      ) : error ? (
        <p className="text-red-500">{error}</p>
      ) : (
        <table className="w-full border-collapse border">
          <thead>
            <tr className="bg-gray-100">
              <th className="border p-2 text-left">Name</th>
              <th className="border p-2 text-left">Type</th>
              <th className="border p-2 text-left">Subject</th>
              <th className="border p-2 text-left">Preview</th>
              <th className="border p-2 text-center">Actions</th>
            </tr>
          </thead>
          <tbody>
            {templates.map((t) => (
              <tr key={t.id} className="hover:bg-gray-50">
                <td className="border p-2 font-medium">{t.name}</td>
                <td className="border p-2">
                  <span
                    className={`px-2 py-1 rounded text-xs ${
                      t.type === "Email"
                        ? "bg-blue-100 text-blue-800"
                        : "bg-green-100 text-green-800"
                    }`}>
                    {t.type}
                  </span>
                </td>
                <td className="border p-2 text-gray-600">{t.subject || "â€”"}</td>
                <td className="border p-2 text-gray-500 text-sm">
                  {t.content.substring(0, 50)}
                  {t.content.length > 50 && "..."}
                </td>
                <td className="border p-2 text-center">
                  <button
                    onClick={() => handleDelete(t.id)}
                    className="text-red-600 hover:underline text-sm">
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}


// =======================================================
// FILE: frontend_harness/src/components/FinancialsSection.tsx
// =======================================================
import { useCallback, useEffect, useState } from "react";
import type { EventFinancials, Expense } from "../types";
import { getEventFinancials, addExpense, upsertBudget } from "../apiClient";
import BudgetOverview from "./BudgetOverview";

interface Props {
  eventId: string;
  // NEW PROP: Accepts a key from the parent to force reload
  refreshKey: number;
}

export default function FinancialsSection({ eventId, refreshKey }: Props) {
  const [financials, setFinancials] = useState<EventFinancials | null>(null);
  const [loading, setLoading] = useState(true);

  // Form State
  const [showAddExpense, setShowAddExpense] = useState(false);
  const [newExpense, setNewExpense] = useState({
    description: "",
    amount: 0,
    category: "General",
    dateIncurred: new Date().toISOString().split("T")[0],
  });

  // Renamed loadData to fetchFinancials for clarity
  const fetchFinancials = useCallback(async () => {
    try {
      setLoading(true);
      const data = await getEventFinancials(eventId);
      setFinancials(data);
    } catch (error) {
      console.error("Failed to load financials", error);
    } finally {
      setLoading(false);
    }
  }, [eventId]); // Dependency: Only changes if the eventId itself changes

  // FIX: Reruns fetchFinancials whenever eventId OR refreshKey changes
  // The 'refreshKey' forces a re-render/re-fetch whenever the parent updates the key.
  useEffect(() => {
    fetchFinancials();
  }, [fetchFinancials, refreshKey]); // Added refreshKey as a direct trigger

  const handleCreateBudget = async () => {
    const amountStr = prompt("Enter Total Budget Amount:", "10000");
    if (!amountStr) return;
    await upsertBudget(eventId, parseFloat(amountStr), "USD", "Initial Budget");
    fetchFinancials();
  };

  const handleSubmitExpense = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newExpense.amount || !newExpense.description) return;

    await addExpense(
      eventId,
      newExpense.description,
      newExpense.amount,
      new Date(newExpense.dateIncurred).toISOString(),
      newExpense.category
    );

    setShowAddExpense(false);
    setNewExpense({
      description: "",
      amount: 0,
      category: "General",
      dateIncurred: new Date().toISOString().split("T")[0],
    });
    fetchFinancials();
  };

  if (loading)
    return (
      <div className="p-8 text-center text-gray-400">Calculating Ledger...</div>
    );

  // Scenario 1: No Budget Exists
  if (
    !financials ||
    (financials.budgetTotal === 0 && financials.expenses.length === 0)
  ) {
    return (
      <div className="text-center p-12 bg-[#333] rounded-xl border border-dashed border-gray-600 mb-8">
        <h3 className="text-lg font-medium text-white">No Budget Set</h3>
        <p className="mt-1 text-gray-400">
          Initialize a budget to start tracking expenses.
        </p>
        <button
          onClick={handleCreateBudget}
          className="mt-4 px-6 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition-colors">
          Create Budget
        </button>
      </div>
    );
  }

  return (
    <div className="space-y-8">
      <BudgetOverview data={financials} onEditBudget={handleCreateBudget} />

      <div className="flex justify-between items-center mb-4">
        <h3 className="text-xl font-bold text-white">Expenses</h3>
        <button
          onClick={() => setShowAddExpense(!showAddExpense)}
          className="px-4 py-2 bg-indigo-600 text-white rounded-md text-sm hover:bg-indigo-700 font-medium transition-colors">
          {showAddExpense ? "Cancel" : "+ Add Expense"}
        </button>
      </div>

      {showAddExpense && (
        <form
          onSubmit={handleSubmitExpense}
          className="bg-[#444] p-6 rounded-lg mb-6 border border-gray-600 grid grid-cols-1 md:grid-cols-4 gap-4 items-end">
          <div className="md:col-span-2">
            <label className="block text-xs font-medium text-gray-300 mb-1">
              Description
            </label>
            <input
              type="text"
              value={newExpense.description}
              onChange={(e) =>
                setNewExpense({ ...newExpense, description: e.target.value })
              }
              className="w-full rounded bg-[#333] border-gray-600 text-white p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500"
              required
            />
          </div>
          <div>
            <label className="block text-xs font-medium text-gray-300 mb-1">
              Amount ($)
            </label>
            <input
              type="number"
              value={newExpense.amount}
              onChange={(e) =>
                setNewExpense({
                  ...newExpense,
                  amount: parseFloat(e.target.value),
                })
              }
              className="w-full rounded bg-[#333] border-gray-600 text-white p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500"
              required
            />
          </div>
          <div>
            <label className="block text-xs font-medium text-gray-300 mb-1">
              Category
            </label>
            <select
              value={newExpense.category}
              onChange={(e) =>
                setNewExpense({ ...newExpense, category: e.target.value })
              }
              className="w-full rounded bg-[#333] border-gray-600 text-white p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500">
              {[
                "General",
                "Venue",
                "Catering",
                "Talent",
                "Production",
                "Marketing",
              ].map((c) => (
                <option key={c} value={c}>
                  {c}
                </option>
              ))}
            </select>
          </div>
          <button
            type="submit"
            className="bg-emerald-600 text-white py-2 px-4 rounded hover:bg-emerald-700 font-medium">
            Save
          </button>
        </form>
      )}

      <div className="bg-[#333] border border-gray-600 rounded-lg overflow-hidden shadow-md">
        <table className="table-fixed w-full text-left">
          <thead className="bg-[#222] text-gray-300 uppercase text-xs tracking-wider border-b border-gray-600">
            <tr>
              <th className="px-6 py-4 w-[15%]">Date</th>
              <th className="px-6 py-4 w-[35%]">Description</th>
              <th className="px-6 py-4 w-[15%]">Category</th>
              <th className="px-6 py-4 w-[15%]">Vendor</th>
              <th className="px-6 py-4 w-[20%] text-right">Amount</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-700">
            {financials.expenses.map((expense: Expense) => (
              <tr
                key={expense.id}
                className="hover:bg-[#383838] transition-colors">
                <td className="px-6 py-4 text-sm text-gray-300">
                  {new Date(expense.dateIncurred).toLocaleDateString()}
                </td>
                <td className="px-6 py-4 text-sm font-medium text-white">
                  {expense.description}
                  {expense.linkedDocumentName && (
                    <span className="ml-2 px-2 py-0.5 bg-blue-900 text-blue-200 text-xs rounded-full border border-blue-700">
                      Invoice
                    </span>
                  )}
                </td>
                <td className="px-6 py-4 text-sm text-gray-300">
                  <span className="px-2 py-1 text-xs font-semibold rounded-full bg-[#444] text-gray-200 border border-gray-600">
                    {expense.category}
                  </span>
                </td>
                <td className="px-6 py-4 text-sm text-gray-300">
                  {expense.vendorName || "-"}
                </td>
                <td className="px-6 py-4 text-sm text-right font-mono font-medium text-emerald-400">
                  ${expense.amount.toLocaleString()}
                </td>
              </tr>
            ))}
            {financials.expenses.length === 0 && (
              <tr>
                <td
                  colSpan={5}
                  className="px-6 py-8 text-center text-sm text-gray-500">
                  No expenses recorded yet.
                </td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
}


// =======================================================
// FILE: frontend_harness/src/components/VendorEventsTable.tsx
// =======================================================
import React, { useState, useEffect, useCallback } from "react";
import { apiClient } from "../apiClient";
import type { EventDto, Guid } from "../types";

interface VendorEventsTableProps {
  vendorId: Guid;
}

const VendorEventsTable: React.FC<VendorEventsTableProps> = ({ vendorId }) => {
  const [events, setEvents] = useState<EventDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // FIX: Wrap in useCallback to satisfy ESLint and allow usage in useEffect + Retry button
  const fetchEvents = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const response = await apiClient.get<EventDto[]>(
        `/api/vendors/${vendorId}/events`
      );
      setEvents(response.data);
    } catch (err) {
      console.error("Error fetching events for vendor:", err);
      setError("Failed to load events.");
    } finally {
      setLoading(false);
    }
  }, [vendorId]); // Re-create function only if vendorId changes

  useEffect(() => {
    if (vendorId) {
      fetchEvents();
    }
  }, [fetchEvents, vendorId]); // FIX: Added fetchEvents dependency

  if (loading) return <div style={{ padding: "10px" }}>Loading events...</div>;

  if (error)
    return (
      <div style={{ color: "red", padding: "10px" }}>
        {error} <button onClick={fetchEvents}>Retry</button>
      </div>
    );

  return (
    <div style={{ marginBottom: "30px" }}>
      <h3>Events Hired For ({events.length})</h3>
      {events.length === 0 ? (
        <p>This vendor is not currently linked to any events.</p>
      ) : (
        <table style={{ width: "100%", borderCollapse: "collapse" }}>
          <thead>
            <tr style={{ borderBottom: "2px solid #ccc" }}>
              <th style={{ padding: "8px", textAlign: "left" }}>Event Name</th>
              <th style={{ padding: "8px", textAlign: "left" }}>Date</th>
              <th style={{ padding: "8px", textAlign: "left" }}>Status</th>
            </tr>
          </thead>
          <tbody>
            {events.map((event) => (
              <tr key={event.id} style={{ borderBottom: "1px solid #eee" }}>
                <td style={{ padding: "8px" }}>{event.name}</td>
                <td style={{ padding: "8px" }}>
                  {new Date(event.startDateTime).toLocaleDateString()}
                </td>
                <td style={{ padding: "8px" }}>{event.status}</td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
};

export default VendorEventsTable;


// =======================================================
// FILE: frontend_harness/src/components/ContactsPage.tsx
// =======================================================
// =======================================================
// FILE: frontend_harness/src/components/ContactsPage.tsx
// =======================================================
import { useEffect, useState } from "react";
import { apiClient } from "../apiClient";
import type { ContactDto } from "../types";
import { LeadStage, ConnectionStatus } from "../types";
import axios from "axios";

import { useSelectionContext } from "../context/useSelectionContext";
import {
  RelatedTasks,
  RelatedNotes,
  ContactEventsTable,
  EmailHistoryTable,
} from "./RelatedTables";

type ContactFormData = Omit<ContactDto, "id">;

type ValidationErrors = {
  [key: string]: string[];
};

// Local definition for Template to avoid editing types.ts in this turn
type TemplateDto = {
  id: string;
  name: string;
  content: string;
};

const styleSheet = document.createElement("style");
styleSheet.type = "text/css";
styleSheet.innerText = `
  .contact-row:hover {
    cursor: pointer;
    background-color: #333;
  }
  .selected-row {
    background-color: #004a99;
    color: white;
  }
  .selected-row:hover {
    background-color: #005ac7;
  }
  .modal-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  .modal-content {
    background: #222;
    padding: 2rem;
    border: 1px solid #555;
    min-width: 400px;
    border-radius: 8px;
  }
`;
document.head.appendChild(styleSheet);

function ContactsPage() {
  const [contacts, setContacts] = useState<ContactDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // --- Email Scheduling State ---
  const [templates, setTemplates] = useState<TemplateDto[]>([]);
  const [isEmailModalOpen, setIsEmailModalOpen] = useState(false);
  const [emailConfig, setEmailConfig] = useState({
    contactId: "",
    contactName: "", // For display
    templateId: "",
    sendAt: "",
  });
  // ------------------------------

  const initialFormState: ContactFormData = {
    firstName: "",
    lastName: "",
    email: "",
    phoneNumber: null,
    title: null,
    organization: null,
    // New Pipeline Fields
    stage: LeadStage.NewLead,
    connectionStatus: ConnectionStatus.NeedToMeet,
    isLead: true,
    followUpCount: 0,
    source: null,
    lastContactedAt: null,
  };

  const [formData, setFormData] =
    useState<Partial<ContactDto>>(initialFormState);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<ValidationErrors>(
    {}
  );

  const { selectedContactId, setSelectedContactId } = useSelectionContext();

  const isEditing = editingId !== null;

  const fetchContacts = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiClient.get<ContactDto[]>("/api/contacts");
      setContacts(response.data);
    } catch (err: unknown) {
      console.error(err);
      let errorMessage = "Failed to fetch contacts. An unknown error occurred.";
      if (err instanceof Error) {
        errorMessage = `Failed to fetch contacts: ${err.message}`;
      }
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  // Fetch Templates for the dropdown
  const fetchTemplates = async () => {
    try {
      const response = await apiClient.get<TemplateDto[]>("/api/templates");
      setTemplates(response.data);
    } catch (err) {
      console.error("Failed to load templates", err);
    }
  };

  useEffect(() => {
    fetchContacts();
    fetchTemplates();
    return () => {
      setSelectedContactId(null);
    };
  }, [setSelectedContactId]);

  const handleDelete = async (id: string) => {
    if (!window.confirm("Are you sure you want to delete this contact?")) {
      return;
    }

    if (id === selectedContactId) {
      setSelectedContactId(null);
    }

    try {
      await apiClient.delete(`/api/contacts/${id}`);
      await fetchContacts();
    } catch (err) {
      console.error(err);
      if (err instanceof Error) {
        alert(`Failed to delete contact: ${err.message}`);
      }
    }
  };

  const handleEdit = (contact: ContactDto) => {
    setEditingId(contact.id);
    setFormData(contact);
    setValidationErrors({});
    window.scrollTo(0, 0);
  };

  const handleCancel = () => {
    setEditingId(null);
    setFormData(initialFormState);
    setValidationErrors({});
  };

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>
  ) => {
    const { name, value, type } = e.target;

    setFormData((prev) => {
      let newValue: string | number | boolean | null =
        value === "" ? null : value;

      // Handle Numeric Enums (Stage & ConnectionStatus)
      if (name === "stage" || name === "connectionStatus") {
        newValue = parseInt(value, 10);
      }

      // Handle Checkbox
      if (type === "checkbox") {
        newValue = (e.target as HTMLInputElement).checked;
      }

      return {
        ...prev,
        [name]: newValue,
      };
    });
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setValidationErrors({});

    const payload = {
      ...formData,
      firstName: formData.firstName ?? "",
      lastName: formData.lastName ?? "",
      email: formData.email ?? "",
      stage: formData.stage ?? LeadStage.NewLead,
      connectionStatus:
        formData.connectionStatus ?? ConnectionStatus.NeedToMeet,
      isLead: formData.isLead ?? true,
      followUpCount: formData.followUpCount ?? 0,
    };

    const promise = isEditing
      ? apiClient.put(`/api/contacts/${editingId}`, payload)
      : apiClient.post("/api/contacts", payload);

    try {
      await promise;
      handleCancel();
      await fetchContacts();
    } catch (err: unknown) {
      if (axios.isAxiosError(err) && err.response?.status === 400) {
        const apiErrors = err.response.data.errors || {
          General: ["An unknown validation error occurred."],
        };
        setValidationErrors(apiErrors);
      } else {
        console.error(err);
        alert("An unexpected error occurred.");
      }
    }
  };

  const handleRowClick = (contactId: string) => {
    if (isEditing) {
      handleCancel();
    }

    if (selectedContactId === contactId) {
      setSelectedContactId(null);
    } else {
      setSelectedContactId(contactId);
    }
  };

  // --- Email Modal Handlers ---
  const openEmailModal = (e: React.MouseEvent, contact: ContactDto) => {
    e.stopPropagation(); // Prevent row selection
    setEmailConfig({
      contactId: contact.id,
      contactName: `${contact.firstName} ${contact.lastName}`,
      templateId: templates.length > 0 ? templates[0].id : "",
      sendAt: "",
    });
    setIsEmailModalOpen(true);
  };

  const handleEmailSubmit = async () => {
    if (!emailConfig.templateId) {
      alert("Please select a template.");
      return;
    }

    try {
      await apiClient.post("/api/automation/schedule-email", {
        contactId: emailConfig.contactId,
        templateId: emailConfig.templateId,
        sendAt: emailConfig.sendAt
          ? new Date(emailConfig.sendAt).toISOString()
          : null,
      });
      alert("Email scheduled successfully!");
      setIsEmailModalOpen(false);
    } catch (err) {
      console.error(err);
      alert("Failed to schedule email.");
    }
  };
  // ----------------------------

  if (error) return <p style={{ color: "red" }}>{error}</p>;

  return (
    <div>
      {/* --- Email Modal --- */}
      {isEmailModalOpen && (
        <div className="modal-overlay">
          <div className="modal-content">
            <h3>Send Email to: {emailConfig.contactName}</h3>

            <div style={{ marginBottom: "1rem" }}>
              <label style={{ display: "block", marginBottom: "0.5rem" }}>
                Select Template:
              </label>
              <select
                style={{ width: "100%", padding: "0.5rem" }}
                value={emailConfig.templateId}
                onChange={(e) =>
                  setEmailConfig((prev) => ({
                    ...prev,
                    templateId: e.target.value,
                  }))
                }>
                <option value="">-- Select a Template --</option>
                {templates.map((t) => (
                  <option key={t.id} value={t.id}>
                    {t.name}
                  </option>
                ))}
              </select>
            </div>

            <div style={{ marginBottom: "1rem" }}>
              <label style={{ display: "block", marginBottom: "0.5rem" }}>
                Send At (Optional):
              </label>
              <input
                type="datetime-local"
                style={{ width: "100%", padding: "0.5rem" }}
                value={emailConfig.sendAt}
                onChange={(e) =>
                  setEmailConfig((prev) => ({
                    ...prev,
                    sendAt: e.target.value,
                  }))
                }
              />
              <small>Leave blank to send immediately.</small>
            </div>

            <div
              style={{
                display: "flex",
                justifyContent: "flex-end",
                gap: "1rem",
              }}>
              <button onClick={() => setIsEmailModalOpen(false)}>Cancel</button>
              <button
                onClick={handleEmailSubmit}
                style={{ backgroundColor: "#004a99", color: "white" }}>
                Send Email
              </button>
            </div>
          </div>
        </div>
      )}

      <div
        style={{
          marginBottom: "2rem",
          padding: "1rem",
          border: "1px solid #555",
        }}>
        <h2>{isEditing ? "Edit Contact" : "Create Contact"}</h2>
        <form onSubmit={handleSubmit}>
          {/* --- Identity Fields --- */}
          <div style={{ display: "flex", gap: "1rem" }}>
            <div style={{ marginBottom: "0.5rem", flex: 1 }}>
              <label>First Name: </label>
              <input
                name="firstName"
                value={formData.firstName ?? ""}
                onChange={handleChange}
                style={{ width: "100%" }}
              />
              {validationErrors.FirstName && (
                <div style={{ color: "red" }}>
                  {validationErrors.FirstName[0]}
                </div>
              )}
            </div>
            <div style={{ marginBottom: "0.5rem", flex: 1 }}>
              <label>Last Name: </label>
              <input
                name="lastName"
                value={formData.lastName ?? ""}
                onChange={handleChange}
                style={{ width: "100%" }}
              />
              {validationErrors.LastName && (
                <div style={{ color: "red" }}>
                  {validationErrors.LastName[0]}
                </div>
              )}
            </div>
          </div>

          <div style={{ display: "flex", gap: "1rem" }}>
            <div style={{ marginBottom: "0.5rem", flex: 1 }}>
              <label>Email: </label>
              <input
                name="email"
                value={formData.email ?? ""}
                onChange={handleChange}
                style={{ width: "100%" }}
              />
              {validationErrors.Email && (
                <div style={{ color: "red" }}>{validationErrors.Email[0]}</div>
              )}
            </div>
            <div style={{ marginBottom: "0.5rem", flex: 1 }}>
              <label>Phone: </label>
              <input
                name="phoneNumber"
                value={formData.phoneNumber ?? ""}
                onChange={handleChange}
                style={{ width: "100%" }}
              />
            </div>
          </div>

          {/* --- Pipeline & Strategy Fields (NEW) --- */}
          <div
            style={{
              margin: "1rem 0",
              padding: "1rem",
              border: "1px dashed #666",
              borderRadius: "4px",
            }}>
            <h4 style={{ marginTop: 0, marginBottom: "0.5rem" }}>
              Pipeline Status
            </h4>
            <div style={{ display: "flex", gap: "1rem", flexWrap: "wrap" }}>
              {/* Stage Dropdown */}
              <div style={{ flex: 1 }}>
                <label>Lead Stage: </label>
                <select
                  name="stage"
                  value={formData.stage ?? LeadStage.NewLead}
                  onChange={handleChange}
                  style={{ width: "100%", padding: "4px" }}>
                  {Object.entries(LeadStage).map(([key, value]) => (
                    <option key={key} value={value}>
                      {key}
                    </option>
                  ))}
                </select>
              </div>

              {/* Connection Status Dropdown */}
              <div style={{ flex: 1 }}>
                <label>Connection Status: </label>
                <select
                  name="connectionStatus"
                  value={
                    formData.connectionStatus ?? ConnectionStatus.NeedToMeet
                  }
                  onChange={handleChange}
                  style={{ width: "100%", padding: "4px" }}>
                  {Object.entries(ConnectionStatus).map(([key, value]) => (
                    <option key={key} value={value}>
                      {key}
                    </option>
                  ))}
                </select>
              </div>

              {/* Is Lead Checkbox */}
              <div
                style={{
                  flex: "0 0 auto",
                  display: "flex",
                  alignItems: "center",
                  paddingTop: "1.2rem",
                }}>
                <label
                  style={{
                    display: "flex",
                    alignItems: "center",
                    cursor: "pointer",
                  }}>
                  <input
                    type="checkbox"
                    name="isLead"
                    checked={formData.isLead ?? true}
                    onChange={handleChange}
                    style={{ marginRight: "0.5rem" }}
                  />
                  Is Lead?
                </label>
              </div>
            </div>
          </div>

          <div style={{ marginBottom: "0.5rem" }}>
            <label>Organization: </label>
            <input
              name="organization"
              value={formData.organization ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Title: </label>
            <input
              name="title"
              value={formData.title ?? ""}
              onChange={handleChange}
            />
          </div>

          <button type="submit">{isEditing ? "Save Changes" : "Create"}</button>
          {isEditing && (
            <button
              type="button"
              onClick={handleCancel}
              style={{ marginLeft: "0.5rem" }}>
              Cancel
            </button>
          )}
          {validationErrors.General && (
            <div style={{ color: "red", marginTop: "1rem" }}>
              {validationErrors.General[0]}
            </div>
          )}
        </form>
      </div>

      <h2>Contacts List</h2>
      {loading ? (
        <p>Loading Contacts...</p>
      ) : contacts.length === 0 ? (
        <p>No contacts found.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Name</th>
              <th>Email</th>
              <th>Status</th> {/* NEW COLUMN */}
              <th>Organization</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {contacts.map((contact) => (
              <tr
                key={contact.id}
                className={`
                  contact-row 
                  ${selectedContactId === contact.id ? "selected-row" : ""}
                `}
                onClick={(e) => {
                  if (
                    e.target instanceof HTMLElement &&
                    e.target.tagName !== "BUTTON" &&
                    e.target.tagName !== "SELECT"
                  ) {
                    handleRowClick(contact.id);
                  }
                }}>
                <td>{contact.id.substring(0, 8)}...</td>
                <td>
                  {contact.firstName} {contact.lastName}
                </td>
                <td>{contact.email}</td>
                {/* NEW STATUS COLUMN */}
                <td>
                  <span
                    style={{
                      fontSize: "0.8rem",
                      padding: "2px 4px",
                      background: "#444",
                      borderRadius: "4px",
                    }}>
                    {Object.keys(LeadStage).find(
                      (key) =>
                        LeadStage[key as keyof typeof LeadStage] ===
                        contact.stage
                    )}
                  </span>
                </td>
                <td>{contact.organization ?? "N/A"}</td>
                <td>
                  <button
                    onClick={() => handleEdit(contact)}
                    style={{ color: "lightblue", marginRight: "0.5rem" }}>
                    Edit
                  </button>
                  <button
                    onClick={() => handleDelete(contact.id)}
                    style={{ color: "red", marginRight: "0.5rem" }}>
                    Delete
                  </button>
                  <button
                    onClick={(e) => openEmailModal(e, contact)}
                    style={{ color: "lightgreen" }}>
                    Send Email
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}

      {selectedContactId && (
        <div
          style={{
            borderTop: "2px solid #555",
            marginTop: "3rem",
            paddingTop: "1rem",
          }}>
          <h2>Contact Dashboard: ID {selectedContactId}</h2>
          <ContactEventsTable />
          <RelatedTasks />
          <RelatedNotes />
          <EmailHistoryTable />
        </div>
      )}
    </div>
  );
}

export default ContactsPage;


// =======================================================
// FILE: frontend_harness/src/components/EventsPage.tsx
// =======================================================
// FILE: frontend_harness/src/components/EventsPage.tsx
import React, { useEffect, useState, useCallback } from "react";
import { apiClient } from "../apiClient";
// FIX 1: Removed unused 'Guid' import
import type { EventDto, ContactDto, VendorDto } from "../types";
import axios from "axios";
import { useSelectionContext } from "../context/useSelectionContext";
import {
  RelatedTasks,
  RelatedNotes,
  EventParticipantsTable,
} from "./RelatedTables";
import { DocumentsSection } from "./DocumentsSection";
// --- NEW: Import the Financials Module ---
import FinancialsSection from "./FinancialsSection";

type EventFormData = Omit<EventDto, "id">;
type ValidationErrors = { [key: string]: string[] };

// --- SUB-COMPONENT: EventVendorAttributesDisplay ---
interface VendorAttributeProps {
  eventVendors: VendorDto[]; // All vendors linked to the event (or fetched separately)
}

const EventVendorAttributesDisplay: React.FC<VendorAttributeProps> = ({
  eventVendors,
}) => {
  // Filter for vendors whose attributes we care about displaying prominently on the dashboard
  const featuredVendors = eventVendors.filter(
    (v) =>
      v.serviceType?.toLowerCase() === "venue" ||
      v.serviceType?.toLowerCase() === "entertainment"
  );

  if (featuredVendors.length === 0) {
    return null;
  }

  return (
    <div
      style={{
        marginTop: "20px",
        padding: "15px",
        border: "1px solid #777",
        borderRadius: "5px",
        backgroundColor: "#333",
      }}>
      <h4 style={{ margin: 0, color: "#ccc" }}>Key Vendor Attributes</h4>
      <div
        style={{
          marginTop: "10px",
          display: "flex",
          flexWrap: "wrap",
          gap: "20px",
        }}>
        {featuredVendors.map((vendor) => {
          let attributeDisplay = null;
          // FIX 2: Changed 'let title' to 'const title'
          const title = vendor.name;

          try {
            if (vendor.attributes) {
              const attrs = JSON.parse(vendor.attributes);

              if (
                vendor.serviceType?.toLowerCase() === "venue" &&
                attrs.Capacity
              ) {
                attributeDisplay = `Capacity: ${attrs.Capacity}`;
              } else if (
                vendor.serviceType?.toLowerCase() === "entertainment" &&
                attrs.Genre
              ) {
                attributeDisplay = `Genre: ${attrs.Genre}`;
              }
            }
          } catch (e) {
            console.error("Error parsing vendor attributes:", e);
          }

          if (!attributeDisplay) {
            // Skip if the required key isn't found
            return null;
          }

          return (
            <div
              key={vendor.id}
              style={{ borderLeft: "3px solid #64b5f6", paddingLeft: "10px" }}>
              <strong style={{ display: "block", color: "#fff" }}>
                {title} ({vendor.serviceType})
              </strong>
              <span style={{ color: "#aaa", fontSize: "0.9rem" }}>
                {attributeDisplay}
              </span>
            </div>
          );
        })}
      </div>
    </div>
  );
};
// --- END EventVendorAttributesDisplay ---

// --- SUB-COMPONENT: ContactLinker ---
interface ContactLinkerProps {
  eventId: string;
  onLinkSuccess: () => void;
}

const ContactLinker: React.FC<ContactLinkerProps> = ({
  eventId,
  onLinkSuccess,
}) => {
  const [contacts, setContacts] = useState<ContactDto[]>([]);
  const [selectedContactId, setSelectedContactId] = useState<string>("");
  const [loading, setLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchContacts = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<ContactDto[]>("/api/contacts");
        setContacts(response.data);
        if (response.data.length > 0) {
          setSelectedContactId(response.data[0].id);
        }
      } catch (err) {
        console.error("Failed to fetch all contacts:", err);
      } finally {
        setLoading(false);
      }
    };
    fetchContacts();
  }, []);

  const handleLink = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!selectedContactId) {
      setError("Please select a contact to link.");
      return;
    }

    setIsSubmitting(true);
    setError(null);
    try {
      const payload = { contactId: selectedContactId };
      await apiClient.post(`/api/events/${eventId}/contacts`, payload);

      onLinkSuccess();
      setError(null);
    } catch (err) {
      const message =
        axios.isAxiosError(err) && err.response?.data?.title
          ? err.response.data.title
          : "Failed to link contact to event.";
      setError(message);
    } finally {
      setIsSubmitting(false);
    }
  };

  if (loading) return <p>Loading contacts for linking...</p>;
  if (contacts.length === 0) return <p>No available contacts to link.</p>;
  return (
    <div
      style={{
        border: "1px dashed #ccc",
        padding: "1rem",
        marginBottom: "1rem",
      }}>
      <h4>Link Contact to Event</h4>
      <form onSubmit={handleLink} style={{ display: "flex", gap: "10px" }}>
        <select
          value={selectedContactId}
          onChange={(e) => setSelectedContactId(e.target.value)}
          disabled={isSubmitting}>
          {contacts.map((contact) => (
            <option key={contact.id} value={contact.id}>
              {contact.firstName} {contact.lastName} ({contact.email})
            </option>
          ))}
        </select>
        <button type="submit" disabled={isSubmitting}>
          {isSubmitting ? "Linking..." : "Link Contact"}
        </button>
      </form>
      {error && (
        <div style={{ color: "red", marginTop: "0.5rem" }}>Error: {error}</div>
      )}
    </div>
  );
};
// --- END ContactLinker ---

function EventsPage() {
  const [events, setEvents] = useState<EventDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // FIX 3: Removed unused 'allVendors' state
  const [eventVendors, setEventVendors] = useState<VendorDto[]>([]);
  // ----------------------------------

  const { selectedEventId, setSelectedEventId } = useSelectionContext();
  const [dashboardKey, setDashboardKey] = useState(0);

  const initialFormState: EventFormData = {
    name: "",
    description: null,
    startDateTime: "",
    endDateTime: "",
    location: null,
    isPublic: false,
    status: "Planned",
  };
  const [formData, setFormData] = useState<Partial<EventDto>>(initialFormState);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<ValidationErrors>(
    {}
  );

  const isEditing = editingId !== null;

  // --- PHASE 29: Fetch Vendor Data for Attribute Display (Simplified) ---
  const fetchAuxiliaryData = useCallback(async () => {
    try {
      // We only need the vendors linked to the *current* event
      // (which implicitly includes their attributes via the backend DTO)
      const eventVendorsResponse = selectedEventId
        ? await apiClient.get<VendorDto[]>(
            `/api/events/${selectedEventId}/vendors`
          )
        : { data: [] as VendorDto[] };

      setEventVendors(eventVendorsResponse.data);
    } catch (err) {
      console.error("Failed to fetch event vendor data:", err);
    }
  }, [selectedEventId]);
  // --------------------------------------------------------

  const forceDashboardRefresh = () => {
    setDashboardKey((prev) => prev + 1);
    fetchAuxiliaryData(); // Refetch vendor data when related tables change
  };

  const fetchEvents = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiClient.get<EventDto[]>("/api/events");
      setEvents(response.data);
    } catch (err: unknown) {
      console.error(err);
      setError("Failed to fetch events.");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchEvents();
  }, []);

  // --- PHASE 29: Refetch auxiliary data when event ID changes ---
  useEffect(() => {
    if (selectedEventId) {
      fetchAuxiliaryData();
    } else {
      setEventVendors([]);
    }
  }, [selectedEventId, fetchAuxiliaryData]);
  // -------------------------------------------------------------

  const handleDelete = async (id: string) => {
    if (!window.confirm("Are you sure you want to delete this event?")) return;
    try {
      await apiClient.delete(`/api/events/${id}`);
      setSelectedEventId(null);
      await fetchEvents();
    } catch (err) {
      console.error(err);
      alert("Failed to delete event.");
    }
  };

  const handleEdit = (event: EventDto) => {
    setEditingId(event.id);
    setFormData({
      ...event,
      startDateTime: event.startDateTime.slice(0, 16),
      endDateTime: event.endDateTime.slice(0, 16),
    });
    setValidationErrors({});
    window.scrollTo(0, 0);
  };

  const handleCancel = () => {
    setEditingId(null);
    setFormData(initialFormState);
    setValidationErrors({});
  };

  const handleChange = (
    e: React.ChangeEvent<
      HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement
    >
  ) => {
    const { name, value, type } = e.target;
    if (type === "checkbox") {
      setFormData((prev) => ({
        ...prev,
        [name]: (e.target as HTMLInputElement).checked,
      }));
    } else {
      setFormData((prev) => ({
        ...prev,
        [name]: value === "" ? null : value,
      }));
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setValidationErrors({});

    const payload = {
      ...formData,
      startDateTime: formData.startDateTime
        ? new Date(formData.startDateTime).toISOString()
        : "",
      endDateTime: formData.endDateTime
        ? new Date(formData.endDateTime).toISOString()
        : "",
    };
    const promise = isEditing
      ? apiClient.put(`/api/events/${editingId}`, payload)
      : apiClient.post("/api/events", payload);

    try {
      await promise;
      handleCancel();
      setSelectedEventId(null);
      await fetchEvents();
    } catch (err: unknown) {
      if (axios.isAxiosError(err) && err.response?.status === 400) {
        setValidationErrors(
          err.response.data.errors || { General: ["Validation Error"] }
        );
      } else {
        console.error(err);
        alert("An unexpected error occurred.");
      }
    }
  };

  const handleRowClick = (eventId: string) => {
    if (selectedEventId === eventId) {
      setSelectedEventId(null);
    } else {
      setSelectedEventId(eventId);
    }
    // The key update forces the entire dashboard section to remount.
    setDashboardKey((prev) => prev + 1);
  };

  if (error) return <p style={{ color: "red" }}>{error}</p>;

  return (
    <div>
      <div
        style={{
          marginBottom: "2rem",
          padding: "1rem",
          border: "1px solid #555",
        }}>
        <h2>{isEditing ? "Edit Event" : "Create Event"}</h2>
        <form onSubmit={handleSubmit}>
          {/* ... (Form fields remain the same) ... */}
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Name: </label>
            <input
              name="name"
              value={formData.name ?? ""}
              onChange={handleChange}
            />
            {validationErrors.Name && (
              <div style={{ color: "red" }}>{validationErrors.Name[0]}</div>
            )}
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Description: </label>
            <textarea
              name="description"
              value={formData.description ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Start Time: </label>
            <input
              name="startDateTime"
              type="datetime-local"
              value={formData.startDateTime ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>End Time: </label>
            <input
              name="endDateTime"
              type="datetime-local"
              value={formData.endDateTime ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Location: </label>
            <input
              name="location"
              value={formData.location ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Status: </label>
            <select
              name="status"
              value={formData.status ?? "Planned"}
              onChange={handleChange}>
              <option value="Planned">Planned</option>
              <option value="Confirmed">Confirmed</option>
              <option value="Cancelled">Cancelled</option>
            </select>
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>
              <input
                name="isPublic"
                type="checkbox"
                checked={formData.isPublic ?? false}
                onChange={handleChange}
              />
              Is Public
            </label>
          </div>

          <button type="submit">{isEditing ? "Save Changes" : "Create"}</button>
          {isEditing && (
            <button
              type="button"
              onClick={handleCancel}
              style={{ marginLeft: "0.5rem" }}>
              Cancel
            </button>
          )}
          {validationErrors.General && (
            <div style={{ color: "red", marginTop: "1rem" }}>
              {validationErrors.General[0]}
            </div>
          )}
        </form>
      </div>

      <h2>Events List (Click a row for related data)</h2>
      {loading ? (
        <p>Loading Events...</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Name</th>
              <th>Status</th>
              <th>Start</th>
              <th>End</th>
              <th>Location</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {events.map((event) => (
              <tr
                key={event.id}
                onClick={() => handleRowClick(event.id)}
                style={{
                  cursor: "pointer",
                  backgroundColor:
                    event.id === selectedEventId ? "#444" : "inherit",
                }}>
                <td>{event.id}</td>
                <td>{event.name}</td>
                <td>{event.status}</td>
                <td>{new Date(event.startDateTime).toLocaleString()}</td>
                <td>{new Date(event.endDateTime).toLocaleString()}</td>
                <td>{event.location ?? "N/A"}</td>
                <td>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      handleEdit(event);
                    }}
                    style={{ color: "blue" }}>
                    Edit
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      handleDelete(event.id);
                    }}
                    style={{ color: "red", marginLeft: "0.5rem" }}>
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}

      {/* --- DASHBOARD --- */}
      {selectedEventId && (
        <div
          key={dashboardKey}
          style={{
            borderTop: "2px solid #555",
            marginTop: "3rem",
            paddingTop: "1rem",
          }}>
          <h2 style={{ marginBottom: "2rem" }}>
            Dashboard: Event ID {selectedEventId}
          </h2>

          {/* --- PHASE 29: DISPLAY VENDOR ATTRIBUTES --- */}
          <EventVendorAttributesDisplay eventVendors={eventVendors} />
          {/* --------------------------------------------- */}

          {/* 1. Financials (High Priority) */}
          <div style={{ marginBottom: "3rem" }}>
            <FinancialsSection
              eventId={selectedEventId}
              refreshKey={dashboardKey}
            />
          </div>

          <hr style={{ margin: "2rem 0", borderColor: "#ccc" }} />

          {/* 2. Contacts & Documents */}
          <div
            style={{
              display: "grid",
              gridTemplateColumns: "1fr 1fr",
              gap: "2rem",
            }}>
            <div>
              <ContactLinker
                eventId={selectedEventId}
                onLinkSuccess={forceDashboardRefresh}
              />
              <EventParticipantsTable onUnlinkSuccess={forceDashboardRefresh} />
            </div>
            <div>
              <DocumentsSection entityId={selectedEventId} entityType="Event" />
            </div>
          </div>

          <hr style={{ margin: "2rem 0", borderColor: "#ccc" }} />

          {/* 3. Operational (Tasks & Notes) */}
          <RelatedTasks />
          <RelatedNotes />
        </div>
      )}
    </div>
  );
}

export default EventsPage;


// =======================================================
// FILE: frontend_harness/src/components/SendEmailModal.tsx
// =======================================================
import React, { useState, useEffect } from "react";
import { templates } from "../apiClient";
import type {
  TemplateDto,
  ContactDto,
  VendorDto,
  SendTemplateEmailCommand,
} from "../types";
import { RecipientType } from "../types"; // RecipientType is a const object (runtime value), so no 'type' keyword here

interface SendEmailModalProps {
  eventId: string;
  isOpen: boolean;
  onClose: () => void;
  availableContacts: ContactDto[];
  availableVendors: VendorDto[];
}

export const SendEmailModal: React.FC<SendEmailModalProps> = ({
  eventId,
  isOpen,
  onClose,
  availableContacts,
  availableVendors,
}) => {
  const [templateList, setTemplateList] = useState<TemplateDto[]>([]);
  const [selectedTemplateId, setSelectedTemplateId] = useState<string>("");
  const [selectedRecipientId, setSelectedRecipientId] = useState<string>("");
  const [recipientType, setRecipientType] = useState<RecipientType>(
    RecipientType.Contact
  );
  const [isSending, setIsSending] = useState(false);

  useEffect(() => {
    if (isOpen) {
      loadTemplates();
    }
  }, [isOpen]);

  const loadTemplates = async () => {
    try {
      const data = await templates.getAll();
      setTemplateList(data);
    } catch (error) {
      console.error("Failed to load templates", error);
    }
  };

  const handleSend = async () => {
    if (!selectedTemplateId || !selectedRecipientId) return;

    setIsSending(true);
    try {
      const command: SendTemplateEmailCommand = {
        eventId,
        templateId: selectedTemplateId,
        targetEntityId: selectedRecipientId,
        recipientType: recipientType,
      };

      await templates.sendEmail(command);
      alert("Email sent successfully!");
      onClose();
    } catch (error) {
      console.error("Failed to send email", error);
      alert("Failed to send email.");
    } finally {
      setIsSending(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
        <h2 className="text-xl font-bold mb-4">Send Event Email</h2>

        {/* Template Selection */}
        <div className="mb-4">
          <label className="block text-sm font-medium mb-1">
            Select Template
          </label>
          <select
            className="w-full border p-2 rounded"
            value={selectedTemplateId}
            onChange={(e) => setSelectedTemplateId(e.target.value)}>
            <option value="">-- Choose a Template --</option>
            {templateList.map((t) => (
              <option key={t.id} value={t.id}>
                {t.name}
              </option>
            ))}
          </select>
        </div>

        {/* Recipient Type Toggle */}
        <div className="mb-4 flex gap-4">
          <label className="flex items-center">
            <input
              type="radio"
              name="rtype"
              checked={recipientType === RecipientType.Contact}
              onChange={() => {
                setRecipientType(RecipientType.Contact);
                setSelectedRecipientId("");
              }}
              className="mr-2"
            />
            Contact
          </label>
          <label className="flex items-center">
            <input
              type="radio"
              name="rtype"
              checked={recipientType === RecipientType.Vendor}
              onChange={() => {
                setRecipientType(RecipientType.Vendor);
                setSelectedRecipientId("");
              }}
              className="mr-2"
            />
            Vendor
          </label>
        </div>

        {/* Recipient Selection */}
        <div className="mb-6">
          <label className="block text-sm font-medium mb-1">
            Select{" "}
            {recipientType === RecipientType.Contact ? "Contact" : "Vendor"}
          </label>
          <select
            className="w-full border p-2 rounded"
            value={selectedRecipientId}
            onChange={(e) => setSelectedRecipientId(e.target.value)}>
            <option value="">-- Choose Recipient --</option>
            {recipientType === RecipientType.Contact
              ? availableContacts.map((c) => (
                  <option key={c.id} value={c.id}>
                    {c.firstName} {c.lastName} ({c.organization})
                  </option>
                ))
              : availableVendors.map((v) => (
                  <option key={v.id} value={v.id}>
                    {v.name} ({v.serviceType})
                  </option>
                ))}
          </select>
        </div>

        <div className="flex justify-end gap-2">
          <button
            onClick={onClose}
            className="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded">
            Cancel
          </button>
          <button
            onClick={handleSend}
            disabled={isSending || !selectedTemplateId || !selectedRecipientId}
            className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50">
            {isSending ? "Sending..." : "Send Email"}
          </button>
        </div>
      </div>
    </div>
  );
};


// =======================================================
// FILE: frontend_harness/src/components/FileUploader.tsx
// =======================================================
import React, { useState } from "react";
import axios from "axios";
import { uploadDocument } from "../apiClient";
import type { Document } from "../types"; // Fix: Type-only import

interface FileUploaderProps {
  relatedEntityId: string;
  relatedEntityType: "Event" | "Vendor" | "Contact" | "Task";
  onUploadSuccess?: (document: Document) => void;
}

// Hardcoded categories for The Librarian
const DOCUMENT_CATEGORIES = [
  "General",
  "Invoice",
  "Contract",
  "Rider",
  "Marketing",
  "Legal",
];

export const FileUploader: React.FC<FileUploaderProps> = ({
  relatedEntityId,
  relatedEntityType,
  onUploadSuccess,
}) => {
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [category, setCategory] = useState<string>("General"); // Default category

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files || e.target.files.length === 0) return;

    const file = e.target.files[0];
    await handleUpload(file);
  };

  const handleUpload = async (file: File) => {
    setIsUploading(true);
    setError(null);

    try {
      // Pass the selected category to the API
      const result = await uploadDocument(
        file,
        relatedEntityId,
        relatedEntityType,
        category
      );
      if (onUploadSuccess) {
        onUploadSuccess(result);
      }
    } catch (err) {
      console.error(err);

      let errorMessage = "Failed to upload file.";

      if (axios.isAxiosError(err) && err.response?.data) {
        const data = err.response.data;
        if (typeof data === "string") {
          errorMessage = data;
        } else if (typeof data === "object") {
          if (data.message) {
            errorMessage = data.message;
            if (data.details) errorMessage += ` (${data.details})`;
          } else if (data.title) {
            errorMessage = data.title;
          } else if (data.errors) {
            errorMessage = Object.values(data.errors).flat().join(", ");
          }
        }
      } else if (err instanceof Error) {
        errorMessage = err.message;
      }

      setError(errorMessage);
    } finally {
      setIsUploading(false);
    }
  };

  return (
    <div className="p-4 border-2 border-dashed border-gray-300 rounded-lg bg-gray-50 text-center hover:bg-gray-100 transition-colors">
      {/* Category Selector */}
      <div
        style={{
          marginBottom: "1rem",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          gap: "10px",
        }}>
        <label style={{ fontSize: "0.9rem", fontWeight: "600", color: "#555" }}>
          Document Type:
        </label>
        <select
          value={category}
          onChange={(e) => setCategory(e.target.value)}
          disabled={isUploading}
          style={{
            padding: "5px 10px",
            borderRadius: "4px",
            border: "1px solid #ccc",
            fontSize: "0.9rem",
            backgroundColor: "white",
            color: "#333",
          }}>
          {DOCUMENT_CATEGORIES.map((cat) => (
            <option key={cat} value={cat}>
              {cat}
            </option>
          ))}
        </select>
      </div>

      <input
        type="file"
        id={`file-upload-${relatedEntityId}`}
        className="hidden"
        onChange={handleFileChange}
        disabled={isUploading}
      />
      <label
        htmlFor={`file-upload-${relatedEntityId}`}
        className="cursor-pointer flex flex-col items-center justify-center">
        {isUploading ? (
          <span className="text-blue-600 font-semibold">Uploading...</span>
        ) : (
          <>
            <span className="text-gray-700 font-medium">
              Click to Upload Document
            </span>
            <span className="text-xs text-gray-500 mt-1">
              (PDF, DOCX, PNG, JPG)
            </span>
          </>
        )}
      </label>

      {error && (
        <div
          style={{
            color: "red",
            marginTop: "10px",
            fontSize: "0.85rem",
            maxHeight: "100px",
            overflowY: "auto",
            textAlign: "left",
            padding: "5px",
            background: "#fff0f0",
            border: "1px solid #ffcccc",
          }}>
          <strong>Error:</strong> {error}
        </div>
      )}
    </div>
  );
};


// =======================================================
// FILE: frontend_harness/src/components/DocumentsSection.tsx
// =======================================================
import React, { useEffect, useState } from "react";
import { apiClient, deleteDocument } from "../apiClient";
import type { Document } from "../types";
import { FileUploader } from "./FileUploader";

interface DocumentsSectionProps {
  entityId: string;
  entityType: "Event" | "Vendor" | "Contact" | "Task"; // Reusable!
}

export const DocumentsSection: React.FC<DocumentsSectionProps> = ({
  entityId,
  entityType,
}) => {
  const [documents, setDocuments] = useState<Document[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchDocuments = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<Document[]>("/api/documents", {
          params: { relatedEntityId: entityId, relatedEntityType: entityType },
        });
        setDocuments(response.data);
      } catch (err) {
        console.error("Failed to load documents", err);
      } finally {
        setLoading(false);
      }
    };

    if (entityId) fetchDocuments();
  }, [entityId, entityType]);

  const handleUploadSuccess = (newDoc: Document) => {
    setDocuments((prev) => [newDoc, ...prev]);
  };

  const handleDeleteDocument = async (id: number) => {
    if (
      !window.confirm(
        "Are you sure you want to permanently delete this document?"
      )
    )
      return;

    try {
      await deleteDocument(id);
      setDocuments((prev) => prev.filter((doc) => doc.id !== id));
    } catch (err) {
      console.error("Failed to delete document", err);
      alert("Failed to delete document.");
    }
  };

  const formatFileSize = (bytes: number) => {
    if (bytes === 0) return "0 Bytes";
    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  };

  // Helper for Category Badges
  const getCategoryColor = (cat: string) => {
    switch (cat) {
      case "Invoice":
        return "#e0f2fe"; // Light Blue
      case "Contract":
        return "#fce7f3"; // Pink
      case "Legal":
        return "#fee2e2"; // Red
      case "Marketing":
        return "#dcfce7"; // Green
      default:
        return "#f3f4f6"; // Grey
    }
  };

  const getCategoryTextColor = (cat: string) => {
    switch (cat) {
      case "Invoice":
        return "#0369a1";
      case "Contract":
        return "#be185d";
      case "Legal":
        return "#b91c1c";
      case "Marketing":
        return "#15803d";
      default:
        return "#374151";
    }
  };

  return (
    <div
      style={{
        border: "1px solid #ddd",
        borderRadius: "8px",
        padding: "1.5rem",
        marginTop: "2rem",
        backgroundColor: "#ffffff",
        color: "#333",
        boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
      }}>
      <h3
        style={{
          borderBottom: "2px solid #eee",
          paddingBottom: "0.5rem",
          marginBottom: "1rem",
          color: "#222",
        }}>
        {entityType} Documents
      </h3>

      <div style={{ marginBottom: "1.5rem" }}>
        <FileUploader
          relatedEntityId={entityId}
          relatedEntityType={entityType}
          onUploadSuccess={handleUploadSuccess}
        />
      </div>

      {loading ? (
        <p style={{ color: "#666" }}>Loading documents...</p>
      ) : documents.length === 0 ? (
        <div
          style={{
            textAlign: "center",
            padding: "2rem",
            backgroundColor: "#f9fafb",
            borderRadius: "6px",
            border: "1px dashed #ccc",
            color: "#666",
          }}>
          No documents archived.
        </div>
      ) : (
        <div style={{ overflowX: "auto" }}>
          <table
            style={{
              width: "100%",
              borderCollapse: "collapse",
              fontSize: "0.95rem",
            }}>
            <thead>
              <tr
                style={{
                  backgroundColor: "#374151",
                  color: "#ffffff",
                  textAlign: "left",
                }}>
                <th style={{ padding: "12px", borderTopLeftRadius: "6px" }}>
                  File Name
                </th>
                <th style={{ padding: "12px" }}>Category</th> {/* NEW COLUMN */}
                <th style={{ padding: "12px" }}>Size</th>
                <th style={{ padding: "12px" }}>Uploaded</th>
                <th style={{ padding: "12px", borderTopRightRadius: "6px" }}>
                  Action
                </th>
              </tr>
            </thead>
            <tbody>
              {documents.map((doc, index) => (
                <tr
                  key={doc.id}
                  style={{
                    borderBottom: "1px solid #eee",
                    backgroundColor: index % 2 === 0 ? "#fff" : "#f8f9fa",
                  }}>
                  <td
                    style={{
                      padding: "12px",
                      color: "#333",
                      fontWeight: "500",
                    }}>
                    {doc.fileName}
                  </td>
                  <td style={{ padding: "12px" }}>
                    <span
                      style={{
                        backgroundColor: getCategoryColor(doc.category),
                        color: getCategoryTextColor(doc.category),
                        padding: "4px 8px",
                        borderRadius: "12px",
                        fontSize: "0.8rem",
                        fontWeight: "600",
                      }}>
                      {doc.category || "General"}
                    </span>
                  </td>
                  <td style={{ padding: "12px", color: "#555" }}>
                    {formatFileSize(doc.size)}
                  </td>
                  <td style={{ padding: "12px", color: "#555" }}>
                    {new Date(doc.uploadedAt).toLocaleDateString()}
                  </td>
                  <td style={{ padding: "12px" }}>
                    <a
                      href={`http://localhost:5179${doc.url}`}
                      target="_blank"
                      rel="noreferrer"
                      style={{
                        color: "#2563eb",
                        fontWeight: "600",
                        textDecoration: "none",
                        marginRight: "10px",
                      }}>
                      Download
                    </a>
                    <button
                      onClick={() => handleDeleteDocument(doc.id)}
                      style={{
                        color: "#dc2626",
                        fontWeight: "600",
                        background: "none",
                        border: "none",
                        cursor: "pointer",
                      }}>
                      Delete
                    </button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );
};


// =======================================================
// FILE: frontend_harness/src/components/VendorsPage.tsx
// =======================================================
// FILE: frontend_harness/src/components/VendorsPage.tsx

import React, { useEffect, useState, useCallback, useRef } from "react";
import { apiClient } from "../apiClient";
import type { VendorDto, Guid } from "../types";
import axios from "axios";
import { useSelectionContext } from "../context/useSelectionContext";
import { RelatedTasks, RelatedNotes } from "./RelatedTables";
import VendorEventsTable from "./VendorEventsTable";
import { DocumentsSection } from "./DocumentsSection"; // NEW: The Reusable Component

type VendorFormData = Omit<VendorDto, "id">;
type ValidationErrors = { [key: string]: string[] };

const initialFormState: VendorFormData = {
  name: "",
  phoneNumber: null,
  email: null,
  serviceType: "Other",
  attributes: null, // NEW: Include attributes
};

function VendorsPage() {
  const [vendors, setVendors] = useState<VendorDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const { selectedVendorId, setSelectedVendorId } = useSelectionContext();

  const selectedVendorIdRef = useRef(selectedVendorId);
  useEffect(() => {
    selectedVendorIdRef.current = selectedVendorId;
  }, [selectedVendorId]);

  const [formData, setFormData] =
    useState<Partial<VendorDto>>(initialFormState);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<ValidationErrors>(
    {}
  );

  // --- NEW: Dynamic Attribute State ---
  const [dynamicFields, setDynamicFields] = useState<{
    Capacity?: number | string;
    Genre?: string;
  }>({});

  const isEditing = editingId !== null;
  const selectedVendor = vendors.find((v) => v.id === selectedVendorId);

  // Function to initialize dynamic fields from the current formData.attributes
  const initializeDynamicFields = useCallback(
    (attributesString: string | null) => {
      if (!attributesString) {
        setDynamicFields({});
        return;
      }
      try {
        const parsed = JSON.parse(attributesString);
        // Set the dynamic fields, ensuring Capacity is handled as a number/string
        setDynamicFields({
          Capacity: parsed.Capacity || "",
          Genre: parsed.Genre || "",
        });
      } catch (e) {
        console.error("Failed to parse vendor attributes JSON:", e);
        setDynamicFields({});
      }
    },
    []
  );

  const fetchVendors = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiClient.get<VendorDto[]>("/api/vendors");
      setVendors(response.data);
      return response.data;
    } catch (err: unknown) {
      console.error(err);
      setError("Failed to fetch vendors.");
      return [];
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    let mounted = true;

    fetchVendors().then((data) => {
      if (mounted && data && data.length > 0 && !selectedVendorIdRef.current) {
        setSelectedVendorId(data[0].id);
      }
    });

    return () => {
      mounted = false;
      setSelectedVendorId(null);
    };
  }, [fetchVendors, setSelectedVendorId]);

  const handleDelete = async (id: string) => {
    if (!window.confirm("Are you sure you want to delete this vendor?")) return;
    try {
      await apiClient.delete(`/api/vendors/${id}`);
      if (selectedVendorId === id) {
        setSelectedVendorId(null);
      }
      await fetchVendors();
    } catch (err) {
      console.error(err);
      alert("Failed to delete vendor.");
    }
  };

  const handleEdit = (vendor: VendorDto) => {
    setEditingId(vendor.id);
    setFormData(vendor);
    initializeDynamicFields(vendor.attributes); // Initialize dynamic fields when editing
    setValidationErrors({});
    window.scrollTo(0, 0);
  };

  const handleCancel = () => {
    setEditingId(null);
    setFormData(initialFormState);
    setDynamicFields({}); // Clear dynamic fields
    setValidationErrors({});
  };

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>
  ) => {
    const { name, value } = e.target;
    // When ServiceType changes, reset the dynamic fields state
    if (name === "serviceType") {
      setDynamicFields({});
    }

    setFormData((prev) => ({
      ...prev,
      [name]: value === "" ? null : value,
    }));
  };

  // NEW: Handle changes for dynamic fields separately
  const handleDynamicChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setDynamicFields((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  const getAttributesJson = () => {
    const cleanFields = Object.entries(dynamicFields)
      .filter(([, value]) => value !== null && value !== "" && value !== 0)
      .reduce((acc, [key, value]) => {
        // Attempt to parse number fields back to number types for cleaner JSON
        if (
          key === "Capacity" &&
          typeof value === "string" &&
          !isNaN(Number(value))
        ) {
          acc[key] = Number(value);
        } else {
          acc[key] = value;
        }
        return acc;
      }, {} as Record<string, string | number>);

    if (Object.keys(cleanFields).length === 0) {
      return null;
    }
    return JSON.stringify(cleanFields);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setValidationErrors({});

    // --- PHASE 27: Inject serialized attributes into payload ---
    const attributesJson = getAttributesJson();

    const payload = {
      ...formData,
      name: formData.name ?? "",
      serviceType: formData.serviceType ?? "Other",
      attributes: attributesJson, // INJECT THE JSON STRING
    };
    // -------------------------------------------------------------

    const promise = isEditing
      ? apiClient.put(`/api/vendors/${editingId}`, payload)
      : apiClient.post("/api/vendors", payload);

    try {
      await promise;
      handleCancel();
      await fetchVendors();
    } catch (err: unknown) {
      if (axios.isAxiosError(err) && err.response?.status === 400) {
        setValidationErrors(
          err.response.data.errors || { General: ["Validation Error"] }
        );
      } else {
        console.error(err);
        alert("An unexpected error occurred.");
      }
    }
  };

  if (error) return <p style={{ color: "red" }}>{error}</p>;

  // --- NEW: Dynamic Field Renderer ---
  const renderDynamicFields = (serviceType: string | null | undefined) => {
    if (serviceType?.toLowerCase() === "venue") {
      return (
        <div style={{ marginBottom: "0.5rem" }}>
          <label>Venue Capacity: </label>
          <input
            name="Capacity"
            type="number"
            value={dynamicFields.Capacity ?? ""}
            onChange={handleDynamicChange}
            placeholder="Max Capacity (e.g., 500)"
            style={{
              width: "100%",
              padding: "8px",
              backgroundColor: "#333",
              color: "white",
              border: "1px solid #555",
            }}
          />
        </div>
      );
    }
    if (serviceType?.toLowerCase() === "entertainment") {
      return (
        <div style={{ marginBottom: "0.5rem" }}>
          <label>Artist Genre: </label>
          <input
            name="Genre"
            type="text"
            value={dynamicFields.Genre ?? ""}
            onChange={handleDynamicChange}
            placeholder="e.g., Jazz, EDM, Acoustic"
            style={{
              width: "100%",
              padding: "8px",
              backgroundColor: "#333",
              color: "white",
              border: "1px solid #555",
            }}
          />
        </div>
      );
    }
    return null;
  };

  const renderVendorListPanel = () => (
    <div
      style={{
        flex: "0 0 350px",
        padding: "1rem",
        borderRight: "1px solid #555",
        overflowY: "auto",
      }}>
      <h2>Vendors List</h2>
      <button
        onClick={() => {
          setEditingId(null);
          setFormData(initialFormState);
          setDynamicFields({}); // Ensure state is reset
          setSelectedVendorId(null);
        }}
        style={{ marginBottom: "1rem", padding: "10px" }}>
        + Add New Vendor
      </button>

      {loading ? (
        <p>Loading Vendors...</p>
      ) : (
        <ul style={{ listStyle: "none", padding: 0 }}>
          {vendors.map((vendor) => (
            <li
              key={vendor.id}
              onClick={() => setSelectedVendorId(vendor.id as Guid)}
              style={{
                padding: "10px",
                marginBottom: "5px",
                cursor: "pointer",
                border: "1px solid #555",
                backgroundColor:
                  vendor.id === selectedVendorId ? "#444" : "#2a2a2a",
                borderRadius: "4px",
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                color: "white",
              }}>
              <div>
                <strong>{vendor.name}</strong> <br />
                <span style={{ fontSize: "0.8rem", color: "#ccc" }}>
                  {vendor.serviceType}
                  {/* NEW: Display a dynamic attribute if present */}
                  {vendor.attributes &&
                    (() => {
                      try {
                        const attrs = JSON.parse(vendor.attributes);
                        if (attrs.Capacity)
                          return ` | Capacity: ${attrs.Capacity}`;
                        if (attrs.Genre) return ` | Genre: ${attrs.Genre}`;
                        return null;
                      } catch {
                        return null; // Ignore invalid JSON
                      }
                    })()}
                </span>
              </div>
              <div style={{ fontSize: "0.8rem" }}>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    handleEdit(vendor);
                  }}
                  style={{
                    color: "#64b5f6",
                    marginRight: "5px",
                    padding: "2px 5px",
                    background: "transparent",
                    border: "none",
                    cursor: "pointer",
                  }}>
                  Edit
                </button>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    handleDelete(vendor.id as Guid);
                  }}
                  style={{
                    color: "#ef5350",
                    padding: "2px 5px",
                    background: "transparent",
                    border: "none",
                    cursor: "pointer",
                  }}>
                  Delete
                </button>
              </div>
            </li>
          ))}
        </ul>
      )}
    </div>
  );

  const renderVendorDashboard = () => {
    if (isEditing || !selectedVendorId) {
      return (
        <div style={{ flex: 1, padding: "20px", overflowY: "auto" }}>
          <div
            style={{
              padding: "1rem",
              border: "1px solid #555",
              width: "100%",
            }}>
            <h2>
              {isEditing
                ? `Edit Vendor: ${selectedVendor?.name}`
                : "Create New Vendor"}
            </h2>
            <form onSubmit={handleSubmit}>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Name: </label>
                <input
                  name="name"
                  value={formData.name ?? ""}
                  onChange={handleChange}
                  style={{
                    width: "100%",
                    padding: "8px",
                    backgroundColor: "#333",
                    color: "white",
                    border: "1px solid #555",
                  }}
                />
                {validationErrors.Name && (
                  <div style={{ color: "#ef5350" }}>
                    {validationErrors.Name[0]}
                  </div>
                )}
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Email: </label>
                <input
                  name="email"
                  type="email"
                  value={formData.email ?? ""}
                  onChange={handleChange}
                  style={{
                    width: "100%",
                    padding: "8px",
                    backgroundColor: "#333",
                    color: "white",
                    border: "1px solid #555",
                  }}
                />
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Phone Number: </label>
                <input
                  name="phoneNumber"
                  value={formData.phoneNumber ?? ""}
                  onChange={handleChange}
                  style={{
                    width: "100%",
                    padding: "8px",
                    backgroundColor: "#333",
                    color: "white",
                    border: "1px solid #555",
                  }}
                />
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Service Type: </label>
                <select
                  name="serviceType"
                  value={formData.serviceType ?? "Other"}
                  onChange={handleChange}
                  style={{
                    width: "100%",
                    padding: "8px",
                    backgroundColor: "#333",
                    color: "white",
                    border: "1px solid #555",
                  }}>
                  {/* NOTE: Added Entertainment option as a requirement example */}
                  <option value="Catering">Catering</option>
                  <option value="Security">Security</option>
                  <option value="Venue">Venue</option>
                  <option value="Entertainment">Entertainment</option>
                  <option value="Florist">Florist</option>
                  <option value="Photography">Photography</option>
                  <option value="Videography">Videography</option>
                  <option value="Other">Other</option>
                </select>
              </div>

              {/* --- PHASE 27: Dynamic Attribute Fields RENDER HERE --- */}
              {renderDynamicFields(formData.serviceType)}

              {validationErrors.Attributes && (
                <div style={{ color: "#ef5350", marginTop: "0.5rem" }}>
                  {/* Display validation error for the JSON field */}
                  {validationErrors.Attributes[0]}
                </div>
              )}
              {/* -------------------------------------------------------- */}

              <button
                type="submit"
                style={{
                  marginTop: "10px",
                  padding: "10px 20px",
                  cursor: "pointer",
                }}>
                {isEditing ? "Save Changes" : "Create"}
              </button>
              {isEditing && (
                <button
                  type="button"
                  onClick={handleCancel}
                  style={{
                    marginLeft: "0.5rem",
                    marginTop: "10px",
                    padding: "10px 20px",
                    cursor: "pointer",
                  }}>
                  Cancel
                </button>
              )}
              {validationErrors.General && (
                <div style={{ color: "#ef5350", marginTop: "1rem" }}>
                  {validationErrors.General[0]}
                </div>
              )}
            </form>
          </div>
        </div>
      );
    }

    const vendorIdString = selectedVendorId as string;

    // --- PHASE 27: Dashboard View ---
    const parsedAttributes = selectedVendor?.attributes
      ? JSON.parse(selectedVendor.attributes)
      : {};

    const attributeDisplay = Object.entries(parsedAttributes).map(
      ([key, value]) => (
        <p key={key}>
          <strong>{key}:</strong> {value as string}
        </p>
      )
    );

    return (
      <div style={{ flex: 1, padding: "20px", overflowY: "auto" }}>
        <h1>Vendor Command Center: {selectedVendor?.name}</h1>
        <div
          style={{
            marginBottom: "20px",
            padding: "15px",
            border: "1px solid #555",
            borderRadius: "5px",
            width: "100%",
          }}>
          <h3>Details</h3>
          <p>
            <strong>ID:</strong> {selectedVendor?.id}
          </p>
          <p>
            <strong>Type:</strong> {selectedVendor?.serviceType}
          </p>
          <p>
            <strong>Contact Info:</strong> {selectedVendor?.phoneNumber} /{" "}
            {selectedVendor?.email}
          </p>
          {/* NEW: Dynamic Attribute Display */}
          {attributeDisplay.length > 0 && (
            <div
              style={{
                marginTop: "10px",
                borderTop: "1px dashed #666",
                paddingTop: "10px",
              }}>
              <h4>Specific Attributes</h4>
              {attributeDisplay}
            </div>
          )}
        </div>

        <h2 style={{ marginTop: "30px" }}>Related Data</h2>

        {/* NEW: Reusable Documents Section for Vendors */}
        <DocumentsSection entityId={vendorIdString} entityType="Vendor" />

        <VendorEventsTable vendorId={vendorIdString as Guid} />
        <RelatedTasks vendorId={vendorIdString} />
        <RelatedNotes vendorId={vendorIdString} />
      </div>
    );
  };

  return (
    <div style={{ display: "flex", height: "100%", minHeight: "800px" }}>
      {renderVendorListPanel()}
      {renderVendorDashboard()}
    </div>
  );
}

export default VendorsPage;


// =======================================================
// FILE: frontend_harness/src/components/NotesPage.tsx
// =======================================================
// FILE: frontend_harness/src/components/NotesPage.tsx

import { useState, useEffect, type FormEvent } from "react";
import { apiClient } from "../apiClient";
import { type NoteDto, type CreateNoteDto } from "../types";
import { AxiosError } from "axios";

// Define an explicit type for the data sent in the command,
// including the new lookup fields for clarity
type NoteCommandData = Omit<CreateNoteDto, "vendorName"> & {
  contactEmail?: string;
  eventName?: string;
  vendorName?: string; // This maps to the backend VendorName field in the command
  taskTitle?: string;
};

type UpdateNoteDto = Pick<NoteDto, "id" | "content">;

const NotesPage = () => {
  const [notes, setNotes] = useState<NoteDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Form state for creating a new note
  const initialNewNoteState: Partial<NoteCommandData> = {
    content: "",
    contactId: null,
    eventId: null,
    taskId: null,
    vendorId: null,
    // String lookup fields
    contactEmail: undefined,
    eventName: undefined,
    vendorName: undefined,
    taskTitle: undefined,
  };

  const [newNote, setNewNote] =
    useState<Partial<NoteCommandData>>(initialNewNoteState);

  // State for which note is being edited
  const [editingNote, setEditingNote] = useState<NoteDto | null>(null);

  // --- NEW: PHASE 29 Dynamic Linkage State ---
  const [entityTypeToLink, setEntityTypeToLink] = useState<
    "Contact" | "Event" | "Vendor" | "Task" | null
  >(null);
  const [linkValue, setLinkValue] = useState("");
  // ------------------------------------------

  const fetchNotes = async () => {
    try {
      setLoading(true);
      const response = await apiClient.get<NoteDto[]>("/api/notes");
      setNotes(response.data);
      setError(null);
    } catch (err) {
      setError("Failed to fetch notes.");
      console.error(err);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchNotes();
  }, []);

  // --- PHASE 29: Dynamic Linkage Handlers ---
  const handleEntityTypeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const type = e.target.value as
      | "Contact"
      | "Event"
      | "Vendor"
      | "Task"
      | "None";
    setEntityTypeToLink(type === "None" ? null : type);
    setLinkValue("");
    // Clear all previous link-related fields in newNote state
    setNewNote({
      ...newNote,
      contactId: null,
      eventId: null,
      taskId: null,
      vendorId: null,
      contactEmail: undefined,
      eventName: undefined,
      vendorName: undefined,
      taskTitle: undefined,
    });
  };

  const handleLinkValueChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setLinkValue(e.target.value);
  };

  const getLinkPlaceholder = () => {
    switch (entityTypeToLink) {
      case "Contact":
        return "Contact Email (e.g., jane@example.com)";
      case "Event":
        return "Event Name (e.g., Summer Gala 2026)";
      case "Vendor":
        return "Vendor Name (e.g., The Jazz Trio)";
      case "Task":
        return "Task Title (e.g., Book Venue)";
      default:
        return "Enter Name, Title, or Email";
    }
  };

  // --- PHASE 29: Payload Construction ---
  const constructCreatePayload = (): Partial<NoteCommandData> => {
    const payload: Partial<NoteCommandData> = {
      content: newNote.content,
    };

    if (entityTypeToLink === "Contact" && linkValue) {
      payload.contactEmail = linkValue;
    } else if (entityTypeToLink === "Event" && linkValue) {
      payload.eventName = linkValue;
    } else if (entityTypeToLink === "Vendor" && linkValue) {
      payload.vendorName = linkValue; // Maps to VendorName on backend command
    } else if (entityTypeToLink === "Task" && linkValue) {
      payload.taskTitle = linkValue;
    }
    // If IDs were manually put in (or if no dynamic link is selected,
    // they are sent as null/undefined, which is fine)

    return payload;
  };
  // ------------------------------------------

  const handleCreateSubmit = async (e: FormEvent) => {
    e.preventDefault();

    if (!newNote.content) {
      setError("Content is required.");
      return;
    }

    const payload = constructCreatePayload();

    try {
      // NOTE: We don't map string lookups to GUIDs on the FE. The FE only sends
      // the string values and the BE handler resolves them.
      const response = await apiClient.post<NoteDto>("/api/notes", payload);
      setNotes([response.data, ...notes]);

      setNewNote(initialNewNoteState); // Reset form
      setEntityTypeToLink(null);
      setLinkValue("");

      setError(null);
    } catch (err: unknown) {
      console.error(err);
      if (err instanceof AxiosError && err.response?.data?.errors) {
        // Find the 'Must Have At Least One Link' error and present it clearly
        const validationMessage = Object.values(err.response.data.errors)
          .flat()
          .join(", ");
        setError(
          validationMessage ||
            "Failed to create note. Ensure at least one ID is provided."
        );
      } else {
        setError("Failed to create note. Ensure at least one ID is provided.");
      }
    }
  };

  const handleUpdateSubmit = async (e: FormEvent) => {
    e.preventDefault();
    if (!editingNote) return;

    const updatePayload: UpdateNoteDto = {
      id: editingNote.id,
      content: editingNote.content,
    };
    try {
      await apiClient.put(`/api/notes/${editingNote.id}`, updatePayload);
      setNotes(notes.map((n) => (n.id === editingNote.id ? editingNote : n)));
      setEditingNote(null);
      setError(null);
    } catch (err: unknown) {
      console.error(err);
      setError("Failed to update note.");
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm("Are you sure you want to delete this note?")) {
      try {
        await apiClient.delete(`/api/notes/${id}`);
        setNotes(notes.filter((n) => n.id !== id));
        setError(null);
      } catch (err) {
        setError("Failed to delete note.");
        console.error(err);
      }
    }
  };

  // --- Render Logic ---

  if (loading) return <p>Loading notes...</p>;
  return (
    <div className="module-page">
      <h2>Notes Module</h2>
      {error && (
        <p className="error-message" style={{ color: "red" }}>
          {error}
        </p>
      )}

      {/* --- Create or Edit Form --- */}
      <form onSubmit={editingNote ? handleUpdateSubmit : handleCreateSubmit}>
        <h3>{editingNote ? "Edit Note" : "Create New Note"}</h3>
        <textarea
          placeholder="Note content..."
          value={editingNote ? editingNote.content : newNote.content}
          onChange={(e) =>
            editingNote
              ? setEditingNote({ ...editingNote, content: e.target.value })
              : setNewNote({ ...newNote, content: e.target.value })
          }
        />

        {/* --- Foreign Key Inputs (Dynamic Link for Create) --- */}
        {!editingNote && (
          <fieldset
            style={{
              border: "1px dashed #666",
              padding: "1rem",
              margin: "1rem 0",
            }}>
            <legend style={{ padding: "0 0.5rem" }}>
              Attach Note By ID or Lookup
            </legend>

            {/* Link Type Selector */}
            <div style={{ marginBottom: "0.5rem" }}>
              <label style={{ display: "block" }}>Link Type:</label>
              <select
                value={entityTypeToLink ?? "None"}
                onChange={handleEntityTypeChange}
                style={{ width: "100%", padding: "4px" }}>
                <option value="None">-- Select Entity Type --</option>
                <option value="Contact">Contact (by Email)</option>
                <option value="Event">Event (by Name)</option>
                <option value="Vendor">Vendor (by Name)</option>
                <option value="Task">Task (by Title)</option>
              </select>
            </div>

            {/* Lookup Value Input */}
            {entityTypeToLink && (
              <div style={{ marginBottom: "0.5rem" }}>
                <label style={{ display: "block" }}>Lookup Value:</label>
                <input
                  type={entityTypeToLink === "Contact" ? "email" : "text"}
                  value={linkValue}
                  onChange={handleLinkValueChange}
                  placeholder={getLinkPlaceholder()}
                  style={{ width: "100%" }}
                />
              </div>
            )}

            <p style={{ fontSize: "0.8rem", color: "#aaa", marginTop: "1rem" }}>
              *If you use the dropdown above, only the lookup value is sent. If
              you need to link by GUID, please use the Task/Vendor/Contact
              pages.
            </p>
          </fieldset>
        )}

        <button type="submit">
          {editingNote ? "Update Note" : "Create Note"}
        </button>
        {editingNote && (
          <button type="button" onClick={() => setEditingNote(null)}>
            Cancel Edit
          </button>
        )}
      </form>

      {/* --- Notes Table --- */}
      <h3>Existing Notes</h3>
      <table className="harness-table" style={{ width: "100%" }}>
        <thead>
          <tr>
            <th>ID</th>
            <th>Content</th>
            <th>Contact ID</th>
            <th>Event ID</th>
            <th>Task ID</th>
            <th>Vendor ID</th>
            <th>Vendor Name</th> {/* Granularity */}
            <th>Created At</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {notes.map((note) => (
            <tr key={note.id}>
              <td>{note.id.substring(0, 8)}...</td>
              <td>{note.content.substring(0, 50)}...</td>
              <td>
                {note.contactId
                  ? note.contactId.substring(0, 8) + "..."
                  : "N/A"}
              </td>
              <td>
                {note.eventId ? note.eventId.substring(0, 8) + "..." : "N/A"}
              </td>
              <td>
                {note.taskId ? note.taskId.substring(0, 8) + "..." : "N/A"}
              </td>
              <td>
                {note.vendorId ? note.vendorId.substring(0, 8) + "..." : "N/A"}
              </td>
              <td>{note.vendorName ?? "N/A"}</td>
              <td>{new Date(note.createdAt).toLocaleString()}</td>
              <td>
                <button
                  className="edit-button"
                  onClick={() => setEditingNote(note)}>
                  Edit
                </button>
                <button
                  className="delete-button"
                  onClick={() => handleDelete(note.id)}>
                  Delete
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

export default NotesPage;


// =======================================================
// FILE: frontend_harness/src/components/BudgetOverview.tsx
// =======================================================
import type { EventFinancials } from "../types";

interface Props {
  data: EventFinancials;
  onEditBudget: () => void;
}

export default function BudgetOverview({ data, onEditBudget }: Props) {
  // Color Logic: Green < 80%, Yellow < 100%, Red >= 100%
  const getProgressColor = () => {
    if (data.burnRate >= 1) return "bg-red-600";
    if (data.burnRate > 0.8) return "bg-yellow-500";
    return "bg-emerald-500";
  };

  const percentage = Math.min(data.burnRate * 100, 100);

  return (
    <div className="p-6 rounded-xl shadow-sm border border-gray-600 bg-[#333] text-white mb-8">
      {/* PHASE 26 ADDITION: BUDGET LOCK STATUS BANNER */}
      {data.isLocked ? (
        <div className="bg-red-900/50 border border-red-700 p-3 rounded-lg flex items-center mb-6">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 20 20"
            fill="currentColor"
            className="w-5 h-5 text-red-400 mr-3">
            <path
              fillRule="evenodd"
              d="M10 1a4.5 4.5 0 0 0-4.5 4.5V9H5a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2h-.5V5.5A4.5 4.5 0 0 0 10 1Zm3 8V5.5a3 3 0 1 0-6 0V9h6Z"
              clipRule="evenodd"
            />
          </svg>
          <span className="text-sm font-medium text-red-300">
            BUDGET LOCKED: Contract Signed. This budget cannot be edited.
          </span>
        </div>
      ) : (
        <div className="bg-emerald-900/50 border border-emerald-700 p-3 rounded-lg flex items-center mb-6">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 20 20"
            fill="currentColor"
            className="w-5 h-5 text-emerald-400 mr-3">
            <path d="M10 1a.75.75 0 0 1 .75.75V3a.75.75 0 1 1-1.5 0V1.75A.75.75 0 0 1 10 1ZM5.5 5.5a.75.75 0 0 0-1.5 0v2.75a.75.75 0 0 0 1.5 0V5.5ZM16 8.25a.75.75 0 0 1 1.5 0v-2.5a.75.75 0 0 1-1.5 0v2.5ZM5.5 12.5a.75.75 0 0 0-1.5 0v2.75a.75.75 0 0 0 1.5 0v-2.75ZM16 14.75a.75.75 0 0 1 1.5 0v-2.5a.75.75 0 0 1-1.5 0v2.5ZM10 6a4 4 0 0 1 4 4v.75c0 1.05.57 2.053 1.5 2.5a.75.75 0 0 1-.6 1.34c-1.288-.574-2.15-1.782-2.3-3.14h-1.3c-.15 1.358-1.012 2.566-2.3 3.14a.75.75 0 0 1-.6-1.34c.93-.447 1.5-1.45 1.5-2.5V10a4 4 0 0 1 4-4Z" />
          </svg>
          <span className="text-sm font-medium text-emerald-300">
            BUDGET UNLOCKED: Ready for updates.
          </span>
        </div>
      )}

      <div className="flex justify-between items-start mb-6">
        <div>
          <h3 className="text-xl font-bold text-white">Budget Overview</h3>
          <p className="text-sm text-gray-400 mt-1">{data.currency} Ledger</p>
        </div>
        <button
          onClick={onEditBudget}
          disabled={data.isLocked} // DISABLES BUTTON WHEN LOCKED
          className={`px-3 py-1 text-sm rounded transition-colors ${
            data.isLocked
              ? "bg-gray-800 text-gray-500 cursor-not-allowed border border-gray-700"
              : "bg-gray-700 hover:bg-gray-600 text-white border border-gray-500"
          }`}>
          {data.isLocked ? "Budget Locked" : "Edit Budget"}
        </button>
      </div>

      {/* Stat Cards */}
      <div className="grid grid-cols-3 gap-6 mb-8">
        <div className="p-4 bg-[#444] rounded-lg border border-gray-600">
          <p className="text-xs text-gray-400 uppercase tracking-wider mb-1">
            Total Budget
          </p>
          <p className="text-2xl font-bold text-white">
            ${data.budgetTotal.toLocaleString()}
          </p>
        </div>
        <div className="p-4 bg-[#444] rounded-lg border border-gray-600">
          <p className="text-xs text-gray-400 uppercase tracking-wider mb-1">
            Spent
          </p>
          <p className="text-2xl font-bold text-white">
            ${data.totalSpent.toLocaleString()}
          </p>
        </div>
        <div className="p-4 bg-[#444] rounded-lg border border-gray-600">
          <p className="text-xs text-gray-400 uppercase tracking-wider mb-1">
            Remaining
          </p>
          <p
            className={`text-2xl font-bold ${
              data.remainingBudget < 0 ? "text-red-400" : "text-emerald-400"
            }`}>
            ${data.remainingBudget.toLocaleString()}
          </p>
        </div>
      </div>

      {/* Progress Bar Section */}
      <div className="relative pt-1">
        <div className="flex mb-2 items-center justify-between text-sm">
          <span className="font-semibold uppercase tracking-wide text-gray-300">
            Burn Rate
          </span>
          <span className="font-bold text-white">
            {Math.round(data.burnRate * 100)}%
          </span>
        </div>
        <div className="overflow-hidden h-3 mb-4 text-xs flex rounded-full bg-gray-700 border border-gray-600">
          <div
            style={{ width: `${percentage}%` }}
            className={`shadow-none flex flex-col text-center whitespace-nowrap text-white justify-center ${getProgressColor()} transition-all duration-500`}></div>
        </div>
      </div>

      {data.notes && (
        <div className="mt-4 text-sm text-gray-400 italic border-l-4 border-gray-500 pl-3">
          "{data.notes}"
        </div>
      )}
    </div>
  );
}


// =======================================================
// FILE: frontend_harness/src/components/TasksPage.tsx
// =======================================================
// FILE: frontend_harness/src/components/TasksPage.tsx (COMPLETE FILE)

import { useEffect, useState } from "react";
import { apiClient } from "../apiClient";
import type { TaskDto } from "../types";
import axios from "axios";

// Define an explicit type for the data sent in the command,
// including the new lookup fields for clarity
type TaskCommandData = Omit<TaskDto, "id" | "createdAt" | "vendorName"> & {
  contactEmail?: string;
  eventName?: string;
  vendorName?: string; // This maps to the backend VendorName field in the command
};
type ValidationErrors = { [key: string]: string[] };

function TasksPage() {
  const [tasks, setTasks] = useState<TaskDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const initialFormState: Partial<TaskCommandData> = {
    title: "",
    description: null,
    status: "NotStarted", // Default enum string
    priority: "Medium", // Default enum string
    dueDate: null,
    // Original GUID fields (cleared for the form but used in DTO)
    contactId: null,
    eventId: null,
    vendorId: null,
    // String lookup fields
    contactEmail: undefined,
    eventName: undefined,
    vendorName: undefined,
  };

  const [formData, setFormData] =
    useState<Partial<TaskCommandData>>(initialFormState);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<ValidationErrors>(
    {}
  );

  // --- NEW: PHASE 29 Dynamic Linkage State ---
  const [entityTypeToLink, setEntityTypeToLink] = useState<
    "Contact" | "Event" | "Vendor" | null
  >(null);
  const [linkValue, setLinkValue] = useState("");
  // ------------------------------------------

  const isEditing = editingId !== null;

  const fetchTasks = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiClient.get<TaskDto[]>("/api/tasks");
      setTasks(response.data);
    } catch (err: unknown) {
      console.error(err);
      setError("Failed to fetch tasks.");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchTasks();
  }, []);

  const handleDelete = async (id: string) => {
    if (!window.confirm("Are you sure you want to delete this task?")) return;
    try {
      await apiClient.delete(`/api/tasks/${id}`);
      await fetchTasks();
    } catch (err) {
      console.error(err);
      alert("Failed to delete task.");
    }
  };

  const handleEdit = (task: TaskDto) => {
    setEditingId(task.id);

    // Clear dynamic link state when editing, as the fields are GUID-based on update
    setEntityTypeToLink(null);
    setLinkValue("");

    // Format date for date input
    setFormData({
      ...task,
      dueDate: task.dueDate ? task.dueDate.slice(0, 10) : null,
      vendorId: task.vendorId ?? null,
      contactId: task.contactId ?? null,
      eventId: task.eventId ?? null,
      // Clear string lookup fields when editing an existing task by ID
      contactEmail: undefined,
      eventName: undefined,
      vendorName: undefined,
    });
    setValidationErrors({});
    window.scrollTo(0, 0);
  };

  const handleCancel = () => {
    setEditingId(null);
    setFormData(initialFormState);
    setEntityTypeToLink(null); // Reset link state
    setLinkValue(""); // Reset link value
    setValidationErrors({});
  };

  const handleChange = (
    e: React.ChangeEvent<
      HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement
    >
  ) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value === "" ? null : value,
    }));
  };

  // --- PHASE 29: Dynamic Linkage Handler ---
  const handleEntityTypeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const type = e.target.value as "Contact" | "Event" | "Vendor" | "None";
    setEntityTypeToLink(type === "None" ? null : type);
    setLinkValue("");
    // Clear all previous link-related fields in formData to prevent conflicts
    setFormData({
      ...formData,
      contactId: null,
      eventId: null,
      vendorId: null,
      contactEmail: undefined,
      eventName: undefined,
      vendorName: undefined,
    });
  };

  const handleLinkValueChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setLinkValue(e.target.value);
  };

  // --- PHASE 29: Payload Construction ---
  const constructPayload = (
    baseData: Partial<TaskCommandData>
  ): TaskCommandData => {
    const payload: Partial<TaskCommandData> = {
      ...baseData,
      description: baseData.description ?? null,
      dueDate: baseData.dueDate ?? null,
    };

    // If we are editing, we submit the GUIDs (contactId, eventId, etc.)
    // already present in formData, and string fields are undefined.
    if (isEditing) {
      return payload as TaskCommandData;
    }

    // If creating, we inject the dynamic linkage values into the string lookup fields.
    // GUID fields are null, string fields hold the lookup value.
    if (entityTypeToLink === "Contact" && linkValue) {
      payload.contactEmail = linkValue;
      payload.contactId = null; // Ensure ID is null
    } else if (entityTypeToLink === "Event" && linkValue) {
      payload.eventName = linkValue;
      payload.eventId = null; // Ensure ID is null
    } else if (entityTypeToLink === "Vendor" && linkValue) {
      payload.vendorName = linkValue; // Maps to VendorName on backend command
      payload.vendorId = null; // Ensure ID is null
    }

    return payload as TaskCommandData;
  };
  // ------------------------------------------

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setValidationErrors({});

    const payload = constructPayload(formData);

    const promise = isEditing
      ? apiClient.put(`/api/tasks/${editingId}`, payload)
      : apiClient.post("/api/tasks", payload);

    try {
      await promise;
      handleCancel();
      await fetchTasks();
    } catch (err: unknown) {
      if (axios.isAxiosError(err) && err.response?.status === 400) {
        setValidationErrors(
          err.response.data.errors || { General: ["Validation Error"] }
        );
      } else {
        console.error(err);
        alert("An unexpected error occurred.");
      }
    }
  };

  if (error) return <p style={{ color: "red" }}>{error}</p>;

  // Helper to determine the placeholder text
  const getLinkPlaceholder = () => {
    switch (entityTypeToLink) {
      case "Contact":
        return "Contact Email (e.g., jane@example.com)";
      case "Event":
        return "Event Name (e.g., Summer Gala 2026)";
      case "Vendor":
        return "Vendor Name (e.g., The Jazz Trio)";
      default:
        return "Enter ID, Name, or Email";
    }
  };

  return (
    <div>
      <div
        style={{
          marginBottom: "2rem",
          padding: "1rem",
          border: "1px solid #555",
        }}>
        <h2>{isEditing ? "Edit Task" : "Create Task"}</h2>
        <form onSubmit={handleSubmit}>
          {/* Form fields */}
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Title: </label>
            <input
              name="title"
              value={formData.title ?? ""}
              onChange={handleChange}
            />
            {validationErrors.Title && (
              <div style={{ color: "red" }}>{validationErrors.Title[0]}</div>
            )}
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Description: </label>
            <textarea
              name="description"
              value={formData.description ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Due Date: </label>
            <input
              name="dueDate"
              type="date"
              value={formData.dueDate ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Status: </label>
            <select
              name="status"
              value={formData.status ?? "NotStarted"}
              onChange={handleChange}>
              <option value="NotStarted">Not Started</option>
              <option value="InProgress">In Progress</option>
              <option value="Completed">Completed</option>
            </select>
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Priority: </label>
            <select
              name="priority"
              value={formData.priority ?? "Medium"}
              onChange={handleChange}>
              <option value="Low">Low</option>
              <option value="Medium">Medium</option>
              <option value="High">High</option>
            </select>
          </div>

          {/* --- PHASE 29: DYNAMIC LINKING SECTION --- */}
          {!isEditing && (
            <div
              style={{
                margin: "1rem 0",
                padding: "1rem",
                border: "1px dashed #666",
                borderRadius: "4px",
              }}>
              <h4 style={{ marginTop: 0 }}>
                Link Task To: (Name or Email Lookup)
              </h4>
              <div style={{ marginBottom: "0.5rem" }}>
                <label style={{ display: "block" }}>Link Type:</label>
                <select
                  value={entityTypeToLink ?? "None"}
                  onChange={handleEntityTypeChange}
                  style={{ width: "100%", padding: "4px" }}>
                  <option value="None">-- Select Entity Type --</option>
                  <option value="Contact">Contact (by Email)</option>
                  <option value="Event">Event (by Name)</option>
                  <option value="Vendor">Vendor (by Name)</option>
                </select>
              </div>
              {entityTypeToLink && (
                <div style={{ marginBottom: "0.5rem" }}>
                  <label style={{ display: "block" }}>Lookup Value:</label>
                  <input
                    type={entityTypeToLink === "Contact" ? "email" : "text"}
                    value={linkValue}
                    onChange={handleLinkValueChange}
                    placeholder={getLinkPlaceholder()}
                    style={{ width: "100%" }}
                  />
                </div>
              )}
            </div>
          )}

          {/* --- LEGACY GUID INPUTS (Hidden on Create, Used on Edit) --- */}
          {/* On Edit mode, we submit the existing GUIDs. */}
          {/* NOTE: We only display the GUIDs on edit if you need to change the parent via GUID */}
          {isEditing && (
            <>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Contact ID (Optional): </label>
                <input
                  name="contactId"
                  value={formData.contactId ?? ""}
                  onChange={handleChange}
                />
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Event ID (Optional): </label>
                <input
                  name="eventId"
                  value={formData.eventId ?? ""}
                  onChange={handleChange}
                />
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Vendor ID (Optional): </label>
                <input
                  name="vendorId"
                  value={formData.vendorId ?? ""}
                  onChange={handleChange}
                />
              </div>
            </>
          )}
          {/* ---------------------------------------------------- */}

          {validationErrors.General && (
            <div style={{ color: "red", marginTop: "1rem" }}>
              {validationErrors.General[0]}
            </div>
          )}

          <button type="submit">{isEditing ? "Save Changes" : "Create"}</button>
          {isEditing && (
            <button
              type="button"
              onClick={handleCancel}
              style={{ marginLeft: "0.5rem" }}>
              Cancel
            </button>
          )}
        </form>
      </div>

      <h2>Tasks List</h2>
      {loading ? (
        <p>Loading Tasks...</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Title</th>
              <th>Status</th>
              <th>Priority</th>
              <th>Due Date</th>
              <th>Vendor</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {tasks.map((task) => (
              <tr key={task.id}>
                <td>{task.id}</td>
                <td>{task.title}</td>
                <td>{task.status}</td>
                <td>{task.priority}</td>
                <td>
                  {task.dueDate
                    ? new Date(task.dueDate).toLocaleDateString()
                    : "N/A"}
                </td>
                <td>{task.vendorName ?? "N/A"}</td>
                <td>
                  <button
                    onClick={() => handleEdit(task)}
                    style={{ color: "blue" }}>
                    Edit
                  </button>
                  <button
                    onClick={() => handleDelete(task.id)}
                    style={{ color: "red", marginLeft: "0.5rem" }}>
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

export default TasksPage;


// =======================================================
// FILE: frontend_harness/src/components/RelatedTables.tsx
// =======================================================
import { useEffect, useState } from "react";
import { useSelectionContext } from "../context/useSelectionContext";
import { apiClient } from "../apiClient";
import type {
  TaskDto,
  NoteDto,
  EventDto,
  ContactDto,
  Guid,
  EmailLogDto,
} from "../types";

// Add vendorId to the props of the related tables
interface RelatedTableProps {
  contactId?: Guid | null;
  eventId?: Guid | null;
  vendorId?: Guid | null;
}

// --- Utility function to determine the API path and selection ID ---
const getApiContext = (
  props: RelatedTableProps,
  selectedContactId: Guid | null,
  selectedEventId: Guid | null,
  resource: "tasks" | "notes"
) => {
  // 1. Check for explicit props (used by Command Centers)
  if (props.vendorId) {
    return {
      id: props.vendorId,
      url: `/api/${resource}?vendorId=${props.vendorId}`,
      label: "Vendor",
    };
  }
  if (props.contactId) {
    return {
      id: props.contactId,
      url: `/api/${resource}?contactId=${props.contactId}`,
      label: "Contact",
    };
  }
  if (props.eventId) {
    return {
      id: props.eventId,
      url: `/api/${resource}?eventId=${props.eventId}`,
      label: "Event",
    };
  }

  // 2. Fall back to context (used by old pages/global lists)
  if (selectedContactId) {
    return {
      id: selectedContactId,
      url: `/api/${resource}?contactId=${selectedContactId}`,
      label: "Contact",
    };
  }
  if (selectedEventId) {
    return {
      id: selectedEventId,
      url: `/api/${resource}?eventId=${selectedEventId}`,
      label: "Event",
    };
  }
  return { id: null, url: null, label: null };
};

// --- 1. RelatedTasks ---
export function RelatedTasks(props: RelatedTableProps) {
  const { selectedContactId, selectedEventId } = useSelectionContext();
  const [tasks, setTasks] = useState<TaskDto[]>([]);
  const [loading, setLoading] = useState(false);

  const context = getApiContext(
    props,
    selectedContactId,
    selectedEventId,
    "tasks"
  );
  const selectedId = context.id;
  const apiUrl = context.url;
  const contextLabel = context.label;

  useEffect(() => {
    if (!selectedId || !apiUrl) {
      setTasks([]);
      return;
    }

    const fetchTasks = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<TaskDto[]>(apiUrl);
        setTasks(response.data);
      } catch (err) {
        console.error("Failed to fetch related tasks:", err);
      } finally {
        setLoading(false);
      }
    };

    fetchTasks();
  }, [selectedId, apiUrl]);

  if (!selectedId) return null;
  if (loading) return <p>Loading related tasks...</p>;

  const safeContextLabel = contextLabel as string;

  return (
    <div style={{ marginTop: "2rem" }}>
      {/* FIX: Show Full ID */}
      <h3>
        Related Tasks (for {safeContextLabel} ID: {selectedId})
      </h3>
      {tasks.length === 0 ? (
        <p>No tasks found for this {safeContextLabel.toLowerCase()}.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Title</th>
              <th>Status</th>
              <th>Due Date</th>
              <th>Linked Vendor</th> {/* NEW COLUMN HEADER */}
              <th>Linked Contact</th> {/* NEW COLUMN HEADER */}
              <th>Linked Event</th> {/* NEW COLUMN HEADER */}
            </tr>
          </thead>
          <tbody>
            {tasks.map((task) => (
              <tr key={task.id}>
                {/* FIX: Show Full ID (Shortened for space) */}
                <td>{task.id.substring(0, 8)}...</td>
                <td>{task.title}</td>
                <td>{task.status}</td>
                <td>
                  {task.dueDate
                    ? new Date(task.dueDate).toLocaleDateString()
                    : "N/A"}
                </td>
                {/* PHASE 28: Vendor Granularity */}
                <td>
                  {task.vendorName ??
                    (task.vendorId
                      ? `ID: ${task.vendorId.substring(0, 8)}...`
                      : "N/A")}
                </td>
                {/* PHASE 28: Contact/Event Granularity */}
                <td>
                  {task.contactId
                    ? `ID: ${task.contactId.substring(0, 8)}...`
                    : "N/A"}
                </td>
                <td>
                  {task.eventId
                    ? `ID: ${task.eventId.substring(0, 8)}...`
                    : "N/A"}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

// --- 2. RelatedNotes ---
export function RelatedNotes(props: RelatedTableProps) {
  const { selectedContactId, selectedEventId } = useSelectionContext();
  const [notes, setNotes] = useState<NoteDto[]>([]);
  const [loading, setLoading] = useState(false);

  const context = getApiContext(
    props,
    selectedContactId,
    selectedEventId,
    "notes"
  );
  const selectedId = context.id;
  const apiUrl = context.url;
  const contextLabel = context.label;

  useEffect(() => {
    if (!selectedId || !apiUrl) {
      setNotes([]);
      return;
    }

    const fetchNotes = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<NoteDto[]>(apiUrl);
        setNotes(response.data);
      } catch (err) {
        console.error("Failed to fetch related notes:", err);
      } finally {
        setLoading(false);
      }
    };

    fetchNotes();
  }, [selectedId, apiUrl]);

  if (!selectedId) return null;
  if (loading) return <p>Loading related notes...</p>;

  const safeContextLabel = contextLabel as string;

  return (
    <div style={{ marginTop: "2rem" }}>
      {/* FIX: Show Full ID */}
      <h3>
        Related Notes (for {safeContextLabel} ID: {selectedId})
      </h3>
      {notes.length === 0 ? (
        <p>No notes found for this {safeContextLabel.toLowerCase()}.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Content</th>
              <th>Linked Vendor</th> {/* NEW COLUMN HEADER */}
              <th>Linked Contact</th> {/* NEW COLUMN HEADER */}
              <th>Linked Event</th> {/* NEW COLUMN HEADER */}
            </tr>
          </thead>
          <tbody>
            {notes.map((note) => (
              <tr key={note.id}>
                {/* FIX: Show Full ID (Shortened for space) */}
                <td>{note.id.substring(0, 8)}...</td>
                <td>{note.content}</td>
                {/* PHASE 28: Vendor Granularity */}
                <td>
                  {note.vendorName ??
                    (note.vendorId
                      ? `ID: ${note.vendorId.substring(0, 8)}...`
                      : "N/A")}
                </td>
                {/* PHASE 28: Contact/Event Granularity */}
                <td>
                  {note.contactId
                    ? `ID: ${note.contactId.substring(0, 8)}...`
                    : "N/A"}
                </td>
                <td>
                  {note.eventId
                    ? `ID: ${note.eventId.substring(0, 8)}...`
                    : "N/A"}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

// --- 3. ContactEventsTable ---
export function ContactEventsTable() {
  const { selectedContactId } = useSelectionContext();
  const [events, setEvents] = useState<EventDto[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (!selectedContactId) {
      setEvents([]);
      return;
    }

    const fetchEvents = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<EventDto[]>(
          `/api/contacts/${selectedContactId}/events`
        );
        setEvents(response.data);
      } catch (err) {
        console.error("Failed to fetch contact's events:", err);
      } finally {
        setLoading(false);
      }
    };

    fetchEvents();
  }, [selectedContactId]);

  if (!selectedContactId) return null;
  if (loading) return <p>Loading related events...</p>;

  return (
    <div style={{ marginTop: "2rem" }}>
      {/* FIX: Show Full ID */}
      <h3>Related Events (for Contact ID: {selectedContactId})</h3>
      {events.length === 0 ? (
        <p>No events found linked to this contact.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Name</th>
              <th>Status</th>
              <th>Start</th>
              <th>Location</th>
            </tr>
          </thead>
          <tbody>
            {events.map((event) => (
              <tr key={event.id}>
                {/* FIX: Show Full ID */}
                <td>{event.id}</td>
                <td>{event.name}</td>
                <td>{event.status}</td>
                <td>{new Date(event.startDateTime).toLocaleString()}</td>
                <td>{event.location ?? "N/A"}</td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

// --- 4. EventParticipantsTable ---
interface EventParticipantsTableProps {
  onUnlinkSuccess: () => void;
}

export function EventParticipantsTable({
  onUnlinkSuccess,
}: EventParticipantsTableProps) {
  const { selectedEventId } = useSelectionContext();
  const [contacts, setContacts] = useState<ContactDto[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    const fetchContacts = async () => {
      if (!selectedEventId) {
        setContacts([]);
        return;
      }
      setLoading(true);
      try {
        const response = await apiClient.get<ContactDto[]>(
          `/api/events/${selectedEventId}/contacts`
        );
        setContacts(response.data);
      } catch (err) {
        console.error("Failed to fetch event participants:", err);
      } finally {
        setLoading(false);
      }
    };

    fetchContacts();
  }, [selectedEventId]);

  const handleUnlink = async (contactId: string) => {
    if (!selectedEventId) return;
    if (
      !window.confirm(
        "Are you sure you want to remove this contact from the event?"
      )
    )
      return;

    try {
      await apiClient.delete(
        `/api/events/${selectedEventId}/contacts/${contactId}`
      );
      onUnlinkSuccess();
    } catch (err) {
      console.error("Failed to unlink contact:", err);
      alert("Failed to unlink contact.");
    }
  };

  if (!selectedEventId) return null;
  if (loading) return <p>Loading event participants...</p>;

  return (
    <div style={{ marginTop: "2rem" }}>
      <h3>Event Participants (Staff/Guests)</h3>
      {contacts.length === 0 ? (
        <p>No participants linked to this event.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>First Name</th>
              <th>Last Name</th>
              <th>Email</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {contacts.map((contact) => (
              <tr key={contact.id}>
                {/* FIX: Show Full ID */}
                <td>{contact.id}</td>
                <td>{contact.firstName}</td>
                <td>{contact.lastName}</td>
                <td>{contact.email}</td>
                <td>
                  <button
                    onClick={() => handleUnlink(contact.id)}
                    style={{ color: "red", cursor: "pointer" }}>
                    Unlink
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

// --- 5. EmailHistoryTable ---
export function EmailHistoryTable() {
  const { selectedContactId } = useSelectionContext();
  const [logs, setLogs] = useState<EmailLogDto[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (!selectedContactId) {
      setLogs([]);
      return;
    }

    const fetchLogs = async () => {
      setLoading(true);
      try {
        const res = await apiClient.get<EmailLogDto[]>(
          `/api/contacts/${selectedContactId}/email-logs`
        );
        setLogs(res.data);
      } catch (err) {
        console.error("Failed to fetch email logs", err);
      } finally {
        setLoading(false);
      }
    };

    fetchLogs();
  }, [selectedContactId]);

  if (!selectedContactId) return null;

  return (
    <div style={{ marginTop: "2rem" }}>
      <h3>Email History (for Contact ID: {selectedContactId})</h3>
      {loading ? (
        <p>Loading logs...</p>
      ) : logs.length === 0 ? (
        <p>No emails sent to this contact.</p>
      ) : (
        <table
          border={1}
          cellPadding={5}
          style={{ width: "100%", borderCollapse: "collapse" }}>
          <thead>
            <tr style={{ background: "#333", color: "#fff" }}>
              <th>Subject</th>
              <th>Sent At</th>
              <th>Status</th>
              <th>Message</th>
            </tr>
          </thead>
          <tbody>
            {logs.map((log) => (
              <tr key={log.id}>
                <td>{log.subject}</td>
                <td>{new Date(log.sentAt).toLocaleString()}</td>
                <td
                  style={{
                    color: log.isSuccess ? "lightgreen" : "#ff6b6b",
                    fontWeight: "bold",
                  }}>
                  {log.isSuccess ? "Success" : "Failed"}
                </td>
                <td
                  style={{
                    maxWidth: "300px",
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    whiteSpace: "nowrap",
                  }}>
                  {log.errorMessage ? log.errorMessage : "Sent via SendGrid"}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

export default function RelatedTables() {
  return (
    <div>
      <RelatedTasks />
      <RelatedNotes />
    </div>
  );
}


// =======================================================
// FILE: frontend_harness/src/components/DashboardPage.tsx
// =======================================================
// FILE: frontend_harness/src/components/DashboardPage.tsx (FINALIZED, COMPLETE)

import { useEffect, useState, useCallback } from "react";
// Removed deleteContact from the top level import to resolve the unused warning.
import {
  apiClient,
  updateContact,
  updateVendor,
  updateEvent,
  submitLead,
  // FIX: scheduleFollowUp removed, using apiClient.post directly
  deleteContact as deleteContactClient, // Use the renamed client here
  initializeTestFixtures, // NEW: For Phase 40 Data Setup
} from "../apiClient";
import { SendEmailModal } from "./SendEmailModal";
// FIX 1: Ensure all necessary types are imported.
import type {
  DashboardStatsDto,
  ContactDto,
  VendorDto,
  EventDto,
  SubmitLeadCommand,
} from "../types";
import { LeadStage, RecipientType } from "../types";

// --- GUID DEFINITIONS ---
const VALID_TEMPLATE_GUID = "8efe1c11-0d4d-49ef-9463-195e6e2bcda5";
// This GUID must match the hardcoded ID in CurrentUserService.cs for the test to see data.
const MOCK_USER_ID = "11111111-2222-3333-4444-555555555555";
// --------------------------------------------------------------------------

// Expected response structure for schedule-followup (Replaces 'any')
interface ScheduleFollowUpResponse {
  jobId: string;
  message: string;
}

// --- NEW SUB-COMPONENT: TestExecutionPanel (PHASE 31) ---
// Define explicit interface for props
interface TestExecutionPanelProps {
  contacts: ContactDto[];
  vendors: VendorDto[];
  events: EventDto[];
  logTestResult: (
    message: string,
    level: "PASS" | "FAIL" | "INFO" | "WARN"
  ) => void;
}

const TestExecutionPanel: React.FC<TestExecutionPanelProps> = ({
  contacts,
  vendors,
  events,
  logTestResult,
}) => {
  const runAllTests = useCallback(() => {
    // Removed 'async' from declaration, moved to where awaited.
    const output = document.getElementById("test-log-output");
    if (output) output.innerHTML = ""; // Clear log on start

    // Calculate entities based on current props (to satisfy linter/compiler)
    const testContact = contacts[0];
    const testVendor =
      vendors.find((v: VendorDto) => v.serviceType === "Catering") ||
      vendors[0];
    const testEvent = events[0];

    logTestResult("Starting CRUD Test Suite...", "INFO");

    if (!testContact || !testVendor || !testEvent) {
      logTestResult(
        "Skipping CRUD tests: Insufficient initial data (need Contact, Vendor, Event).",
        "WARN"
      );
      return;
    }

    // --- 1. LEAD SUBMISSION TEST (POST /leads/submit) ---
    const executeLeadSubmission = async () => {
      let createdLeadId: string | null = null;
      try {
        const leadCommand: SubmitLeadCommand = {
          firstName: "Auto",
          lastName: "Lead",
          email: `auto_lead_${Date.now()}@test.com`,
          source: "Dashboard Test Harness",
        };
        createdLeadId = await submitLead(leadCommand);
        logTestResult(
          `POST /leads/submit: SUCCESS. New Lead ID: ${createdLeadId.substring(
            0,
            8
          )}...`,
          "PASS"
        );
        return createdLeadId; // Return ID for cleanup later
      } catch (e: unknown) {
        logTestResult(
          `POST /leads/submit: FAILED. Error: ${(e as Error).message}`,
          "FAIL"
        );
        return null;
      }
    };

    // --- 2. CONTACT UPDATE TEST (PUT /contacts/{id}) ---
    const executeContactUpdate = async () => {
      try {
        // FIX 1: Spread the entire contact DTO to satisfy NotEmpty() validation for Name, Email, etc.
        const contactPayload = {
          ...testContact,
          lastName: `Updated-${Date.now().toString().slice(-4)}`,
          stage: LeadStage.InDiscussion,
        };

        await updateContact(testContact.id, contactPayload);
        logTestResult(
          `PUT /contacts/${testContact.id.substring(
            0,
            8
          )}...: SUCCESS (Update Contact Name)`,
          "PASS"
        );
      } catch (e: unknown) {
        logTestResult(
          `PUT /contacts: FAILED. Error: ${(e as Error).message}`,
          "FAIL"
        );
      }
    };

    // --- 3. VENDOR UPDATE TEST (PUT /vendors/{id}) ---
    const executeVendorUpdate = async () => {
      try {
        // FIX 2: Spread the entire vendor DTO to satisfy NotEmpty() and JSONB validation
        const vendorPayload = {
          ...testVendor,
          email: `updated_vendor_${Date.now().toString().slice(-4)}@test.com`,
          // CRITICAL: Ensure attributes are explicitly passed, even if null/empty string
          attributes: testVendor.attributes || null,
        };

        await updateVendor(testVendor.id, vendorPayload);
        logTestResult(
          `PUT /vendors/${testVendor.id.substring(
            0,
            8
          )}...: SUCCESS (Update Vendor Email)`,
          "PASS"
        );
      } catch (e: unknown) {
        logTestResult(
          `PUT /vendors: FAILED. Error: ${(e as Error).message}`,
          "FAIL"
        );
      }
    };

    // --- 4. EVENT UPDATE TEST (PUT /events/{id}) ---
    const executeEventUpdate = async () => {
      try {
        // FIX 3: Spread the entire event DTO to satisfy date validation (End > Start)
        const eventPayload = {
          ...testEvent,
          description: `Tested by Harness at ${new Date().toLocaleTimeString()}`,
        };

        await updateEvent(testEvent.id, eventPayload);
        logTestResult(
          `PUT /events/${testEvent.id.substring(
            0,
            8
          )}...: SUCCESS (Update Event Description)`,
          "PASS"
        );
      } catch (e: unknown) {
        logTestResult(
          `PUT /events: FAILED. Error: ${(e as Error).message}`,
          "FAIL"
        );
      }
    };

    // --- 5. SCHEDULE FOLLOW-UP TEST (POST /automation/schedule-followup) ---
    const executeScheduleFollowUp = async () => {
      try {
        // Uses the VALID_TEMPLATE_GUID constant defined at the top
        const scheduleTime = new Date(Date.now() + 60000).toISOString();

        // FIX 5: Explicitly type the response and extract jobId property
        const response = await apiClient.post<ScheduleFollowUpResponse>(
          "/api/automation/schedule-followup",
          {
            contactId: testContact.id,
            templateId: VALID_TEMPLATE_GUID,
            scheduleTime: scheduleTime,
            type: RecipientType.Contact,
          }
        );

        const jobId = response.data.jobId;

        logTestResult(
          `POST /automation/schedule-followup: SUCCESS. Job ID: ${jobId.substring(
            0,
            8
          )}...`,
          "PASS"
        );
      } catch (e: unknown) {
        logTestResult(
          `POST /automation/schedule-followup: FAILED. Error: ${
            (e as Error).message
          }`,
          "FAIL"
        );
      }
    };

    // --- EXECUTION SEQUENCE ---
    const runSequence = async () => {
      const leadId = await executeLeadSubmission();
      await executeContactUpdate();
      await executeVendorUpdate();
      await executeEventUpdate();
      await executeScheduleFollowUp();

      // --- CLEANUP (Delete Auto Lead) ---
      try {
        // Use the createdLeadId from step 1
        const contactsAfterTest = (
          await apiClient.get<ContactDto[]>("/api/contacts")
        ).data;
        const createdLead = contactsAfterTest.find(
          (c) => c.firstName === "Auto" && c.lastName === "Lead"
        );

        const idToClean = leadId || createdLead?.id;

        if (idToClean) {
          // Use the client imported as deleteContactClient
          await deleteContactClient(idToClean);
          logTestResult(
            `DELETE /contacts: SUCCESS (Cleaned up Auto Lead ${idToClean.substring(
              0,
              8
            )}...)`,
            "PASS"
          );
        }
      } catch (e: unknown) {
        logTestResult(
          `CLEANUP DELETE FAILED. Error: ${(e as Error).message}`,
          "WARN"
        );
      }

      logTestResult("CRUD Test Suite Finished.", "INFO");
    };

    runSequence();
  }, [contacts, vendors, events, logTestResult]);

  // --- NEW: PHASE 39 ADVANCED TEST FUNCTION ---
  const runAdvancedTests = useCallback(async () => {
    logTestResult("Starting Advanced Feature Audit...", "INFO");

    // We rely on the first contact, vendor, and event being present for reporting tests
    const testContact = contacts[0];
    const testVendor = vendors.find((v) => v.email !== null) || vendors[0];
    const testEvent = events[0];

    if (!testContact || !testVendor || !testEvent) {
      logTestResult(
        "Skipping Advanced tests: Insufficient initial data.",
        "WARN"
      );
      return;
    }

    let ownedContactId: string | null = null;

    // -----------------------------------------------------------
    // AUDIT 1: SCOPED AUTHORIZATION AND VISIBILITY (PHASE 37)
    // -----------------------------------------------------------
    logTestResult("AUDIT 1: Scoped Authorization Check...", "INFO");

    // 1A. Create a Contact (This contact should be owned by MOCK_USER_ID)
    try {
      const leadCommand: SubmitLeadCommand = {
        firstName: "Scoped",
        lastName: "Owner",
        email: `scoped_test_${Date.now()}@test.com`,
        source: "Auth Test",
      };
      // This creation will assign CreatedByUserId: MOCK_USER_ID via SubmitLeadCommandHandler fix
      ownedContactId = await submitLead(leadCommand);
      logTestResult(
        `1A: Created Scoped Contact ID: ${ownedContactId.substring(0, 8)}...`,
        "PASS"
      );
    } catch (e: unknown) {
      logTestResult(
        `1A: Scoped Contact creation FAILED: ${(e as Error).message}`,
        "FAIL"
      );
    }

    // 1B. Query All Contacts (Should only return the newly created one and any others owned by MOCK_USER_ID)
    if (ownedContactId) {
      try {
        // We expect the result set to be small, containing only records owned by MOCK_USER_ID
        const contactsRes = await apiClient.get<ContactDto[]>("/api/contacts");

        // Check that the newly created contact is present
        const isOwnedContactPresent = contactsRes.data.some(
          (c) => c.id === ownedContactId
        );

        if (isOwnedContactPresent) {
          logTestResult(
            `1B: Global Filter PASSED. Found ${contactsRes.data.length} owned records.`,
            "PASS"
          );
        } else {
          logTestResult(
            `1B: Global Filter FAILED. Cannot find the newly created record. Filter is blocking owned data.`,
            "FAIL"
          );
        }
      } catch (e: unknown) {
        logTestResult(
          `1B: Global Query FAILED (likely 500 crash): ${(e as Error).message}`,
          "FAIL"
        );
      }
    }

    // -----------------------------------------------------------
    // AUDIT 2: CROSS-CUTTING SUMMARY REPORTS (PHASE 35)
    // -----------------------------------------------------------
    logTestResult("AUDIT 2: Reporting & Aggregation Check...", "INFO");

    // 2A. Vendor Summary Check
    try {
      const vendorSummaryRes = await apiClient.get(
        `/api/vendors/${testVendor.id}/summary`
      );
      const summary = vendorSummaryRes.data;

      if (
        typeof summary.totalEventsHiredFor === "number" &&
        typeof summary.totalExpensesPaid === "number"
      ) {
        logTestResult(
          `2A: Vendor Summary PASSED. Events: ${
            summary.totalEventsHiredFor
          }, Expenses: $${summary.totalExpensesPaid.toFixed(2)}.`,
          "PASS"
        );
      } else {
        logTestResult(
          `2A: Vendor Summary FAILED. Invalid report data structure.`,
          "FAIL"
        );
      }
    } catch (e: unknown) {
      logTestResult(
        `2A: Vendor Summary FAILED (likely missing join/data): ${
          (e as Error).message
        }`,
        "FAIL"
      );
    }

    // 2B. Contact Task Summary Check
    try {
      const taskSummaryRes = await apiClient.get(
        `/api/contacts/${testContact.id}/task-summary`
      );
      const summary = taskSummaryRes.data;

      if (
        typeof summary.totalTasksAssigned === "number" &&
        typeof summary.totalTasksOverdue === "number"
      ) {
        logTestResult(
          `2B: Contact Summary PASSED. Total Tasks: ${summary.totalTasksAssigned}.`,
          "PASS"
        );
      } else {
        logTestResult(
          `2B: Contact Summary FAILED. Invalid report data structure.`,
          "FAIL"
        );
      }
    } catch (e: unknown) {
      logTestResult(
        `2B: Contact Summary FAILED (likely 500 crash): ${
          (e as Error).message
        }`,
        "FAIL"
      );
    }

    // -----------------------------------------------------------
    // AUDIT 3: UNIFIED ACTIVITY STREAM (PHASE 36)
    // -----------------------------------------------------------
    logTestResult("AUDIT 3: Activity Stream Check...", "INFO");

    // NOTE: This test relies on existing Notes, Tasks, and EmailLogs associated with contacts[0]
    try {
      const streamRes = await apiClient.get(
        `/api/contacts/${testContact.id}/activity-stream`
      );
      const stream = streamRes.data;

      if (
        Array.isArray(stream) &&
        stream.every((a) => a.activityType && a.timestamp)
      ) {
        logTestResult(
          `3A: Activity Stream PASSED. Found ${stream.length} activities.`,
          "PASS"
        );
      } else {
        logTestResult(
          "3A: Activity Stream FAILED. Response was not a valid array of ActivityDto.",
          "FAIL"
        );
      }
    } catch (e: unknown) {
      logTestResult(
        `3A: Activity Stream FAILED (likely 500 crash): ${
          (e as Error).message
        }`,
        "FAIL"
      );
    }

    // -----------------------------------------------------------
    // 1C. FINAL CLEANUP
    // -----------------------------------------------------------
    try {
      if (ownedContactId) {
        await deleteContactClient(ownedContactId);
        logTestResult(`1C: Cleaned up Scoped Contact.`, "INFO");
      }
    } catch (e: unknown) {
      logTestResult(`1C: Cleanup FAILED: ${(e as Error).message}`, "WARN");
    }

    logTestResult("Advanced Feature Audit Finished.", "INFO");
  }, [contacts, vendors, events, logTestResult]);
  // ---------------------------------------------

  return (
    <div
      style={{
        marginTop: "2rem",
        padding: "1rem",
        border: "1px solid #444",
        borderRadius: "8px",
        backgroundColor: "#222",
      }}>
      <h2 className="text-xl font-semibold text-white mb-3">
        API Test Harness
      </h2>
      <button
        onClick={runAllTests}
        style={{
          padding: "8px 16px",
          backgroundColor: "#007acc",
          color: "white",
          borderRadius: "4px",
          border: "none",
          marginRight: "1rem",
        }}>
        Execute Full CRUD Test Suite
      </button>
      <button
        onClick={runAdvancedTests} // NEW BUTTON
        style={{
          padding: "8px 16px",
          backgroundColor: "#b8860b", // DarkYellow for differentiation
          color: "white",
          borderRadius: "4px",
          border: "none",
        }}>
        Execute Advanced Audit
      </button>
      <div
        style={{
          marginTop: "1rem",
          maxHeight: "300px",
          overflowY: "auto",
          backgroundColor: "#111",
          padding: "10px",
          borderRadius: "4px",
        }}>
        <h4 style={{ color: "#aaa", margin: 0 }}>Test Log:</h4>
        <div
          id="test-log-output"
          style={{
            whiteSpace: "pre-wrap",
            fontFamily: "monospace",
            fontSize: "0.85rem",
          }}>
          {/* Log entries will be appended here */}
        </div>
      </div>
    </div>
  );
};
// --- END TestExecutionPanel ---

// --- MAIN DashboardPage COMPONENT ---
export default function DashboardPage() {
  const [stats, setStats] = useState<DashboardStatsDto | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");

  // --- Modal State ---
  const [isEmailModalOpen, setIsEmailModalOpen] = useState(false);
  const [selectedEventId, setSelectedEventId] = useState<string>("");

  // --- Auxiliary Data for Test Harness ---
  const [contacts, setContacts] = useState<ContactDto[]>([]);
  const [vendors, setVendors] = useState<VendorDto[]>([]);
  const [events, setEvents] = useState<EventDto[]>([]);
  // --- NEW STATE FOR FIXTURE MANAGEMENT ---
  const [isFixturesInitialized, setIsFixturesInitialized] = useState(false); // New state to track initialization
  // ----------------------------------------

  // --- Test Log State ---
  const logTestResult = useCallback(
    (message: string, level: "PASS" | "FAIL" | "INFO" | "WARN") => {
      let color = "#fff";
      if (level === "PASS") color = "#4caf50";
      if (level === "FAIL") color = "#f44336";
      if (level === "WARN") color = "#ff9800";

      const timestamp = new Date().toLocaleTimeString();
      const logEntry = `<span style="color: ${color};">[${level}] ${timestamp}: ${message}</span>\n`;

      const output = document.getElementById("test-log-output");
      if (output) {
        output.innerHTML += logEntry;
        output.scrollTop = output.scrollHeight; // Auto-scroll
      }
    },
    []
  );

  useEffect(() => {
    const loadDashboardData = async () => {
      try {
        setLoading(true);
        setError("");

        // --- PHASE 40: RUN FIXTURES ONCE ---
        if (!isFixturesInitialized) {
          logTestResult("Initializing required test fixtures...", "INFO");
          // InitializeTestFixtures creates the data needed for all subsequent fetches/tests
          await initializeTestFixtures();
          setIsFixturesInitialized(true);
          logTestResult("Fixtures initialized successfully.", "PASS");
        }
        // ----------------------------------

        // Fetch Events for Test Harness and for Upcoming Events List
        const [statsRes, contactsRes, vendorsRes, eventsRes] =
          await Promise.all([
            apiClient.get<DashboardStatsDto>("/api/dashboard"),
            apiClient.get<ContactDto[]>("/api/contacts"),
            apiClient.get<VendorDto[]>("/api/vendors"),
            apiClient.get<EventDto[]>("/api/events"),
          ]);

        setStats(statsRes.data);
        setContacts(contactsRes.data);
        setVendors(vendorsRes.data);
        setEvents(eventsRes.data); // Store events for testing
        setLoading(false);
      } catch (err: unknown) {
        console.error(err);
        setError("Failed to load dashboard data. Check API/Fixtures endpoint.");
        setLoading(false);
      }
    };

    // --- FIX: Reruns fetchDashboardData whenever initialized status changes ---
    loadDashboardData();
  }, [isFixturesInitialized, logTestResult]); // Added logTestResult to deps array

  const handleOpenEmailModal = (eventId: string) => {
    setSelectedEventId(eventId);
    setIsEmailModalOpen(true);
  };

  if (loading)
    return (
      <div
        style={{
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          height: "200px",
          color: "#9ca3af",
        }}>
        Initializing Command Center...
      </div>
    );
  if (error) return <div className="p-8 text-red-400">{error}</div>;
  if (!stats) return null;

  return (
    <div className="space-y-8 pb-10 max-w-7xl mx-auto animate-fade-in">
      {/* PHASE 31: TEST EXECUTION PANEL */}
      <TestExecutionPanel
        contacts={contacts}
        vendors={vendors}
        events={events}
        logTestResult={logTestResult}
      />

      {/* Header - Forced Flex */}
      <div
        style={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "flex-end",
          borderBottom: "1px solid #1f2937",
          paddingBottom: "1rem",
          marginBottom: "2rem",
        }}>
        <div>
          <h1 className="text-3xl font-bold text-white tracking-tight">
            Command Center
          </h1>
          <p className="text-gray-400 mt-1">System Status & Overview</p>
        </div>
        <div className="hidden sm:block text-right">
          <p className="text-sm text-gray-500">Current Phase</p>
          <p className="text-blue-400 font-mono">
            Phase 31: Full API Harness Test Coverage
          </p>
        </div>
      </div>

      {/* Stat Cards - Forced Grid */}
      <div
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(auto-fit, minmax(240px, 1fr))",
          gap: "1rem",
          marginBottom: "2rem",
        }}>
        <StatCard
          label="Total Contacts"
          value={stats.totalContacts}
          color="border-blue-500"
          icon={
            <svg
              width="24"
              height="24"
              style={{ minWidth: "24px" }}
              className="text-blue-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24">
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 005.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"
              />
            </svg>
          }
        />
        <StatCard
          label="Active Events"
          value={stats.activeEvents}
          color="border-purple-500"
          icon={
            <svg
              width="24"
              height="24"
              style={{ minWidth: "24px" }}
              className="text-purple-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24">
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"
              />
            </svg>
          }
        />
        <StatCard
          label="Pending Tasks"
          value={stats.pendingTasks}
          color="border-yellow-500"
          icon={
            <svg
              width="24"
              height="24"
              style={{ minWidth: "24px" }}
              className="text-yellow-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24">
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"
              />
            </svg>
          }
        />
        <StatCard
          label="Emails (24h)"
          value={stats.recentEmails}
          color="border-green-500"
          icon={
            <svg
              width="24"
              height="24"
              style={{ minWidth: "24px" }}
              className="text-green-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24">
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"
              />
            </svg>
          }
        />
      </div>

      {/* Upcoming Events Section */}
      <div className="bg-gray-800 rounded-xl border border-gray-700 overflow-hidden shadow-sm">
        <div
          className="p-6 border-b border-gray-700 flex justify-between items-center bg-gray-800"
          style={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
          }}>
          <h2 className="text-xl font-semibold text-white">Upcoming Events</h2>
          <button className="text-sm text-blue-400 hover:text-blue-300 transition-colors">
            View All
          </button>
        </div>

        <div className="divide-y divide-gray-700">
          {stats.upcomingEvents.length === 0 ? (
            <div className="p-8 text-center text-gray-500 italic">
              No upcoming events scheduled. Time to book something!
            </div>
          ) : (
            stats.upcomingEvents.map((evt: EventDto) => {
              const dateObj = new Date(evt.startDateTime);
              const month = dateObj.toLocaleString("default", {
                month: "short",
              });
              const day = dateObj.getDate();
              const time = dateObj.toLocaleTimeString([], {
                hour: "2-digit",
                minute: "2-digit",
              });

              return (
                <div
                  key={evt.id}
                  className="p-4 hover:bg-gray-700/50 transition-colors"
                  style={{
                    display: "flex",
                    alignItems: "center",
                    gap: "1rem",
                  }}>
                  {/* Date Badge */}
                  <div
                    className="bg-gray-900 rounded-lg border border-gray-600 shadow-inner"
                    style={{
                      width: "56px",
                      height: "56px",
                      flexShrink: 0,
                      display: "flex",
                      flexDirection: "column",
                      alignItems: "center",
                      justifyContent: "center",
                    }}>
                    <span className="text-xs text-gray-400 uppercase font-bold">
                      {month}
                    </span>
                    <span className="text-xl font-bold text-white leading-none">
                      {day}
                    </span>
                  </div>

                  {/* Event Info - Grow to take space */}
                  <div style={{ flexGrow: 1, minWidth: 0 }}>
                    <h3 className="text-white font-medium truncate">
                      {evt.name}
                    </h3>

                    {/* Meta Row */}
                    <div
                      className="text-sm text-gray-400 mt-1"
                      style={{
                        display: "flex",
                        flexWrap: "wrap",
                        alignItems: "center",
                        gap: "1rem",
                      }}>
                      <span
                        style={{
                          display: "flex",
                          alignItems: "center",
                          gap: "4px",
                        }}>
                        <svg
                          width="16"
                          height="16"
                          fill="none"
                          stroke="currentColor"
                          viewBox="0 0 24 24">
                          <path
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            strokeWidth={2}
                            d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                          />
                        </svg>
                        {time}
                      </span>
                      {evt.location && (
                        <span
                          style={{
                            display: "flex",
                            alignItems: "center",
                            gap: "4px",
                          }}>
                          <svg
                            width="16"
                            height="16"
                            fill="none"
                            stroke="currentColor"
                            viewBox="0 0 24 24">
                            <path
                              strokeLinecap="round"
                              strokeLinejoin="round"
                              strokeWidth={2}
                              d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"
                            />
                            <path
                              strokeLinecap="round"
                              strokeLinejoin="round"
                              strokeWidth={2}
                              d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"
                            />
                          </svg>
                          {evt.location}
                        </span>
                      )}
                    </div>
                  </div>

                  {/* Action Button */}
                  <button
                    onClick={() => handleOpenEmailModal(evt.id)}
                    className="rounded-lg bg-gray-900 hover:bg-blue-600 text-gray-300 hover:text-white border border-gray-600 hover:border-blue-500 transition-all shadow-sm"
                    style={{
                      flexShrink: 0,
                      display: "flex",
                      alignItems: "center",
                      gap: "0.5rem",
                      padding: "0.5rem 1rem",
                    }}
                    title="Send Email">
                    <svg
                      width="20"
                      height="20"
                      fill="none"
                      viewBox="0 0 24 24"
                      stroke="currentColor">
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"
                      />
                    </svg>
                    <span className="hidden sm:inline text-sm font-medium">
                      Email
                    </span>
                  </button>
                </div>
              );
            })
          )}
        </div>
      </div>

      {/* The Email Modal */}
      <SendEmailModal
        isOpen={isEmailModalOpen}
        onClose={() => setIsEmailModalOpen(false)}
        eventId={selectedEventId}
        availableContacts={contacts}
        availableVendors={vendors}
      />
    </div>
  );
}

function StatCard({
  label,
  value,
  color,
  icon,
}: {
  label: string;
  value: number;
  color: string;
  icon?: React.ReactNode;
}) {
  return (
    <div
      className={`bg-gray-800 p-6 rounded-xl border-l-4 ${color} shadow-md`}
      style={{
        display: "flex",
        justifyContent: "space-between",
        alignItems: "flex-start",
      }}>
      <div>
        <p className="text-gray-400 text-xs font-bold uppercase tracking-wider mb-1">
          {label}
        </p>
        <p className="text-3xl font-bold text-white">{value}</p>
      </div>
      {/* Icon container with strict styling */}
      {icon && (
        <div
          style={{
            width: "32px",
            height: "32px",
            flexShrink: 0,
            opacity: 0.8,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
          }}>
          {icon}
        </div>
      )}
    </div>
  );
}


// =======================================================
// FILE: frontend_harness/src/apiClient.ts
// =======================================================
// FILE: frontend_harness/src/apiClient.ts (COMPLETE REPLACEMENT)
import axios from 'axios';
import { 
  type Document, 
  type EventFinancials, 
  type SendTemplateEmailCommand,
  type TemplateDto, 
  type ContactDto,
  type VendorDto,
  type EventDto,
  type TaskDto,
  type NoteDto,
  type EmailLogDto,
  type SubmitLeadCommand,
  RecipientType,
} from './types';


// Define the base URL of your local API
const API_BASE_URL = 'http://localhost:5179';

export const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// =======================================================
// CORE SERVICES
// =======================================================

// --- DOCUMENT SERVICES ---

export const uploadDocument = async (
  file: File, 
  relatedEntityId: string, 
  relatedEntityType: string,
  category: string
): Promise<Document> => {
  const formData = new FormData();
  formData.append('file', file);
  formData.append('relatedEntityId', relatedEntityId);
  formData.append('relatedEntityType', relatedEntityType);
  formData.append('category', category);

  const response = await apiClient.post<Document>('/api/documents', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  });
  return response.data;
};

export const deleteDocument = async (id: number): Promise<void> => {
  await apiClient.delete(`/api/documents/${id}`);
};

// --- FINANCIALS SERVICES ---

export const getEventFinancials = async (eventId: string): Promise<EventFinancials> => {
  const response = await apiClient.get<EventFinancials>(`/api/events/${eventId}/financials`);
  return response.data;
};

export const upsertBudget = async (
  eventId: string, 
  totalAmount: number, 
  currency: string, 
  notes?: string
): Promise<string> => {
  const payload = { eventId, totalAmount, currency, notes };
  const response = await apiClient.post<string>(`/api/events/${eventId}/financials/budget`, payload);
  return response.data;
};

export const addExpense = async (
  eventId: string,
  description: string,
  amount: number,
  dateIncurred: string, // ISO String
  category: string,
  vendorId?: string,
  linkedDocumentId?: number
): Promise<string> => {
  const payload = { eventId, description, amount, dateIncurred, category, vendorId, linkedDocumentId };
  const response = await apiClient.post<string>(`/api/events/${eventId}/financials/expenses`, payload);
  return response.data;
};


// --- TEMPLATE SERVICES ---

export const templates = {
  getAll: async () => {
    const response = await apiClient.get<TemplateDto[]>('/api/templates');
    return response.data;
  },
  create: async (data: unknown) => {
    const response = await apiClient.post<string>('/api/templates', data);
    return response.data;
  },
  sendEmail: async (command: SendTemplateEmailCommand) => {
    // Uses POST /api/templates/send
    await apiClient.post('/api/templates/send', command);
  }
};

/**
 * Initializes required contacts, vendors, and events for testing.
 * @returns The ID of the primary contact created.
 */
export const initializeTestFixtures = async (): Promise<string> => {
  const response = await apiClient.post<string>('/api/contacts/init-fixtures');
  return response.data;
};

// =======================================================
// FULL CRUD IMPLEMENTATION (PHASE 31)
// =======================================================

// --- CONTACTS CRUD & RELATIONS ---

export const updateContact = async (id: string, data: Partial<ContactDto>): Promise<void> => {
  await apiClient.put(`/api/contacts/${id}`, data);
};

export const deleteContact = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/contacts/${id}`);
};

export const getContactEmailLogs = async (contactId: string): Promise<EmailLogDto[]> => {
  const response = await apiClient.get<EmailLogDto[]>(`/api/contacts/${contactId}/email-logs`);
  return response.data;
};

// --- EVENTS CRUD & RELATIONS ---

export const updateEvent = async (id: string, data: Partial<EventDto>): Promise<void> => {
  await apiClient.put(`/api/events/${id}`, data);
};

export const deleteEvent = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/events/${id}`);
};

export const unlinkContactFromEvent = async (eventId: string, contactId: string): Promise<void> => {
  await apiClient.delete(`/api/events/${eventId}/contacts/${contactId}`);
};


// --- VENDORS CRUD ---

export const updateVendor = async (id: string, data: Partial<VendorDto>): Promise<void> => {
  await apiClient.put(`/api/vendors/${id}`, data);
};

export const deleteVendor = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/vendors/${id}`);
};


// --- TASKS CRUD ---
// (TasksController only has Create/Update/Delete - Reads are handled via GetTasksQuery)
export const updateTask = async (id: string, data: Partial<TaskDto>): Promise<void> => {
  await apiClient.put(`/api/tasks/${id}`, data);
};

export const deleteTask = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/tasks/${id}`);
};


// --- NOTES CRUD ---
// (NotesController only has Update/Delete - Create returns DTO)
export const updateNote = async (id: string, data: Partial<NoteDto>): Promise<void> => {
  // NOTE: Notes only allow updating 'content' per the business logic
  await apiClient.put(`/api/notes/${id}`, data); 
};

export const deleteNote = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/notes/${id}`);
};


// --- AUTOMATION & LEADS ---

export const submitLead = async (command: SubmitLeadCommand): Promise<string> => {
  const response = await apiClient.post<string>('/api/leads/submit', command);
  return response.data;
};

export const scheduleFollowUp = async (
  contactId: string, 
  templateId: string, 
  scheduleTime: string, // ISO String
  type: RecipientType = RecipientType.Contact
): Promise<string> => {
  const payload = { contactId, templateId, scheduleTime, type };
  const response = await apiClient.post<string>('/api/automation/schedule-followup', payload);
  return response.data;
};