

// ==========================================
// FILE: frontend_harness/src/types.ts 
// ==========================================
// =======================================================
// FILE: frontend_harness/src/types.ts
// =======================================================

// --- ENUMS REPLACED WITH CONST OBJECTS (Erasable Syntax Compliant) ---

export const VendorType = {
  Catering: "Catering",
  Venue: "Venue",
  Security: "Security",
  Entertainment: "Entertainment",
  Florist: "Florist",
  Photography: "Photography",
  Videography: "Videography",
  Other: "Other"
} as const;
export type VendorType = typeof VendorType[keyof typeof VendorType];

export const LeadStage = {
  NewLead: 0,
  InDiscussion: 1,
  ProposalSent: 2,
  Negotiating: 3,
  Won: 4,
  Lost: 5
} as const;
export type LeadStage = typeof LeadStage[keyof typeof LeadStage];

export const ConnectionStatus = {
  Unknown: 0,
  NeedToMeet: 1,
  MetAlready: 2,
  DoesntNeed: 3,
  NeedAndDoesntHave: 4,
  NeedAndHas: 5,
  HasAndNeedsToMeet: 6
} as const;
export type ConnectionStatus = typeof ConnectionStatus[keyof typeof ConnectionStatus];

export const TaskStatus = {
  NotStarted: "NotStarted",
  InProgress: "InProgress",
  Completed: "Completed",
  Deferred: "Deferred"
} as const;
export type TaskStatus = typeof TaskStatus[keyof typeof TaskStatus];

export const TaskPriority = {
  Low: "Low",
  Medium: "Medium",
  High: "High",
  Urgent: "Urgent"
} as const;
export type TaskPriority = typeof TaskPriority[keyof typeof TaskPriority];

// --- DTOs ---

export interface ContactDto {
  id: string;
  firstName: string;
  lastName: string | null;
  email: string;
  phoneNumber: string | null;
  title: string | null;
  organization: string | null;
  
  // --- NEW: Pipeline Fields (Phase 25) ---
  stage: LeadStage;
  connectionStatus: ConnectionStatus;
  isLead: boolean;
  followUpCount: number;
  lastContactedAt: string | null; // ISO Date
  source: string | null;
}

export interface VendorDto {
  id: string;
  name: string;
  phoneNumber: string | null;
  email: string | null;
  serviceType: VendorType;
  attributes: string | null;
}

export interface EventDto {
  id: string;
  name: string;
  description: string | null;
  startDateTime: string; // ISO 8601 string
  endDateTime: string; // ISO 8601 string
  location: string | null;
  isPublic: boolean;
  status: string; 
}

export interface TaskDto {
  id: string;
  title: string;
  description: string | null;
  status: TaskStatus;
  priority: TaskPriority;
  dueDate: string | null;
  createdAt: string;
  contactId: string | null;
  eventId: string | null;
  vendorId: string | null;
  vendorName: string | null;
  contactEmail?: string;
  eventName?: string;
  vendorNameForLookup?: string;
}

export interface NoteDto {
  id: string;
  content: string;
  createdAt: string;
  updatedAt: string | null;
  contactId: string | null;
  eventId: string | null;
  taskId: string | null;
  vendorId: string | null;
  vendorName: string | null;
  contactEmail?: string;
  eventName?: string;
  vendorNameForLookup?: string;
  taskTitle?: string;
}

export interface TemplateDto {
  id: string;
  name: string;
  subject: string | null;
  content: string;
  type: string;
}

export interface EmailLogDto {
  id: string;
  to: string;
  subject: string;
  sentAt: string;
  isSuccess: boolean;
  errorMessage: string | null;
}

// --- NEW: DASHBOARD DTO (PHASE 31 FIX) ---
export interface DashboardStatsDto {
  totalContacts: number;
  activeEvents: number;
  pendingTasks: number;
  recentEmails: number;
  upcomingEvents: EventDto[]; // Uses the EventDto defined above
}

// --- DOCUMENT & FINANCIALS (Phase 26) ---

export type ContractStatus = 1 | 2 | 3 | 4 | 5;

export const ContractStatusName: Record<ContractStatus, string> = {
    1: "Draft",
    2: "Sent",
    3: "Viewed",
    4: "Signed",
    5: "Voided"
};

export interface Document {
  id: number;
  fileName: string;
  contentType: string;
  size: number;
  uploadedAt: string;
  url: string;
  relatedEntityId: string;
  relatedEntityType: string;
  category: string;
  status: ContractStatus;
  signedAt: string | null;
}

export type ExpenseCategory = 
    | "General" | "Venue" | "Catering" | "Talent" 
    | "Production" | "Marketing" | "Travel" | "Admin" | "Legal";

export interface Expense {
    id: string;
    budgetId: string;
    description: string;
    amount: number;
    dateIncurred: string;
    category: ExpenseCategory;
    vendorId?: string;
    vendorName?: string;
    linkedDocumentId?: number;
    linkedDocumentName?: string;
}

export interface EventFinancials {
    eventId: string;
    eventName: string;
    budgetTotal: number;
    currency: string;
    notes?: string;
    isLocked: boolean;
    expenses: Expense[];
    totalSpent: number;
    remainingBudget: number;
    burnRate: number;
}

// --- COMMANDS ---

export const RecipientType = {
  Contact: 0,
  Vendor: 1
} as const;
export type RecipientType = typeof RecipientType[keyof typeof RecipientType];

export interface SendTemplateEmailCommand {
  eventId: string;
  templateId: string;
  targetEntityId: string;
  recipientType: RecipientType;
}

export interface SubmitLeadCommand {
  firstName: string;
  lastName?: string;
  email: string;
  phoneNumber?: string;
  organization?: string;
  source?: string;
}

// Type aliases for CREATE DTOs
export type CreateContactDto = Omit<ContactDto, 'id'>;
export type CreateEventDto = Omit<EventDto, 'id' | 'createdAt'>;
export type CreateTaskDto = Omit<TaskDto, 'id' | 'createdAt'>;
export type CreateVendorDto = Omit<VendorDto, 'id' | 'createdAt'>;
export type CreateNoteDto = Omit<NoteDto, 'id' | 'createdAt' | 'updatedAt'>;
export type CreateTemplateDto = Omit<TemplateDto, 'id'>;

export type Guid = string;

// ==========================================
// FILE: frontend_harness/src/apiClient.ts 
// ==========================================
// FILE: frontend_harness/src/apiClient.ts (COMPLETE REPLACEMENT)
import axios from 'axios';
import { 
  type Document, 
  type EventFinancials, 
  type SendTemplateEmailCommand,
  type TemplateDto, 
  type ContactDto,
  type VendorDto,
  type EventDto,
  type TaskDto,
  type NoteDto,
  type EmailLogDto,
  type SubmitLeadCommand,
  RecipientType,
} from './types';


// Define the base URL of your local API
const API_BASE_URL = 'http://localhost:5179';

export const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// =======================================================
// CORE SERVICES
// =======================================================

// --- DOCUMENT SERVICES ---

export const uploadDocument = async (
  file: File, 
  relatedEntityId: string, 
  relatedEntityType: string,
  category: string
): Promise<Document> => {
  const formData = new FormData();
  formData.append('file', file);
  formData.append('relatedEntityId', relatedEntityId);
  formData.append('relatedEntityType', relatedEntityType);
  formData.append('category', category);

  const response = await apiClient.post<Document>('/api/documents', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  });
  return response.data;
};

export const deleteDocument = async (id: number): Promise<void> => {
  await apiClient.delete(`/api/documents/${id}`);
};

// --- FINANCIALS SERVICES ---

export const getEventFinancials = async (eventId: string): Promise<EventFinancials> => {
  const response = await apiClient.get<EventFinancials>(`/api/events/${eventId}/financials`);
  return response.data;
};

export const upsertBudget = async (
  eventId: string, 
  totalAmount: number, 
  currency: string, 
  notes?: string
): Promise<string> => {
  const payload = { eventId, totalAmount, currency, notes };
  const response = await apiClient.post<string>(`/api/events/${eventId}/financials/budget`, payload);
  return response.data;
};

export const addExpense = async (
  eventId: string,
  description: string,
  amount: number,
  dateIncurred: string, // ISO String
  category: string,
  vendorId?: string,
  linkedDocumentId?: number
): Promise<string> => {
  const payload = { eventId, description, amount, dateIncurred, category, vendorId, linkedDocumentId };
  const response = await apiClient.post<string>(`/api/events/${eventId}/financials/expenses`, payload);
  return response.data;
};


// --- TEMPLATE SERVICES ---

export const templates = {
  getAll: async () => {
    const response = await apiClient.get<TemplateDto[]>('/api/templates');
    return response.data;
  },
  create: async (data: unknown) => {
    const response = await apiClient.post<string>('/api/templates', data);
    return response.data;
  },
  sendEmail: async (command: SendTemplateEmailCommand) => {
    // Uses POST /api/templates/send
    await apiClient.post('/api/templates/send', command);
  }
};

/**
 * Initializes required contacts, vendors, and events for testing.
 * @returns The ID of the primary contact created.
 */
export const initializeTestFixtures = async (): Promise<string> => {
  const response = await apiClient.post<string>('/api/contacts/init-fixtures');
  return response.data;
};

// =======================================================
// FULL CRUD IMPLEMENTATION (PHASE 31)
// =======================================================

// --- CONTACTS CRUD & RELATIONS ---

export const updateContact = async (id: string, data: Partial<ContactDto>): Promise<void> => {
  await apiClient.put(`/api/contacts/${id}`, data);
};

export const deleteContact = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/contacts/${id}`);
};

export const getContactEmailLogs = async (contactId: string): Promise<EmailLogDto[]> => {
  const response = await apiClient.get<EmailLogDto[]>(`/api/contacts/${contactId}/email-logs`);
  return response.data;
};

// --- EVENTS CRUD & RELATIONS ---

export const updateEvent = async (id: string, data: Partial<EventDto>): Promise<void> => {
  await apiClient.put(`/api/events/${id}`, data);
};

export const deleteEvent = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/events/${id}`);
};

export const unlinkContactFromEvent = async (eventId: string, contactId: string): Promise<void> => {
  await apiClient.delete(`/api/events/${eventId}/contacts/${contactId}`);
};


// --- VENDORS CRUD ---

export const updateVendor = async (id: string, data: Partial<VendorDto>): Promise<void> => {
  await apiClient.put(`/api/vendors/${id}`, data);
};

export const deleteVendor = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/vendors/${id}`);
};


// --- TASKS CRUD ---
// (TasksController only has Create/Update/Delete - Reads are handled via GetTasksQuery)
export const updateTask = async (id: string, data: Partial<TaskDto>): Promise<void> => {
  await apiClient.put(`/api/tasks/${id}`, data);
};

export const deleteTask = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/tasks/${id}`);
};


// --- NOTES CRUD ---
// (NotesController only has Update/Delete - Create returns DTO)
export const updateNote = async (id: string, data: Partial<NoteDto>): Promise<void> => {
  // NOTE: Notes only allow updating 'content' per the business logic
  await apiClient.put(`/api/notes/${id}`, data); 
};

export const deleteNote = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/notes/${id}`);
};


// --- AUTOMATION & LEADS ---

export const submitLead = async (command: SubmitLeadCommand): Promise<string> => {
  const response = await apiClient.post<string>('/api/leads/submit', command);
  return response.data;
};

export const scheduleFollowUp = async (
  contactId: string, 
  templateId: string, 
  scheduleTime: string, // ISO String
  type: RecipientType = RecipientType.Contact
): Promise<string> => {
  const payload = { contactId, templateId, scheduleTime, type };
  const response = await apiClient.post<string>('/api/automation/schedule-followup', payload);
  return response.data;
};

// ==========================================
// FILE: frontend_harness/src/App.tsx 
// ==========================================
import {
  SignedIn,
  SignedOut,
  UserButton,
  useAuth,
  RedirectToSignIn,
} from "@clerk/clerk-react";
import { apiClient } from "./apiClient";
import { useEffect, useState } from "react";

import DashboardPage from "./components/DashboardPage"; // NEW IMPORT
import ContactsPage from "./components/ContactsPage";
import EventsPage from "./components/EventsPage";
import TasksPage from "./components/TasksPage";
import VendorsPage from "./components/VendorsPage";
import NotesPage from "./components/NotesPage";
import TemplatesPage from "./components/TemplatesPage";

import { SelectionProvider } from "./context/SelectionProvider";

type PageView =
  | "dashboard" // NEW TYPE
  | "contacts"
  | "events"
  | "tasks"
  | "vendors"
  | "notes"
  | "templates";

function App() {
  const [isApiReady, setIsApiReady] = useState(false);
  // CHANGED: Default to "dashboard"
  const [currentPage, setCurrentPage] = useState<PageView>("dashboard");
  const { getToken } = useAuth();

  useEffect(() => {
    const setupAxiosInterceptor = async () => {
      const interceptorId = apiClient.interceptors.request.use(
        async (config) => {
          const token = await getToken();

          if (token) {
            config.headers.Authorization = `Bearer ${token}`;
          }
          return config;
        },
        (error) => {
          return Promise.reject(error);
        }
      );

      setIsApiReady(true);

      return () => {
        apiClient.interceptors.request.eject(interceptorId);
        setIsApiReady(false);
      };
    };
    setupAxiosInterceptor();
  }, [getToken]);

  const renderPage = () => {
    switch (currentPage) {
      case "dashboard": // NEW CASE
        return <DashboardPage />;
      case "contacts":
        return <ContactsPage />;
      case "events":
        return <EventsPage />;
      case "tasks":
        return <TasksPage />;
      case "vendors":
        return <VendorsPage />;
      case "notes":
        return <NotesPage />;
      case "templates":
        return <TemplatesPage />;
      default:
        return <DashboardPage />;
    }
  };

  return (
    <SelectionProvider>
      <div>
        <header
          style={{
            padding: "1rem",
            display: "flex",
            justifyContent: "flex-end",
            borderBottom: "1px solid #333",
            marginBottom: "1rem",
          }}>
          <SignedIn>
            <UserButton />
          </SignedIn>
        </header>
        <main style={{ padding: "1rem" }}>
          <SignedIn>
            <div
              style={{
                display: "flex",
                alignItems: "center",
                justifyContent: "space-between",
                marginBottom: "1rem",
              }}>
              <h1>CRM_Vivid Command Center</h1>
            </div>

            <nav
              className="harness-nav"
              style={{
                marginBottom: "2rem",
                display: "flex",
                gap: "0.5rem",
                flexWrap: "wrap",
              }}>
              <button
                onClick={() => setCurrentPage("dashboard")}
                disabled={currentPage === "dashboard"}
                style={{
                  fontWeight: currentPage === "dashboard" ? "bold" : "normal",
                }}>
                ðŸ“Š Dashboard
              </button>
              <button
                onClick={() => setCurrentPage("contacts")}
                disabled={currentPage === "contacts"}>
                Contacts
              </button>
              <button
                onClick={() => setCurrentPage("events")}
                disabled={currentPage === "events"}>
                Events
              </button>
              <button
                onClick={() => setCurrentPage("tasks")}
                disabled={currentPage === "tasks"}>
                Tasks
              </button>
              <button
                onClick={() => setCurrentPage("vendors")}
                disabled={currentPage === "vendors"}>
                Vendors
              </button>
              <button
                onClick={() => setCurrentPage("notes")}
                disabled={currentPage === "notes"}>
                Notes
              </button>
              <button
                onClick={() => setCurrentPage("templates")}
                disabled={currentPage === "templates"}>
                Templates
              </button>
            </nav>

            <main className="harness-main">
              {isApiReady ? renderPage() : <p>Initializing API client...</p>}
            </main>
          </SignedIn>

          <SignedOut>
            <RedirectToSignIn />
          </SignedOut>
        </main>
      </div>
    </SelectionProvider>
  );
}

export default App;


// ==========================================
// FILE: frontend_harness/src/main.tsx 
// ==========================================
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.tsx";
import "./index.css";
import { ClerkProvider } from "@clerk/clerk-react";

// Import your env variable
const PUBLISHABLE_KEY = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY;

if (!PUBLISHABLE_KEY) {
  throw new Error("Missing Publishable Key");
}

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ClerkProvider publishableKey={PUBLISHABLE_KEY}>
      <App />
    </ClerkProvider>
  </React.StrictMode>
);


// ==========================================
// FILE: frontend_harness/src/context/useSelectionContext.tsx 
// ==========================================
import { useContext } from "react";
// Import the raw context from its new, separate file
import { SelectionContext } from "./internalContext";

// This is the only export, and it's a hook.
// This also satisfies the linter.
export const useSelectionContext = () => {
  const context = useContext(SelectionContext);
  if (context === undefined) {
    throw new Error(
      "useSelectionContext must be used within a SelectionProvider"
    );
  }
  return context;
};


// ==========================================
// FILE: frontend_harness/src/context/SelectionProvider.tsx 
// ==========================================
// frontend_harness/src/context/SelectionProvider.tsx (FULL FILE - Corrected)
import React, { useState, useMemo } from "react";
import { SelectionContext } from "./internalContext";
import type { Guid } from "../types"; // FIX: Added 'type' keyword (TS1484)

interface SelectionProviderProps {
  children: React.ReactNode;
}

export const SelectionProvider: React.FC<SelectionProviderProps> = ({
  children,
}) => {
  const [selectedContactId, setSelectedContactId] = useState<Guid | null>(null);
  const [selectedEventId, setSelectedEventId] = useState<Guid | null>(null);
  // NEW: State for selected vendor
  const [selectedVendorId, setSelectedVendorId] = useState<Guid | null>(null);

  const contextValue = useMemo(
    () => ({
      selectedContactId,
      setSelectedContactId,
      selectedEventId,
      setSelectedEventId,
      selectedVendorId, // NEW: Include in context value
      setSelectedVendorId, // NEW: Include in context value
    }),
    [selectedContactId, selectedEventId, selectedVendorId]
  ); // NEW: Include in dependency array

  return (
    <SelectionContext.Provider value={contextValue}>
      {children}
    </SelectionContext.Provider>
  );
};


// ==========================================
// FILE: frontend_harness/src/context/internalContext.tsx 
// ==========================================
// frontend_harness/src/context/internalContext.tsx
import { createContext } from "react";

// Define the shape of the context state
export interface SelectionContextType {
  selectedContactId: string | null;
  setSelectedContactId: (id: string | null) => void;
  selectedEventId: string | null;
  setSelectedEventId: (id: string | null) => void;
  // NEW: Vendor selection properties
  selectedVendorId: string | null;
  setSelectedVendorId: (id: string | null) => void;
}

// Create the context with an initial undefined value
export const SelectionContext = createContext<SelectionContextType | undefined>(
  undefined
);


// ==========================================
// FILE: frontend_harness/src/types.ts 
// ==========================================
// =======================================================
// FILE: frontend_harness/src/types.ts
// =======================================================

// --- ENUMS REPLACED WITH CONST OBJECTS (Erasable Syntax Compliant) ---

export const VendorType = {
  Catering: "Catering",
  Venue: "Venue",
  Security: "Security",
  Entertainment: "Entertainment",
  Florist: "Florist",
  Photography: "Photography",
  Videography: "Videography",
  Other: "Other"
} as const;
export type VendorType = typeof VendorType[keyof typeof VendorType];

export const LeadStage = {
  NewLead: 0,
  InDiscussion: 1,
  ProposalSent: 2,
  Negotiating: 3,
  Won: 4,
  Lost: 5
} as const;
export type LeadStage = typeof LeadStage[keyof typeof LeadStage];

export const ConnectionStatus = {
  Unknown: 0,
  NeedToMeet: 1,
  MetAlready: 2,
  DoesntNeed: 3,
  NeedAndDoesntHave: 4,
  NeedAndHas: 5,
  HasAndNeedsToMeet: 6
} as const;
export type ConnectionStatus = typeof ConnectionStatus[keyof typeof ConnectionStatus];

export const TaskStatus = {
  NotStarted: "NotStarted",
  InProgress: "InProgress",
  Completed: "Completed",
  Deferred: "Deferred"
} as const;
export type TaskStatus = typeof TaskStatus[keyof typeof TaskStatus];

export const TaskPriority = {
  Low: "Low",
  Medium: "Medium",
  High: "High",
  Urgent: "Urgent"
} as const;
export type TaskPriority = typeof TaskPriority[keyof typeof TaskPriority];

// --- DTOs ---

export interface ContactDto {
  id: string;
  firstName: string;
  lastName: string | null;
  email: string;
  phoneNumber: string | null;
  title: string | null;
  organization: string | null;
  
  // --- NEW: Pipeline Fields (Phase 25) ---
  stage: LeadStage;
  connectionStatus: ConnectionStatus;
  isLead: boolean;
  followUpCount: number;
  lastContactedAt: string | null; // ISO Date
  source: string | null;
}

export interface VendorDto {
  id: string;
  name: string;
  phoneNumber: string | null;
  email: string | null;
  serviceType: VendorType;
  attributes: string | null;
}

export interface EventDto {
  id: string;
  name: string;
  description: string | null;
  startDateTime: string; // ISO 8601 string
  endDateTime: string; // ISO 8601 string
  location: string | null;
  isPublic: boolean;
  status: string; 
}

export interface TaskDto {
  id: string;
  title: string;
  description: string | null;
  status: TaskStatus;
  priority: TaskPriority;
  dueDate: string | null;
  createdAt: string;
  contactId: string | null;
  eventId: string | null;
  vendorId: string | null;
  vendorName: string | null;
  contactEmail?: string;
  eventName?: string;
  vendorNameForLookup?: string;
}

export interface NoteDto {
  id: string;
  content: string;
  createdAt: string;
  updatedAt: string | null;
  contactId: string | null;
  eventId: string | null;
  taskId: string | null;
  vendorId: string | null;
  vendorName: string | null;
  contactEmail?: string;
  eventName?: string;
  vendorNameForLookup?: string;
  taskTitle?: string;
}

export interface TemplateDto {
  id: string;
  name: string;
  subject: string | null;
  content: string;
  type: string;
}

export interface EmailLogDto {
  id: string;
  to: string;
  subject: string;
  sentAt: string;
  isSuccess: boolean;
  errorMessage: string | null;
}

// --- NEW: DASHBOARD DTO (PHASE 31 FIX) ---
export interface DashboardStatsDto {
  totalContacts: number;
  activeEvents: number;
  pendingTasks: number;
  recentEmails: number;
  upcomingEvents: EventDto[]; // Uses the EventDto defined above
}

// --- DOCUMENT & FINANCIALS (Phase 26) ---

export type ContractStatus = 1 | 2 | 3 | 4 | 5;

export const ContractStatusName: Record<ContractStatus, string> = {
    1: "Draft",
    2: "Sent",
    3: "Viewed",
    4: "Signed",
    5: "Voided"
};

export interface Document {
  id: number;
  fileName: string;
  contentType: string;
  size: number;
  uploadedAt: string;
  url: string;
  relatedEntityId: string;
  relatedEntityType: string;
  category: string;
  status: ContractStatus;
  signedAt: string | null;
}

export type ExpenseCategory = 
    | "General" | "Venue" | "Catering" | "Talent" 
    | "Production" | "Marketing" | "Travel" | "Admin" | "Legal";

export interface Expense {
    id: string;
    budgetId: string;
    description: string;
    amount: number;
    dateIncurred: string;
    category: ExpenseCategory;
    vendorId?: string;
    vendorName?: string;
    linkedDocumentId?: number;
    linkedDocumentName?: string;
}

export interface EventFinancials {
    eventId: string;
    eventName: string;
    budgetTotal: number;
    currency: string;
    notes?: string;
    isLocked: boolean;
    expenses: Expense[];
    totalSpent: number;
    remainingBudget: number;
    burnRate: number;
}

// --- COMMANDS ---

export const RecipientType = {
  Contact: 0,
  Vendor: 1
} as const;
export type RecipientType = typeof RecipientType[keyof typeof RecipientType];

export interface SendTemplateEmailCommand {
  eventId: string;
  templateId: string;
  targetEntityId: string;
  recipientType: RecipientType;
}

export interface SubmitLeadCommand {
  firstName: string;
  lastName?: string;
  email: string;
  phoneNumber?: string;
  organization?: string;
  source?: string;
}

// Type aliases for CREATE DTOs
export type CreateContactDto = Omit<ContactDto, 'id'>;
export type CreateEventDto = Omit<EventDto, 'id' | 'createdAt'>;
export type CreateTaskDto = Omit<TaskDto, 'id' | 'createdAt'>;
export type CreateVendorDto = Omit<VendorDto, 'id' | 'createdAt'>;
export type CreateNoteDto = Omit<NoteDto, 'id' | 'createdAt' | 'updatedAt'>;
export type CreateTemplateDto = Omit<TemplateDto, 'id'>;

export type Guid = string;

// ==========================================
// FILE: frontend_harness/src/components/TemplatesPage.tsx 
// ==========================================
import { useEffect, useState } from "react";
import { apiClient } from "../apiClient";
import type { TemplateDto, CreateTemplateDto } from "../types"; // FIX: Added 'type' keyword

export default function TemplatesPage() {
  const [templates, setTemplates] = useState<TemplateDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");

  // Form State
  const [formData, setFormData] = useState<CreateTemplateDto>({
    name: "",
    subject: "",
    content: "",
    type: "Email", // Default
  });

  useEffect(() => {
    fetchTemplates();
  }, []);

  const fetchTemplates = async () => {
    try {
      const response = await apiClient.get<TemplateDto[]>("/api/templates");
      setTemplates(response.data);
    } catch (err) {
      console.error(err);
      setError("Failed to load templates.");
    } finally {
      setLoading(false);
    }
  };

  const handleCreate = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await apiClient.post("/api/templates", formData);
      // Reset form
      setFormData({
        name: "",
        subject: "",
        content: "",
        type: "Email",
      });
      fetchTemplates();
    } catch (err) {
      console.error(err);
      alert("Failed to create template.");
    }
  };

  const handleDelete = async (id: string) => {
    if (!confirm("Are you sure you want to delete this template?")) return;
    try {
      await apiClient.delete(`/api/templates/${id}`);
      fetchTemplates();
    } catch (err) {
      console.error(err);
      alert("Failed to delete template.");
    }
  };

  return (
    <div className="p-4">
      <h2 className="text-xl font-bold mb-4">Templates</h2>

      {/* CREATE FORM */}
      <div className="mb-8 p-4 border rounded shadow-sm bg-gray-50">
        <h3 className="font-semibold mb-2">New Template</h3>
        <form onSubmit={handleCreate} className="space-y-3">
          <div>
            <label className="block text-sm font-medium">Name (Internal)</label>
            <input
              className="border p-1 w-full"
              value={formData.name}
              onChange={(e) =>
                setFormData({ ...formData, name: e.target.value })
              }
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium">Type</label>
            <select
              className="border p-1 w-full"
              value={formData.type}
              onChange={(e) =>
                setFormData({ ...formData, type: e.target.value })
              }>
              <option value="Email">Email</option>
              <option value="SMS">SMS</option>
            </select>
          </div>

          {formData.type === "Email" && (
            <div>
              <label className="block text-sm font-medium">Subject Line</label>
              <input
                className="border p-1 w-full"
                value={formData.subject || ""}
                onChange={(e) =>
                  setFormData({ ...formData, subject: e.target.value })
                }
              />
            </div>
          )}

          <div>
            <label className="block text-sm font-medium">Content Body</label>
            <textarea
              className="border p-1 w-full h-24"
              value={formData.content}
              onChange={(e) =>
                setFormData({ ...formData, content: e.target.value })
              }
              required
            />
          </div>

          <button
            type="submit"
            className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">
            Save Template
          </button>
        </form>
      </div>

      {/* LIST */}
      {loading ? (
        <p>Loading...</p>
      ) : error ? (
        <p className="text-red-500">{error}</p>
      ) : (
        <table className="w-full border-collapse border">
          <thead>
            <tr className="bg-gray-100">
              <th className="border p-2 text-left">Name</th>
              <th className="border p-2 text-left">Type</th>
              <th className="border p-2 text-left">Subject</th>
              <th className="border p-2 text-left">Preview</th>
              <th className="border p-2 text-center">Actions</th>
            </tr>
          </thead>
          <tbody>
            {templates.map((t) => (
              <tr key={t.id} className="hover:bg-gray-50">
                <td className="border p-2 font-medium">{t.name}</td>
                <td className="border p-2">
                  <span
                    className={`px-2 py-1 rounded text-xs ${
                      t.type === "Email"
                        ? "bg-blue-100 text-blue-800"
                        : "bg-green-100 text-green-800"
                    }`}>
                    {t.type}
                  </span>
                </td>
                <td className="border p-2 text-gray-600">{t.subject || "â€”"}</td>
                <td className="border p-2 text-gray-500 text-sm">
                  {t.content.substring(0, 50)}
                  {t.content.length > 50 && "..."}
                </td>
                <td className="border p-2 text-center">
                  <button
                    onClick={() => handleDelete(t.id)}
                    className="text-red-600 hover:underline text-sm">
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}


// ==========================================
// FILE: frontend_harness/src/components/FinancialsSection.tsx 
// ==========================================
import { useCallback, useEffect, useState } from "react";
import type { EventFinancials, Expense } from "../types";
import { getEventFinancials, addExpense, upsertBudget } from "../apiClient";
import BudgetOverview from "./BudgetOverview";

interface Props {
  eventId: string;
  // NEW PROP: Accepts a key from the parent to force reload
  refreshKey: number;
}

export default function FinancialsSection({ eventId, refreshKey }: Props) {
  const [financials, setFinancials] = useState<EventFinancials | null>(null);
  const [loading, setLoading] = useState(true);

  // Form State
  const [showAddExpense, setShowAddExpense] = useState(false);
  const [newExpense, setNewExpense] = useState({
    description: "",
    amount: 0,
    category: "General",
    dateIncurred: new Date().toISOString().split("T")[0],
  });

  // Renamed loadData to fetchFinancials for clarity
  const fetchFinancials = useCallback(async () => {
    try {
      setLoading(true);
      const data = await getEventFinancials(eventId);
      setFinancials(data);
    } catch (error) {
      console.error("Failed to load financials", error);
    } finally {
      setLoading(false);
    }
  }, [eventId]); // Dependency: Only changes if the eventId itself changes

  // FIX: Reruns fetchFinancials whenever eventId OR refreshKey changes
  // The 'refreshKey' forces a re-render/re-fetch whenever the parent updates the key.
  useEffect(() => {
    fetchFinancials();
  }, [fetchFinancials, refreshKey]); // Added refreshKey as a direct trigger

  const handleCreateBudget = async () => {
    const amountStr = prompt("Enter Total Budget Amount:", "10000");
    if (!amountStr) return;
    await upsertBudget(eventId, parseFloat(amountStr), "USD", "Initial Budget");
    fetchFinancials();
  };

  const handleSubmitExpense = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newExpense.amount || !newExpense.description) return;

    await addExpense(
      eventId,
      newExpense.description,
      newExpense.amount,
      new Date(newExpense.dateIncurred).toISOString(),
      newExpense.category
    );

    setShowAddExpense(false);
    setNewExpense({
      description: "",
      amount: 0,
      category: "General",
      dateIncurred: new Date().toISOString().split("T")[0],
    });
    fetchFinancials();
  };

  if (loading)
    return (
      <div className="p-8 text-center text-gray-400">Calculating Ledger...</div>
    );

  // Scenario 1: No Budget Exists
  if (
    !financials ||
    (financials.budgetTotal === 0 && financials.expenses.length === 0)
  ) {
    return (
      <div className="text-center p-12 bg-[#333] rounded-xl border border-dashed border-gray-600 mb-8">
        <h3 className="text-lg font-medium text-white">No Budget Set</h3>
        <p className="mt-1 text-gray-400">
          Initialize a budget to start tracking expenses.
        </p>
        <button
          onClick={handleCreateBudget}
          className="mt-4 px-6 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition-colors">
          Create Budget
        </button>
      </div>
    );
  }

  return (
    <div className="space-y-8">
      <BudgetOverview data={financials} onEditBudget={handleCreateBudget} />

      <div className="flex justify-between items-center mb-4">
        <h3 className="text-xl font-bold text-white">Expenses</h3>
        <button
          onClick={() => setShowAddExpense(!showAddExpense)}
          className="px-4 py-2 bg-indigo-600 text-white rounded-md text-sm hover:bg-indigo-700 font-medium transition-colors">
          {showAddExpense ? "Cancel" : "+ Add Expense"}
        </button>
      </div>

      {showAddExpense && (
        <form
          onSubmit={handleSubmitExpense}
          className="bg-[#444] p-6 rounded-lg mb-6 border border-gray-600 grid grid-cols-1 md:grid-cols-4 gap-4 items-end">
          <div className="md:col-span-2">
            <label className="block text-xs font-medium text-gray-300 mb-1">
              Description
            </label>
            <input
              type="text"
              value={newExpense.description}
              onChange={(e) =>
                setNewExpense({ ...newExpense, description: e.target.value })
              }
              className="w-full rounded bg-[#333] border-gray-600 text-white p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500"
              required
            />
          </div>
          <div>
            <label className="block text-xs font-medium text-gray-300 mb-1">
              Amount ($)
            </label>
            <input
              type="number"
              value={newExpense.amount}
              onChange={(e) =>
                setNewExpense({
                  ...newExpense,
                  amount: parseFloat(e.target.value),
                })
              }
              className="w-full rounded bg-[#333] border-gray-600 text-white p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500"
              required
            />
          </div>
          <div>
            <label className="block text-xs font-medium text-gray-300 mb-1">
              Category
            </label>
            <select
              value={newExpense.category}
              onChange={(e) =>
                setNewExpense({ ...newExpense, category: e.target.value })
              }
              className="w-full rounded bg-[#333] border-gray-600 text-white p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500">
              {[
                "General",
                "Venue",
                "Catering",
                "Talent",
                "Production",
                "Marketing",
              ].map((c) => (
                <option key={c} value={c}>
                  {c}
                </option>
              ))}
            </select>
          </div>
          <button
            type="submit"
            className="bg-emerald-600 text-white py-2 px-4 rounded hover:bg-emerald-700 font-medium">
            Save
          </button>
        </form>
      )}

      <div className="bg-[#333] border border-gray-600 rounded-lg overflow-hidden shadow-md">
        <table className="table-fixed w-full text-left">
          <thead className="bg-[#222] text-gray-300 uppercase text-xs tracking-wider border-b border-gray-600">
            <tr>
              <th className="px-6 py-4 w-[15%]">Date</th>
              <th className="px-6 py-4 w-[35%]">Description</th>
              <th className="px-6 py-4 w-[15%]">Category</th>
              <th className="px-6 py-4 w-[15%]">Vendor</th>
              <th className="px-6 py-4 w-[20%] text-right">Amount</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-700">
            {financials.expenses.map((expense: Expense) => (
              <tr
                key={expense.id}
                className="hover:bg-[#383838] transition-colors">
                <td className="px-6 py-4 text-sm text-gray-300">
                  {new Date(expense.dateIncurred).toLocaleDateString()}
                </td>
                <td className="px-6 py-4 text-sm font-medium text-white">
                  {expense.description}
                  {expense.linkedDocumentName && (
                    <span className="ml-2 px-2 py-0.5 bg-blue-900 text-blue-200 text-xs rounded-full border border-blue-700">
                      Invoice
                    </span>
                  )}
                </td>
                <td className="px-6 py-4 text-sm text-gray-300">
                  <span className="px-2 py-1 text-xs font-semibold rounded-full bg-[#444] text-gray-200 border border-gray-600">
                    {expense.category}
                  </span>
                </td>
                <td className="px-6 py-4 text-sm text-gray-300">
                  {expense.vendorName || "-"}
                </td>
                <td className="px-6 py-4 text-sm text-right font-mono font-medium text-emerald-400">
                  ${expense.amount.toLocaleString()}
                </td>
              </tr>
            ))}
            {financials.expenses.length === 0 && (
              <tr>
                <td
                  colSpan={5}
                  className="px-6 py-8 text-center text-sm text-gray-500">
                  No expenses recorded yet.
                </td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
}


// ==========================================
// FILE: frontend_harness/src/components/VendorEventsTable.tsx 
// ==========================================
import React, { useState, useEffect, useCallback } from "react";
import { apiClient } from "../apiClient";
import type { EventDto, Guid } from "../types";

interface VendorEventsTableProps {
  vendorId: Guid;
}

const VendorEventsTable: React.FC<VendorEventsTableProps> = ({ vendorId }) => {
  const [events, setEvents] = useState<EventDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // FIX: Wrap in useCallback to satisfy ESLint and allow usage in useEffect + Retry button
  const fetchEvents = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const response = await apiClient.get<EventDto[]>(
        `/api/vendors/${vendorId}/events`
      );
      setEvents(response.data);
    } catch (err) {
      console.error("Error fetching events for vendor:", err);
      setError("Failed to load events.");
    } finally {
      setLoading(false);
    }
  }, [vendorId]); // Re-create function only if vendorId changes

  useEffect(() => {
    if (vendorId) {
      fetchEvents();
    }
  }, [fetchEvents, vendorId]); // FIX: Added fetchEvents dependency

  if (loading) return <div style={{ padding: "10px" }}>Loading events...</div>;

  if (error)
    return (
      <div style={{ color: "red", padding: "10px" }}>
        {error} <button onClick={fetchEvents}>Retry</button>
      </div>
    );

  return (
    <div style={{ marginBottom: "30px" }}>
      <h3>Events Hired For ({events.length})</h3>
      {events.length === 0 ? (
        <p>This vendor is not currently linked to any events.</p>
      ) : (
        <table style={{ width: "100%", borderCollapse: "collapse" }}>
          <thead>
            <tr style={{ borderBottom: "2px solid #ccc" }}>
              <th style={{ padding: "8px", textAlign: "left" }}>Event Name</th>
              <th style={{ padding: "8px", textAlign: "left" }}>Date</th>
              <th style={{ padding: "8px", textAlign: "left" }}>Status</th>
            </tr>
          </thead>
          <tbody>
            {events.map((event) => (
              <tr key={event.id} style={{ borderBottom: "1px solid #eee" }}>
                <td style={{ padding: "8px" }}>{event.name}</td>
                <td style={{ padding: "8px" }}>
                  {new Date(event.startDateTime).toLocaleDateString()}
                </td>
                <td style={{ padding: "8px" }}>{event.status}</td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
};

export default VendorEventsTable;


// ==========================================
// FILE: frontend_harness/src/components/ContactsPage.tsx 
// ==========================================
// =======================================================
// FILE: frontend_harness/src/components/ContactsPage.tsx
// =======================================================
import { useEffect, useState } from "react";
import { apiClient } from "../apiClient";
import type { ContactDto } from "../types";
import { LeadStage, ConnectionStatus } from "../types";
import axios from "axios";

import { useSelectionContext } from "../context/useSelectionContext";
import {
  RelatedTasks,
  RelatedNotes,
  ContactEventsTable,
  EmailHistoryTable,
} from "./RelatedTables";

type ContactFormData = Omit<ContactDto, "id">;

type ValidationErrors = {
  [key: string]: string[];
};

// Local definition for Template to avoid editing types.ts in this turn
type TemplateDto = {
  id: string;
  name: string;
  content: string;
};

const styleSheet = document.createElement("style");
styleSheet.type = "text/css";
styleSheet.innerText = `
  .contact-row:hover {
    cursor: pointer;
    background-color: #333;
  }
  .selected-row {
    background-color: #004a99;
    color: white;
  }
  .selected-row:hover {
    background-color: #005ac7;
  }
  .modal-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  .modal-content {
    background: #222;
    padding: 2rem;
    border: 1px solid #555;
    min-width: 400px;
    border-radius: 8px;
  }
`;
document.head.appendChild(styleSheet);

function ContactsPage() {
  const [contacts, setContacts] = useState<ContactDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // --- Email Scheduling State ---
  const [templates, setTemplates] = useState<TemplateDto[]>([]);
  const [isEmailModalOpen, setIsEmailModalOpen] = useState(false);
  const [emailConfig, setEmailConfig] = useState({
    contactId: "",
    contactName: "", // For display
    templateId: "",
    sendAt: "",
  });
  // ------------------------------

  const initialFormState: ContactFormData = {
    firstName: "",
    lastName: "",
    email: "",
    phoneNumber: null,
    title: null,
    organization: null,
    // New Pipeline Fields
    stage: LeadStage.NewLead,
    connectionStatus: ConnectionStatus.NeedToMeet,
    isLead: true,
    followUpCount: 0,
    source: null,
    lastContactedAt: null,
  };

  const [formData, setFormData] =
    useState<Partial<ContactDto>>(initialFormState);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<ValidationErrors>(
    {}
  );

  const { selectedContactId, setSelectedContactId } = useSelectionContext();

  const isEditing = editingId !== null;

  const fetchContacts = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiClient.get<ContactDto[]>("/api/contacts");
      setContacts(response.data);
    } catch (err: unknown) {
      console.error(err);
      let errorMessage = "Failed to fetch contacts. An unknown error occurred.";
      if (err instanceof Error) {
        errorMessage = `Failed to fetch contacts: ${err.message}`;
      }
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  // Fetch Templates for the dropdown
  const fetchTemplates = async () => {
    try {
      const response = await apiClient.get<TemplateDto[]>("/api/templates");
      setTemplates(response.data);
    } catch (err) {
      console.error("Failed to load templates", err);
    }
  };

  useEffect(() => {
    fetchContacts();
    fetchTemplates();
    return () => {
      setSelectedContactId(null);
    };
  }, [setSelectedContactId]);

  const handleDelete = async (id: string) => {
    if (!window.confirm("Are you sure you want to delete this contact?")) {
      return;
    }

    if (id === selectedContactId) {
      setSelectedContactId(null);
    }

    try {
      await apiClient.delete(`/api/contacts/${id}`);
      await fetchContacts();
    } catch (err) {
      console.error(err);
      if (err instanceof Error) {
        alert(`Failed to delete contact: ${err.message}`);
      }
    }
  };

  const handleEdit = (contact: ContactDto) => {
    setEditingId(contact.id);
    setFormData(contact);
    setValidationErrors({});
    window.scrollTo(0, 0);
  };

  const handleCancel = () => {
    setEditingId(null);
    setFormData(initialFormState);
    setValidationErrors({});
  };

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>
  ) => {
    const { name, value, type } = e.target;

    setFormData((prev) => {
      let newValue: string | number | boolean | null =
        value === "" ? null : value;

      // Handle Numeric Enums (Stage & ConnectionStatus)
      if (name === "stage" || name === "connectionStatus") {
        newValue = parseInt(value, 10);
      }

      // Handle Checkbox
      if (type === "checkbox") {
        newValue = (e.target as HTMLInputElement).checked;
      }

      return {
        ...prev,
        [name]: newValue,
      };
    });
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setValidationErrors({});

    const payload = {
      ...formData,
      firstName: formData.firstName ?? "",
      lastName: formData.lastName ?? "",
      email: formData.email ?? "",
      stage: formData.stage ?? LeadStage.NewLead,
      connectionStatus:
        formData.connectionStatus ?? ConnectionStatus.NeedToMeet,
      isLead: formData.isLead ?? true,
      followUpCount: formData.followUpCount ?? 0,
    };

    const promise = isEditing
      ? apiClient.put(`/api/contacts/${editingId}`, payload)
      : apiClient.post("/api/contacts", payload);

    try {
      await promise;
      handleCancel();
      await fetchContacts();
    } catch (err: unknown) {
      if (axios.isAxiosError(err) && err.response?.status === 400) {
        const apiErrors = err.response.data.errors || {
          General: ["An unknown validation error occurred."],
        };
        setValidationErrors(apiErrors);
      } else {
        console.error(err);
        alert("An unexpected error occurred.");
      }
    }
  };

  const handleRowClick = (contactId: string) => {
    if (isEditing) {
      handleCancel();
    }

    if (selectedContactId === contactId) {
      setSelectedContactId(null);
    } else {
      setSelectedContactId(contactId);
    }
  };

  // --- Email Modal Handlers ---
  const openEmailModal = (e: React.MouseEvent, contact: ContactDto) => {
    e.stopPropagation(); // Prevent row selection
    setEmailConfig({
      contactId: contact.id,
      contactName: `${contact.firstName} ${contact.lastName}`,
      templateId: templates.length > 0 ? templates[0].id : "",
      sendAt: "",
    });
    setIsEmailModalOpen(true);
  };

  const handleEmailSubmit = async () => {
    if (!emailConfig.templateId) {
      alert("Please select a template.");
      return;
    }

    try {
      await apiClient.post("/api/automation/schedule-email", {
        contactId: emailConfig.contactId,
        templateId: emailConfig.templateId,
        sendAt: emailConfig.sendAt
          ? new Date(emailConfig.sendAt).toISOString()
          : null,
      });
      alert("Email scheduled successfully!");
      setIsEmailModalOpen(false);
    } catch (err) {
      console.error(err);
      alert("Failed to schedule email.");
    }
  };
  // ----------------------------

  if (error) return <p style={{ color: "red" }}>{error}</p>;

  return (
    <div>
      {/* --- Email Modal --- */}
      {isEmailModalOpen && (
        <div className="modal-overlay">
          <div className="modal-content">
            <h3>Send Email to: {emailConfig.contactName}</h3>

            <div style={{ marginBottom: "1rem" }}>
              <label style={{ display: "block", marginBottom: "0.5rem" }}>
                Select Template:
              </label>
              <select
                style={{ width: "100%", padding: "0.5rem" }}
                value={emailConfig.templateId}
                onChange={(e) =>
                  setEmailConfig((prev) => ({
                    ...prev,
                    templateId: e.target.value,
                  }))
                }>
                <option value="">-- Select a Template --</option>
                {templates.map((t) => (
                  <option key={t.id} value={t.id}>
                    {t.name}
                  </option>
                ))}
              </select>
            </div>

            <div style={{ marginBottom: "1rem" }}>
              <label style={{ display: "block", marginBottom: "0.5rem" }}>
                Send At (Optional):
              </label>
              <input
                type="datetime-local"
                style={{ width: "100%", padding: "0.5rem" }}
                value={emailConfig.sendAt}
                onChange={(e) =>
                  setEmailConfig((prev) => ({
                    ...prev,
                    sendAt: e.target.value,
                  }))
                }
              />
              <small>Leave blank to send immediately.</small>
            </div>

            <div
              style={{
                display: "flex",
                justifyContent: "flex-end",
                gap: "1rem",
              }}>
              <button onClick={() => setIsEmailModalOpen(false)}>Cancel</button>
              <button
                onClick={handleEmailSubmit}
                style={{ backgroundColor: "#004a99", color: "white" }}>
                Send Email
              </button>
            </div>
          </div>
        </div>
      )}

      <div
        style={{
          marginBottom: "2rem",
          padding: "1rem",
          border: "1px solid #555",
        }}>
        <h2>{isEditing ? "Edit Contact" : "Create Contact"}</h2>
        <form onSubmit={handleSubmit}>
          {/* --- Identity Fields --- */}
          <div style={{ display: "flex", gap: "1rem" }}>
            <div style={{ marginBottom: "0.5rem", flex: 1 }}>
              <label>First Name: </label>
              <input
                name="firstName"
                value={formData.firstName ?? ""}
                onChange={handleChange}
                style={{ width: "100%" }}
              />
              {validationErrors.FirstName && (
                <div style={{ color: "red" }}>
                  {validationErrors.FirstName[0]}
                </div>
              )}
            </div>
            <div style={{ marginBottom: "0.5rem", flex: 1 }}>
              <label>Last Name: </label>
              <input
                name="lastName"
                value={formData.lastName ?? ""}
                onChange={handleChange}
                style={{ width: "100%" }}
              />
              {validationErrors.LastName && (
                <div style={{ color: "red" }}>
                  {validationErrors.LastName[0]}
                </div>
              )}
            </div>
          </div>

          <div style={{ display: "flex", gap: "1rem" }}>
            <div style={{ marginBottom: "0.5rem", flex: 1 }}>
              <label>Email: </label>
              <input
                name="email"
                value={formData.email ?? ""}
                onChange={handleChange}
                style={{ width: "100%" }}
              />
              {validationErrors.Email && (
                <div style={{ color: "red" }}>{validationErrors.Email[0]}</div>
              )}
            </div>
            <div style={{ marginBottom: "0.5rem", flex: 1 }}>
              <label>Phone: </label>
              <input
                name="phoneNumber"
                value={formData.phoneNumber ?? ""}
                onChange={handleChange}
                style={{ width: "100%" }}
              />
            </div>
          </div>

          {/* --- Pipeline & Strategy Fields (NEW) --- */}
          <div
            style={{
              margin: "1rem 0",
              padding: "1rem",
              border: "1px dashed #666",
              borderRadius: "4px",
            }}>
            <h4 style={{ marginTop: 0, marginBottom: "0.5rem" }}>
              Pipeline Status
            </h4>
            <div style={{ display: "flex", gap: "1rem", flexWrap: "wrap" }}>
              {/* Stage Dropdown */}
              <div style={{ flex: 1 }}>
                <label>Lead Stage: </label>
                <select
                  name="stage"
                  value={formData.stage ?? LeadStage.NewLead}
                  onChange={handleChange}
                  style={{ width: "100%", padding: "4px" }}>
                  {Object.entries(LeadStage).map(([key, value]) => (
                    <option key={key} value={value}>
                      {key}
                    </option>
                  ))}
                </select>
              </div>

              {/* Connection Status Dropdown */}
              <div style={{ flex: 1 }}>
                <label>Connection Status: </label>
                <select
                  name="connectionStatus"
                  value={
                    formData.connectionStatus ?? ConnectionStatus.NeedToMeet
                  }
                  onChange={handleChange}
                  style={{ width: "100%", padding: "4px" }}>
                  {Object.entries(ConnectionStatus).map(([key, value]) => (
                    <option key={key} value={value}>
                      {key}
                    </option>
                  ))}
                </select>
              </div>

              {/* Is Lead Checkbox */}
              <div
                style={{
                  flex: "0 0 auto",
                  display: "flex",
                  alignItems: "center",
                  paddingTop: "1.2rem",
                }}>
                <label
                  style={{
                    display: "flex",
                    alignItems: "center",
                    cursor: "pointer",
                  }}>
                  <input
                    type="checkbox"
                    name="isLead"
                    checked={formData.isLead ?? true}
                    onChange={handleChange}
                    style={{ marginRight: "0.5rem" }}
                  />
                  Is Lead?
                </label>
              </div>
            </div>
          </div>

          <div style={{ marginBottom: "0.5rem" }}>
            <label>Organization: </label>
            <input
              name="organization"
              value={formData.organization ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Title: </label>
            <input
              name="title"
              value={formData.title ?? ""}
              onChange={handleChange}
            />
          </div>

          <button type="submit">{isEditing ? "Save Changes" : "Create"}</button>
          {isEditing && (
            <button
              type="button"
              onClick={handleCancel}
              style={{ marginLeft: "0.5rem" }}>
              Cancel
            </button>
          )}
          {validationErrors.General && (
            <div style={{ color: "red", marginTop: "1rem" }}>
              {validationErrors.General[0]}
            </div>
          )}
        </form>
      </div>

      <h2>Contacts List</h2>
      {loading ? (
        <p>Loading Contacts...</p>
      ) : contacts.length === 0 ? (
        <p>No contacts found.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Name</th>
              <th>Email</th>
              <th>Status</th> {/* NEW COLUMN */}
              <th>Organization</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {contacts.map((contact) => (
              <tr
                key={contact.id}
                className={`
                  contact-row 
                  ${selectedContactId === contact.id ? "selected-row" : ""}
                `}
                onClick={(e) => {
                  if (
                    e.target instanceof HTMLElement &&
                    e.target.tagName !== "BUTTON" &&
                    e.target.tagName !== "SELECT"
                  ) {
                    handleRowClick(contact.id);
                  }
                }}>
                <td>{contact.id.substring(0, 8)}...</td>
                <td>
                  {contact.firstName} {contact.lastName}
                </td>
                <td>{contact.email}</td>
                {/* NEW STATUS COLUMN */}
                <td>
                  <span
                    style={{
                      fontSize: "0.8rem",
                      padding: "2px 4px",
                      background: "#444",
                      borderRadius: "4px",
                    }}>
                    {Object.keys(LeadStage).find(
                      (key) =>
                        LeadStage[key as keyof typeof LeadStage] ===
                        contact.stage
                    )}
                  </span>
                </td>
                <td>{contact.organization ?? "N/A"}</td>
                <td>
                  <button
                    onClick={() => handleEdit(contact)}
                    style={{ color: "lightblue", marginRight: "0.5rem" }}>
                    Edit
                  </button>
                  <button
                    onClick={() => handleDelete(contact.id)}
                    style={{ color: "red", marginRight: "0.5rem" }}>
                    Delete
                  </button>
                  <button
                    onClick={(e) => openEmailModal(e, contact)}
                    style={{ color: "lightgreen" }}>
                    Send Email
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}

      {selectedContactId && (
        <div
          style={{
            borderTop: "2px solid #555",
            marginTop: "3rem",
            paddingTop: "1rem",
          }}>
          <h2>Contact Dashboard: ID {selectedContactId}</h2>
          <ContactEventsTable />
          <RelatedTasks />
          <RelatedNotes />
          <EmailHistoryTable />
        </div>
      )}
    </div>
  );
}

export default ContactsPage;


// ==========================================
// FILE: frontend_harness/src/components/EventsPage.tsx 
// ==========================================
// FILE: frontend_harness/src/components/EventsPage.tsx
import React, { useEffect, useState, useCallback } from "react";
import { apiClient } from "../apiClient";
// FIX 1: Removed unused 'Guid' import
import type { EventDto, ContactDto, VendorDto } from "../types";
import axios from "axios";
import { useSelectionContext } from "../context/useSelectionContext";
import {
  RelatedTasks,
  RelatedNotes,
  EventParticipantsTable,
} from "./RelatedTables";
import { DocumentsSection } from "./DocumentsSection";
// --- NEW: Import the Financials Module ---
import FinancialsSection from "./FinancialsSection";

type EventFormData = Omit<EventDto, "id">;
type ValidationErrors = { [key: string]: string[] };

// --- SUB-COMPONENT: EventVendorAttributesDisplay ---
interface VendorAttributeProps {
  eventVendors: VendorDto[]; // All vendors linked to the event (or fetched separately)
}

const EventVendorAttributesDisplay: React.FC<VendorAttributeProps> = ({
  eventVendors,
}) => {
  // Filter for vendors whose attributes we care about displaying prominently on the dashboard
  const featuredVendors = eventVendors.filter(
    (v) =>
      v.serviceType?.toLowerCase() === "venue" ||
      v.serviceType?.toLowerCase() === "entertainment"
  );

  if (featuredVendors.length === 0) {
    return null;
  }

  return (
    <div
      style={{
        marginTop: "20px",
        padding: "15px",
        border: "1px solid #777",
        borderRadius: "5px",
        backgroundColor: "#333",
      }}>
      <h4 style={{ margin: 0, color: "#ccc" }}>Key Vendor Attributes</h4>
      <div
        style={{
          marginTop: "10px",
          display: "flex",
          flexWrap: "wrap",
          gap: "20px",
        }}>
        {featuredVendors.map((vendor) => {
          let attributeDisplay = null;
          // FIX 2: Changed 'let title' to 'const title'
          const title = vendor.name;

          try {
            if (vendor.attributes) {
              const attrs = JSON.parse(vendor.attributes);

              if (
                vendor.serviceType?.toLowerCase() === "venue" &&
                attrs.Capacity
              ) {
                attributeDisplay = `Capacity: ${attrs.Capacity}`;
              } else if (
                vendor.serviceType?.toLowerCase() === "entertainment" &&
                attrs.Genre
              ) {
                attributeDisplay = `Genre: ${attrs.Genre}`;
              }
            }
          } catch (e) {
            console.error("Error parsing vendor attributes:", e);
          }

          if (!attributeDisplay) {
            // Skip if the required key isn't found
            return null;
          }

          return (
            <div
              key={vendor.id}
              style={{ borderLeft: "3px solid #64b5f6", paddingLeft: "10px" }}>
              <strong style={{ display: "block", color: "#fff" }}>
                {title} ({vendor.serviceType})
              </strong>
              <span style={{ color: "#aaa", fontSize: "0.9rem" }}>
                {attributeDisplay}
              </span>
            </div>
          );
        })}
      </div>
    </div>
  );
};
// --- END EventVendorAttributesDisplay ---

// --- SUB-COMPONENT: ContactLinker ---
interface ContactLinkerProps {
  eventId: string;
  onLinkSuccess: () => void;
}

const ContactLinker: React.FC<ContactLinkerProps> = ({
  eventId,
  onLinkSuccess,
}) => {
  const [contacts, setContacts] = useState<ContactDto[]>([]);
  const [selectedContactId, setSelectedContactId] = useState<string>("");
  const [loading, setLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchContacts = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<ContactDto[]>("/api/contacts");
        setContacts(response.data);
        if (response.data.length > 0) {
          setSelectedContactId(response.data[0].id);
        }
      } catch (err) {
        console.error("Failed to fetch all contacts:", err);
      } finally {
        setLoading(false);
      }
    };
    fetchContacts();
  }, []);

  const handleLink = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!selectedContactId) {
      setError("Please select a contact to link.");
      return;
    }

    setIsSubmitting(true);
    setError(null);
    try {
      const payload = { contactId: selectedContactId };
      await apiClient.post(`/api/events/${eventId}/contacts`, payload);

      onLinkSuccess();
      setError(null);
    } catch (err) {
      const message =
        axios.isAxiosError(err) && err.response?.data?.title
          ? err.response.data.title
          : "Failed to link contact to event.";
      setError(message);
    } finally {
      setIsSubmitting(false);
    }
  };

  if (loading) return <p>Loading contacts for linking...</p>;
  if (contacts.length === 0) return <p>No available contacts to link.</p>;
  return (
    <div
      style={{
        border: "1px dashed #ccc",
        padding: "1rem",
        marginBottom: "1rem",
      }}>
      <h4>Link Contact to Event</h4>
      <form onSubmit={handleLink} style={{ display: "flex", gap: "10px" }}>
        <select
          value={selectedContactId}
          onChange={(e) => setSelectedContactId(e.target.value)}
          disabled={isSubmitting}>
          {contacts.map((contact) => (
            <option key={contact.id} value={contact.id}>
              {contact.firstName} {contact.lastName} ({contact.email})
            </option>
          ))}
        </select>
        <button type="submit" disabled={isSubmitting}>
          {isSubmitting ? "Linking..." : "Link Contact"}
        </button>
      </form>
      {error && (
        <div style={{ color: "red", marginTop: "0.5rem" }}>Error: {error}</div>
      )}
    </div>
  );
};
// --- END ContactLinker ---

function EventsPage() {
  const [events, setEvents] = useState<EventDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // FIX 3: Removed unused 'allVendors' state
  const [eventVendors, setEventVendors] = useState<VendorDto[]>([]);
  // ----------------------------------

  const { selectedEventId, setSelectedEventId } = useSelectionContext();
  const [dashboardKey, setDashboardKey] = useState(0);

  const initialFormState: EventFormData = {
    name: "",
    description: null,
    startDateTime: "",
    endDateTime: "",
    location: null,
    isPublic: false,
    status: "Planned",
  };
  const [formData, setFormData] = useState<Partial<EventDto>>(initialFormState);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<ValidationErrors>(
    {}
  );

  const isEditing = editingId !== null;

  // --- PHASE 29: Fetch Vendor Data for Attribute Display (Simplified) ---
  const fetchAuxiliaryData = useCallback(async () => {
    try {
      // We only need the vendors linked to the *current* event
      // (which implicitly includes their attributes via the backend DTO)
      const eventVendorsResponse = selectedEventId
        ? await apiClient.get<VendorDto[]>(
            `/api/events/${selectedEventId}/vendors`
          )
        : { data: [] as VendorDto[] };

      setEventVendors(eventVendorsResponse.data);
    } catch (err) {
      console.error("Failed to fetch event vendor data:", err);
    }
  }, [selectedEventId]);
  // --------------------------------------------------------

  const forceDashboardRefresh = () => {
    setDashboardKey((prev) => prev + 1);
    fetchAuxiliaryData(); // Refetch vendor data when related tables change
  };

  const fetchEvents = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiClient.get<EventDto[]>("/api/events");
      setEvents(response.data);
    } catch (err: unknown) {
      console.error(err);
      setError("Failed to fetch events.");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchEvents();
  }, []);

  // --- PHASE 29: Refetch auxiliary data when event ID changes ---
  useEffect(() => {
    if (selectedEventId) {
      fetchAuxiliaryData();
    } else {
      setEventVendors([]);
    }
  }, [selectedEventId, fetchAuxiliaryData]);
  // -------------------------------------------------------------

  const handleDelete = async (id: string) => {
    if (!window.confirm("Are you sure you want to delete this event?")) return;
    try {
      await apiClient.delete(`/api/events/${id}`);
      setSelectedEventId(null);
      await fetchEvents();
    } catch (err) {
      console.error(err);
      alert("Failed to delete event.");
    }
  };

  const handleEdit = (event: EventDto) => {
    setEditingId(event.id);
    setFormData({
      ...event,
      startDateTime: event.startDateTime.slice(0, 16),
      endDateTime: event.endDateTime.slice(0, 16),
    });
    setValidationErrors({});
    window.scrollTo(0, 0);
  };

  const handleCancel = () => {
    setEditingId(null);
    setFormData(initialFormState);
    setValidationErrors({});
  };

  const handleChange = (
    e: React.ChangeEvent<
      HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement
    >
  ) => {
    const { name, value, type } = e.target;
    if (type === "checkbox") {
      setFormData((prev) => ({
        ...prev,
        [name]: (e.target as HTMLInputElement).checked,
      }));
    } else {
      setFormData((prev) => ({
        ...prev,
        [name]: value === "" ? null : value,
      }));
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setValidationErrors({});

    const payload = {
      ...formData,
      startDateTime: formData.startDateTime
        ? new Date(formData.startDateTime).toISOString()
        : "",
      endDateTime: formData.endDateTime
        ? new Date(formData.endDateTime).toISOString()
        : "",
    };
    const promise = isEditing
      ? apiClient.put(`/api/events/${editingId}`, payload)
      : apiClient.post("/api/events", payload);

    try {
      await promise;
      handleCancel();
      setSelectedEventId(null);
      await fetchEvents();
    } catch (err: unknown) {
      if (axios.isAxiosError(err) && err.response?.status === 400) {
        setValidationErrors(
          err.response.data.errors || { General: ["Validation Error"] }
        );
      } else {
        console.error(err);
        alert("An unexpected error occurred.");
      }
    }
  };

  const handleRowClick = (eventId: string) => {
    if (selectedEventId === eventId) {
      setSelectedEventId(null);
    } else {
      setSelectedEventId(eventId);
    }
    // The key update forces the entire dashboard section to remount.
    setDashboardKey((prev) => prev + 1);
  };

  if (error) return <p style={{ color: "red" }}>{error}</p>;

  return (
    <div>
      <div
        style={{
          marginBottom: "2rem",
          padding: "1rem",
          border: "1px solid #555",
        }}>
        <h2>{isEditing ? "Edit Event" : "Create Event"}</h2>
        <form onSubmit={handleSubmit}>
          {/* ... (Form fields remain the same) ... */}
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Name: </label>
            <input
              name="name"
              value={formData.name ?? ""}
              onChange={handleChange}
            />
            {validationErrors.Name && (
              <div style={{ color: "red" }}>{validationErrors.Name[0]}</div>
            )}
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Description: </label>
            <textarea
              name="description"
              value={formData.description ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Start Time: </label>
            <input
              name="startDateTime"
              type="datetime-local"
              value={formData.startDateTime ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>End Time: </label>
            <input
              name="endDateTime"
              type="datetime-local"
              value={formData.endDateTime ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Location: </label>
            <input
              name="location"
              value={formData.location ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Status: </label>
            <select
              name="status"
              value={formData.status ?? "Planned"}
              onChange={handleChange}>
              <option value="Planned">Planned</option>
              <option value="Confirmed">Confirmed</option>
              <option value="Cancelled">Cancelled</option>
            </select>
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>
              <input
                name="isPublic"
                type="checkbox"
                checked={formData.isPublic ?? false}
                onChange={handleChange}
              />
              Is Public
            </label>
          </div>

          <button type="submit">{isEditing ? "Save Changes" : "Create"}</button>
          {isEditing && (
            <button
              type="button"
              onClick={handleCancel}
              style={{ marginLeft: "0.5rem" }}>
              Cancel
            </button>
          )}
          {validationErrors.General && (
            <div style={{ color: "red", marginTop: "1rem" }}>
              {validationErrors.General[0]}
            </div>
          )}
        </form>
      </div>

      <h2>Events List (Click a row for related data)</h2>
      {loading ? (
        <p>Loading Events...</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Name</th>
              <th>Status</th>
              <th>Start</th>
              <th>End</th>
              <th>Location</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {events.map((event) => (
              <tr
                key={event.id}
                onClick={() => handleRowClick(event.id)}
                style={{
                  cursor: "pointer",
                  backgroundColor:
                    event.id === selectedEventId ? "#444" : "inherit",
                }}>
                <td>{event.id}</td>
                <td>{event.name}</td>
                <td>{event.status}</td>
                <td>{new Date(event.startDateTime).toLocaleString()}</td>
                <td>{new Date(event.endDateTime).toLocaleString()}</td>
                <td>{event.location ?? "N/A"}</td>
                <td>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      handleEdit(event);
                    }}
                    style={{ color: "blue" }}>
                    Edit
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      handleDelete(event.id);
                    }}
                    style={{ color: "red", marginLeft: "0.5rem" }}>
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}

      {/* --- DASHBOARD --- */}
      {selectedEventId && (
        <div
          key={dashboardKey}
          style={{
            borderTop: "2px solid #555",
            marginTop: "3rem",
            paddingTop: "1rem",
          }}>
          <h2 style={{ marginBottom: "2rem" }}>
            Dashboard: Event ID {selectedEventId}
          </h2>

          {/* --- PHASE 29: DISPLAY VENDOR ATTRIBUTES --- */}
          <EventVendorAttributesDisplay eventVendors={eventVendors} />
          {/* --------------------------------------------- */}

          {/* 1. Financials (High Priority) */}
          <div style={{ marginBottom: "3rem" }}>
            <FinancialsSection
              eventId={selectedEventId}
              refreshKey={dashboardKey}
            />
          </div>

          <hr style={{ margin: "2rem 0", borderColor: "#ccc" }} />

          {/* 2. Contacts & Documents */}
          <div
            style={{
              display: "grid",
              gridTemplateColumns: "1fr 1fr",
              gap: "2rem",
            }}>
            <div>
              <ContactLinker
                eventId={selectedEventId}
                onLinkSuccess={forceDashboardRefresh}
              />
              <EventParticipantsTable onUnlinkSuccess={forceDashboardRefresh} />
            </div>
            <div>
              <DocumentsSection entityId={selectedEventId} entityType="Event" />
            </div>
          </div>

          <hr style={{ margin: "2rem 0", borderColor: "#ccc" }} />

          {/* 3. Operational (Tasks & Notes) */}
          <RelatedTasks />
          <RelatedNotes />
        </div>
      )}
    </div>
  );
}

export default EventsPage;


// ==========================================
// FILE: frontend_harness/src/components/SendEmailModal.tsx 
// ==========================================
import React, { useState, useEffect } from "react";
import { templates } from "../apiClient";
import type {
  TemplateDto,
  ContactDto,
  VendorDto,
  SendTemplateEmailCommand,
} from "../types";
import { RecipientType } from "../types"; // RecipientType is a const object (runtime value), so no 'type' keyword here

interface SendEmailModalProps {
  eventId: string;
  isOpen: boolean;
  onClose: () => void;
  availableContacts: ContactDto[];
  availableVendors: VendorDto[];
}

export const SendEmailModal: React.FC<SendEmailModalProps> = ({
  eventId,
  isOpen,
  onClose,
  availableContacts,
  availableVendors,
}) => {
  const [templateList, setTemplateList] = useState<TemplateDto[]>([]);
  const [selectedTemplateId, setSelectedTemplateId] = useState<string>("");
  const [selectedRecipientId, setSelectedRecipientId] = useState<string>("");
  const [recipientType, setRecipientType] = useState<RecipientType>(
    RecipientType.Contact
  );
  const [isSending, setIsSending] = useState(false);

  useEffect(() => {
    if (isOpen) {
      loadTemplates();
    }
  }, [isOpen]);

  const loadTemplates = async () => {
    try {
      const data = await templates.getAll();
      setTemplateList(data);
    } catch (error) {
      console.error("Failed to load templates", error);
    }
  };

  const handleSend = async () => {
    if (!selectedTemplateId || !selectedRecipientId) return;

    setIsSending(true);
    try {
      const command: SendTemplateEmailCommand = {
        eventId,
        templateId: selectedTemplateId,
        targetEntityId: selectedRecipientId,
        recipientType: recipientType,
      };

      await templates.sendEmail(command);
      alert("Email sent successfully!");
      onClose();
    } catch (error) {
      console.error("Failed to send email", error);
      alert("Failed to send email.");
    } finally {
      setIsSending(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
        <h2 className="text-xl font-bold mb-4">Send Event Email</h2>

        {/* Template Selection */}
        <div className="mb-4">
          <label className="block text-sm font-medium mb-1">
            Select Template
          </label>
          <select
            className="w-full border p-2 rounded"
            value={selectedTemplateId}
            onChange={(e) => setSelectedTemplateId(e.target.value)}>
            <option value="">-- Choose a Template --</option>
            {templateList.map((t) => (
              <option key={t.id} value={t.id}>
                {t.name}
              </option>
            ))}
          </select>
        </div>

        {/* Recipient Type Toggle */}
        <div className="mb-4 flex gap-4">
          <label className="flex items-center">
            <input
              type="radio"
              name="rtype"
              checked={recipientType === RecipientType.Contact}
              onChange={() => {
                setRecipientType(RecipientType.Contact);
                setSelectedRecipientId("");
              }}
              className="mr-2"
            />
            Contact
          </label>
          <label className="flex items-center">
            <input
              type="radio"
              name="rtype"
              checked={recipientType === RecipientType.Vendor}
              onChange={() => {
                setRecipientType(RecipientType.Vendor);
                setSelectedRecipientId("");
              }}
              className="mr-2"
            />
            Vendor
          </label>
        </div>

        {/* Recipient Selection */}
        <div className="mb-6">
          <label className="block text-sm font-medium mb-1">
            Select{" "}
            {recipientType === RecipientType.Contact ? "Contact" : "Vendor"}
          </label>
          <select
            className="w-full border p-2 rounded"
            value={selectedRecipientId}
            onChange={(e) => setSelectedRecipientId(e.target.value)}>
            <option value="">-- Choose Recipient --</option>
            {recipientType === RecipientType.Contact
              ? availableContacts.map((c) => (
                  <option key={c.id} value={c.id}>
                    {c.firstName} {c.lastName} ({c.organization})
                  </option>
                ))
              : availableVendors.map((v) => (
                  <option key={v.id} value={v.id}>
                    {v.name} ({v.serviceType})
                  </option>
                ))}
          </select>
        </div>

        <div className="flex justify-end gap-2">
          <button
            onClick={onClose}
            className="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded">
            Cancel
          </button>
          <button
            onClick={handleSend}
            disabled={isSending || !selectedTemplateId || !selectedRecipientId}
            className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50">
            {isSending ? "Sending..." : "Send Email"}
          </button>
        </div>
      </div>
    </div>
  );
};


// ==========================================
// FILE: frontend_harness/src/components/FileUploader.tsx 
// ==========================================
import React, { useState } from "react";
import axios from "axios";
import { uploadDocument } from "../apiClient";
import type { Document } from "../types"; // Fix: Type-only import

interface FileUploaderProps {
  relatedEntityId: string;
  relatedEntityType: "Event" | "Vendor" | "Contact" | "Task";
  onUploadSuccess?: (document: Document) => void;
}

// Hardcoded categories for The Librarian
const DOCUMENT_CATEGORIES = [
  "General",
  "Invoice",
  "Contract",
  "Rider",
  "Marketing",
  "Legal",
];

export const FileUploader: React.FC<FileUploaderProps> = ({
  relatedEntityId,
  relatedEntityType,
  onUploadSuccess,
}) => {
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [category, setCategory] = useState<string>("General"); // Default category

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files || e.target.files.length === 0) return;

    const file = e.target.files[0];
    await handleUpload(file);
  };

  const handleUpload = async (file: File) => {
    setIsUploading(true);
    setError(null);

    try {
      // Pass the selected category to the API
      const result = await uploadDocument(
        file,
        relatedEntityId,
        relatedEntityType,
        category
      );
      if (onUploadSuccess) {
        onUploadSuccess(result);
      }
    } catch (err) {
      console.error(err);

      let errorMessage = "Failed to upload file.";

      if (axios.isAxiosError(err) && err.response?.data) {
        const data = err.response.data;
        if (typeof data === "string") {
          errorMessage = data;
        } else if (typeof data === "object") {
          if (data.message) {
            errorMessage = data.message;
            if (data.details) errorMessage += ` (${data.details})`;
          } else if (data.title) {
            errorMessage = data.title;
          } else if (data.errors) {
            errorMessage = Object.values(data.errors).flat().join(", ");
          }
        }
      } else if (err instanceof Error) {
        errorMessage = err.message;
      }

      setError(errorMessage);
    } finally {
      setIsUploading(false);
    }
  };

  return (
    <div className="p-4 border-2 border-dashed border-gray-300 rounded-lg bg-gray-50 text-center hover:bg-gray-100 transition-colors">
      {/* Category Selector */}
      <div
        style={{
          marginBottom: "1rem",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          gap: "10px",
        }}>
        <label style={{ fontSize: "0.9rem", fontWeight: "600", color: "#555" }}>
          Document Type:
        </label>
        <select
          value={category}
          onChange={(e) => setCategory(e.target.value)}
          disabled={isUploading}
          style={{
            padding: "5px 10px",
            borderRadius: "4px",
            border: "1px solid #ccc",
            fontSize: "0.9rem",
            backgroundColor: "white",
            color: "#333",
          }}>
          {DOCUMENT_CATEGORIES.map((cat) => (
            <option key={cat} value={cat}>
              {cat}
            </option>
          ))}
        </select>
      </div>

      <input
        type="file"
        id={`file-upload-${relatedEntityId}`}
        className="hidden"
        onChange={handleFileChange}
        disabled={isUploading}
      />
      <label
        htmlFor={`file-upload-${relatedEntityId}`}
        className="cursor-pointer flex flex-col items-center justify-center">
        {isUploading ? (
          <span className="text-blue-600 font-semibold">Uploading...</span>
        ) : (
          <>
            <span className="text-gray-700 font-medium">
              Click to Upload Document
            </span>
            <span className="text-xs text-gray-500 mt-1">
              (PDF, DOCX, PNG, JPG)
            </span>
          </>
        )}
      </label>

      {error && (
        <div
          style={{
            color: "red",
            marginTop: "10px",
            fontSize: "0.85rem",
            maxHeight: "100px",
            overflowY: "auto",
            textAlign: "left",
            padding: "5px",
            background: "#fff0f0",
            border: "1px solid #ffcccc",
          }}>
          <strong>Error:</strong> {error}
        </div>
      )}
    </div>
  );
};


// ==========================================
// FILE: frontend_harness/src/components/DocumentsSection.tsx 
// ==========================================
import React, { useEffect, useState } from "react";
import { apiClient, deleteDocument } from "../apiClient";
import type { Document } from "../types";
import { FileUploader } from "./FileUploader";

interface DocumentsSectionProps {
  entityId: string;
  entityType: "Event" | "Vendor" | "Contact" | "Task"; // Reusable!
}

export const DocumentsSection: React.FC<DocumentsSectionProps> = ({
  entityId,
  entityType,
}) => {
  const [documents, setDocuments] = useState<Document[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchDocuments = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<Document[]>("/api/documents", {
          params: { relatedEntityId: entityId, relatedEntityType: entityType },
        });
        setDocuments(response.data);
      } catch (err) {
        console.error("Failed to load documents", err);
      } finally {
        setLoading(false);
      }
    };

    if (entityId) fetchDocuments();
  }, [entityId, entityType]);

  const handleUploadSuccess = (newDoc: Document) => {
    setDocuments((prev) => [newDoc, ...prev]);
  };

  const handleDeleteDocument = async (id: number) => {
    if (
      !window.confirm(
        "Are you sure you want to permanently delete this document?"
      )
    )
      return;

    try {
      await deleteDocument(id);
      setDocuments((prev) => prev.filter((doc) => doc.id !== id));
    } catch (err) {
      console.error("Failed to delete document", err);
      alert("Failed to delete document.");
    }
  };

  const formatFileSize = (bytes: number) => {
    if (bytes === 0) return "0 Bytes";
    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  };

  // Helper for Category Badges
  const getCategoryColor = (cat: string) => {
    switch (cat) {
      case "Invoice":
        return "#e0f2fe"; // Light Blue
      case "Contract":
        return "#fce7f3"; // Pink
      case "Legal":
        return "#fee2e2"; // Red
      case "Marketing":
        return "#dcfce7"; // Green
      default:
        return "#f3f4f6"; // Grey
    }
  };

  const getCategoryTextColor = (cat: string) => {
    switch (cat) {
      case "Invoice":
        return "#0369a1";
      case "Contract":
        return "#be185d";
      case "Legal":
        return "#b91c1c";
      case "Marketing":
        return "#15803d";
      default:
        return "#374151";
    }
  };

  return (
    <div
      style={{
        border: "1px solid #ddd",
        borderRadius: "8px",
        padding: "1.5rem",
        marginTop: "2rem",
        backgroundColor: "#ffffff",
        color: "#333",
        boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
      }}>
      <h3
        style={{
          borderBottom: "2px solid #eee",
          paddingBottom: "0.5rem",
          marginBottom: "1rem",
          color: "#222",
        }}>
        {entityType} Documents
      </h3>

      <div style={{ marginBottom: "1.5rem" }}>
        <FileUploader
          relatedEntityId={entityId}
          relatedEntityType={entityType}
          onUploadSuccess={handleUploadSuccess}
        />
      </div>

      {loading ? (
        <p style={{ color: "#666" }}>Loading documents...</p>
      ) : documents.length === 0 ? (
        <div
          style={{
            textAlign: "center",
            padding: "2rem",
            backgroundColor: "#f9fafb",
            borderRadius: "6px",
            border: "1px dashed #ccc",
            color: "#666",
          }}>
          No documents archived.
        </div>
      ) : (
        <div style={{ overflowX: "auto" }}>
          <table
            style={{
              width: "100%",
              borderCollapse: "collapse",
              fontSize: "0.95rem",
            }}>
            <thead>
              <tr
                style={{
                  backgroundColor: "#374151",
                  color: "#ffffff",
                  textAlign: "left",
                }}>
                <th style={{ padding: "12px", borderTopLeftRadius: "6px" }}>
                  File Name
                </th>
                <th style={{ padding: "12px" }}>Category</th> {/* NEW COLUMN */}
                <th style={{ padding: "12px" }}>Size</th>
                <th style={{ padding: "12px" }}>Uploaded</th>
                <th style={{ padding: "12px", borderTopRightRadius: "6px" }}>
                  Action
                </th>
              </tr>
            </thead>
            <tbody>
              {documents.map((doc, index) => (
                <tr
                  key={doc.id}
                  style={{
                    borderBottom: "1px solid #eee",
                    backgroundColor: index % 2 === 0 ? "#fff" : "#f8f9fa",
                  }}>
                  <td
                    style={{
                      padding: "12px",
                      color: "#333",
                      fontWeight: "500",
                    }}>
                    {doc.fileName}
                  </td>
                  <td style={{ padding: "12px" }}>
                    <span
                      style={{
                        backgroundColor: getCategoryColor(doc.category),
                        color: getCategoryTextColor(doc.category),
                        padding: "4px 8px",
                        borderRadius: "12px",
                        fontSize: "0.8rem",
                        fontWeight: "600",
                      }}>
                      {doc.category || "General"}
                    </span>
                  </td>
                  <td style={{ padding: "12px", color: "#555" }}>
                    {formatFileSize(doc.size)}
                  </td>
                  <td style={{ padding: "12px", color: "#555" }}>
                    {new Date(doc.uploadedAt).toLocaleDateString()}
                  </td>
                  <td style={{ padding: "12px" }}>
                    <a
                      href={`http://localhost:5179${doc.url}`}
                      target="_blank"
                      rel="noreferrer"
                      style={{
                        color: "#2563eb",
                        fontWeight: "600",
                        textDecoration: "none",
                        marginRight: "10px",
                      }}>
                      Download
                    </a>
                    <button
                      onClick={() => handleDeleteDocument(doc.id)}
                      style={{
                        color: "#dc2626",
                        fontWeight: "600",
                        background: "none",
                        border: "none",
                        cursor: "pointer",
                      }}>
                      Delete
                    </button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );
};


// ==========================================
// FILE: frontend_harness/src/components/VendorsPage.tsx 
// ==========================================
// FILE: frontend_harness/src/components/VendorsPage.tsx

import React, { useEffect, useState, useCallback, useRef } from "react";
import { apiClient } from "../apiClient";
import type { VendorDto, Guid } from "../types";
import axios from "axios";
import { useSelectionContext } from "../context/useSelectionContext";
import { RelatedTasks, RelatedNotes } from "./RelatedTables";
import VendorEventsTable from "./VendorEventsTable";
import { DocumentsSection } from "./DocumentsSection"; // NEW: The Reusable Component

type VendorFormData = Omit<VendorDto, "id">;
type ValidationErrors = { [key: string]: string[] };

const initialFormState: VendorFormData = {
  name: "",
  phoneNumber: null,
  email: null,
  serviceType: "Other",
  attributes: null, // NEW: Include attributes
};

function VendorsPage() {
  const [vendors, setVendors] = useState<VendorDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const { selectedVendorId, setSelectedVendorId } = useSelectionContext();

  const selectedVendorIdRef = useRef(selectedVendorId);
  useEffect(() => {
    selectedVendorIdRef.current = selectedVendorId;
  }, [selectedVendorId]);

  const [formData, setFormData] =
    useState<Partial<VendorDto>>(initialFormState);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<ValidationErrors>(
    {}
  );

  // --- NEW: Dynamic Attribute State ---
  const [dynamicFields, setDynamicFields] = useState<{
    Capacity?: number | string;
    Genre?: string;
  }>({});

  const isEditing = editingId !== null;
  const selectedVendor = vendors.find((v) => v.id === selectedVendorId);

  // Function to initialize dynamic fields from the current formData.attributes
  const initializeDynamicFields = useCallback(
    (attributesString: string | null) => {
      if (!attributesString) {
        setDynamicFields({});
        return;
      }
      try {
        const parsed = JSON.parse(attributesString);
        // Set the dynamic fields, ensuring Capacity is handled as a number/string
        setDynamicFields({
          Capacity: parsed.Capacity || "",
          Genre: parsed.Genre || "",
        });
      } catch (e) {
        console.error("Failed to parse vendor attributes JSON:", e);
        setDynamicFields({});
      }
    },
    []
  );

  const fetchVendors = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiClient.get<VendorDto[]>("/api/vendors");
      setVendors(response.data);
      return response.data;
    } catch (err: unknown) {
      console.error(err);
      setError("Failed to fetch vendors.");
      return [];
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    let mounted = true;

    fetchVendors().then((data) => {
      if (mounted && data && data.length > 0 && !selectedVendorIdRef.current) {
        setSelectedVendorId(data[0].id);
      }
    });

    return () => {
      mounted = false;
      setSelectedVendorId(null);
    };
  }, [fetchVendors, setSelectedVendorId]);

  const handleDelete = async (id: string) => {
    if (!window.confirm("Are you sure you want to delete this vendor?")) return;
    try {
      await apiClient.delete(`/api/vendors/${id}`);
      if (selectedVendorId === id) {
        setSelectedVendorId(null);
      }
      await fetchVendors();
    } catch (err) {
      console.error(err);
      alert("Failed to delete vendor.");
    }
  };

  const handleEdit = (vendor: VendorDto) => {
    setEditingId(vendor.id);
    setFormData(vendor);
    initializeDynamicFields(vendor.attributes); // Initialize dynamic fields when editing
    setValidationErrors({});
    window.scrollTo(0, 0);
  };

  const handleCancel = () => {
    setEditingId(null);
    setFormData(initialFormState);
    setDynamicFields({}); // Clear dynamic fields
    setValidationErrors({});
  };

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>
  ) => {
    const { name, value } = e.target;
    // When ServiceType changes, reset the dynamic fields state
    if (name === "serviceType") {
      setDynamicFields({});
    }

    setFormData((prev) => ({
      ...prev,
      [name]: value === "" ? null : value,
    }));
  };

  // NEW: Handle changes for dynamic fields separately
  const handleDynamicChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setDynamicFields((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  const getAttributesJson = () => {
    const cleanFields = Object.entries(dynamicFields)
      .filter(([, value]) => value !== null && value !== "" && value !== 0)
      .reduce((acc, [key, value]) => {
        // Attempt to parse number fields back to number types for cleaner JSON
        if (
          key === "Capacity" &&
          typeof value === "string" &&
          !isNaN(Number(value))
        ) {
          acc[key] = Number(value);
        } else {
          acc[key] = value;
        }
        return acc;
      }, {} as Record<string, string | number>);

    if (Object.keys(cleanFields).length === 0) {
      return null;
    }
    return JSON.stringify(cleanFields);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setValidationErrors({});

    // --- PHASE 27: Inject serialized attributes into payload ---
    const attributesJson = getAttributesJson();

    const payload = {
      ...formData,
      name: formData.name ?? "",
      serviceType: formData.serviceType ?? "Other",
      attributes: attributesJson, // INJECT THE JSON STRING
    };
    // -------------------------------------------------------------

    const promise = isEditing
      ? apiClient.put(`/api/vendors/${editingId}`, payload)
      : apiClient.post("/api/vendors", payload);

    try {
      await promise;
      handleCancel();
      await fetchVendors();
    } catch (err: unknown) {
      if (axios.isAxiosError(err) && err.response?.status === 400) {
        setValidationErrors(
          err.response.data.errors || { General: ["Validation Error"] }
        );
      } else {
        console.error(err);
        alert("An unexpected error occurred.");
      }
    }
  };

  if (error) return <p style={{ color: "red" }}>{error}</p>;

  // --- NEW: Dynamic Field Renderer ---
  const renderDynamicFields = (serviceType: string | null | undefined) => {
    if (serviceType?.toLowerCase() === "venue") {
      return (
        <div style={{ marginBottom: "0.5rem" }}>
          <label>Venue Capacity: </label>
          <input
            name="Capacity"
            type="number"
            value={dynamicFields.Capacity ?? ""}
            onChange={handleDynamicChange}
            placeholder="Max Capacity (e.g., 500)"
            style={{
              width: "100%",
              padding: "8px",
              backgroundColor: "#333",
              color: "white",
              border: "1px solid #555",
            }}
          />
        </div>
      );
    }
    if (serviceType?.toLowerCase() === "entertainment") {
      return (
        <div style={{ marginBottom: "0.5rem" }}>
          <label>Artist Genre: </label>
          <input
            name="Genre"
            type="text"
            value={dynamicFields.Genre ?? ""}
            onChange={handleDynamicChange}
            placeholder="e.g., Jazz, EDM, Acoustic"
            style={{
              width: "100%",
              padding: "8px",
              backgroundColor: "#333",
              color: "white",
              border: "1px solid #555",
            }}
          />
        </div>
      );
    }
    return null;
  };

  const renderVendorListPanel = () => (
    <div
      style={{
        flex: "0 0 350px",
        padding: "1rem",
        borderRight: "1px solid #555",
        overflowY: "auto",
      }}>
      <h2>Vendors List</h2>
      <button
        onClick={() => {
          setEditingId(null);
          setFormData(initialFormState);
          setDynamicFields({}); // Ensure state is reset
          setSelectedVendorId(null);
        }}
        style={{ marginBottom: "1rem", padding: "10px" }}>
        + Add New Vendor
      </button>

      {loading ? (
        <p>Loading Vendors...</p>
      ) : (
        <ul style={{ listStyle: "none", padding: 0 }}>
          {vendors.map((vendor) => (
            <li
              key={vendor.id}
              onClick={() => setSelectedVendorId(vendor.id as Guid)}
              style={{
                padding: "10px",
                marginBottom: "5px",
                cursor: "pointer",
                border: "1px solid #555",
                backgroundColor:
                  vendor.id === selectedVendorId ? "#444" : "#2a2a2a",
                borderRadius: "4px",
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                color: "white",
              }}>
              <div>
                <strong>{vendor.name}</strong> <br />
                <span style={{ fontSize: "0.8rem", color: "#ccc" }}>
                  {vendor.serviceType}
                  {/* NEW: Display a dynamic attribute if present */}
                  {vendor.attributes &&
                    (() => {
                      try {
                        const attrs = JSON.parse(vendor.attributes);
                        if (attrs.Capacity)
                          return ` | Capacity: ${attrs.Capacity}`;
                        if (attrs.Genre) return ` | Genre: ${attrs.Genre}`;
                        return null;
                      } catch {
                        return null; // Ignore invalid JSON
                      }
                    })()}
                </span>
              </div>
              <div style={{ fontSize: "0.8rem" }}>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    handleEdit(vendor);
                  }}
                  style={{
                    color: "#64b5f6",
                    marginRight: "5px",
                    padding: "2px 5px",
                    background: "transparent",
                    border: "none",
                    cursor: "pointer",
                  }}>
                  Edit
                </button>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    handleDelete(vendor.id as Guid);
                  }}
                  style={{
                    color: "#ef5350",
                    padding: "2px 5px",
                    background: "transparent",
                    border: "none",
                    cursor: "pointer",
                  }}>
                  Delete
                </button>
              </div>
            </li>
          ))}
        </ul>
      )}
    </div>
  );

  const renderVendorDashboard = () => {
    if (isEditing || !selectedVendorId) {
      return (
        <div style={{ flex: 1, padding: "20px", overflowY: "auto" }}>
          <div
            style={{
              padding: "1rem",
              border: "1px solid #555",
              width: "100%",
            }}>
            <h2>
              {isEditing
                ? `Edit Vendor: ${selectedVendor?.name}`
                : "Create New Vendor"}
            </h2>
            <form onSubmit={handleSubmit}>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Name: </label>
                <input
                  name="name"
                  value={formData.name ?? ""}
                  onChange={handleChange}
                  style={{
                    width: "100%",
                    padding: "8px",
                    backgroundColor: "#333",
                    color: "white",
                    border: "1px solid #555",
                  }}
                />
                {validationErrors.Name && (
                  <div style={{ color: "#ef5350" }}>
                    {validationErrors.Name[0]}
                  </div>
                )}
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Email: </label>
                <input
                  name="email"
                  type="email"
                  value={formData.email ?? ""}
                  onChange={handleChange}
                  style={{
                    width: "100%",
                    padding: "8px",
                    backgroundColor: "#333",
                    color: "white",
                    border: "1px solid #555",
                  }}
                />
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Phone Number: </label>
                <input
                  name="phoneNumber"
                  value={formData.phoneNumber ?? ""}
                  onChange={handleChange}
                  style={{
                    width: "100%",
                    padding: "8px",
                    backgroundColor: "#333",
                    color: "white",
                    border: "1px solid #555",
                  }}
                />
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Service Type: </label>
                <select
                  name="serviceType"
                  value={formData.serviceType ?? "Other"}
                  onChange={handleChange}
                  style={{
                    width: "100%",
                    padding: "8px",
                    backgroundColor: "#333",
                    color: "white",
                    border: "1px solid #555",
                  }}>
                  {/* NOTE: Added Entertainment option as a requirement example */}
                  <option value="Catering">Catering</option>
                  <option value="Security">Security</option>
                  <option value="Venue">Venue</option>
                  <option value="Entertainment">Entertainment</option>
                  <option value="Florist">Florist</option>
                  <option value="Photography">Photography</option>
                  <option value="Videography">Videography</option>
                  <option value="Other">Other</option>
                </select>
              </div>

              {/* --- PHASE 27: Dynamic Attribute Fields RENDER HERE --- */}
              {renderDynamicFields(formData.serviceType)}

              {validationErrors.Attributes && (
                <div style={{ color: "#ef5350", marginTop: "0.5rem" }}>
                  {/* Display validation error for the JSON field */}
                  {validationErrors.Attributes[0]}
                </div>
              )}
              {/* -------------------------------------------------------- */}

              <button
                type="submit"
                style={{
                  marginTop: "10px",
                  padding: "10px 20px",
                  cursor: "pointer",
                }}>
                {isEditing ? "Save Changes" : "Create"}
              </button>
              {isEditing && (
                <button
                  type="button"
                  onClick={handleCancel}
                  style={{
                    marginLeft: "0.5rem",
                    marginTop: "10px",
                    padding: "10px 20px",
                    cursor: "pointer",
                  }}>
                  Cancel
                </button>
              )}
              {validationErrors.General && (
                <div style={{ color: "#ef5350", marginTop: "1rem" }}>
                  {validationErrors.General[0]}
                </div>
              )}
            </form>
          </div>
        </div>
      );
    }

    const vendorIdString = selectedVendorId as string;

    // --- PHASE 27: Dashboard View ---
    const parsedAttributes = selectedVendor?.attributes
      ? JSON.parse(selectedVendor.attributes)
      : {};

    const attributeDisplay = Object.entries(parsedAttributes).map(
      ([key, value]) => (
        <p key={key}>
          <strong>{key}:</strong> {value as string}
        </p>
      )
    );

    return (
      <div style={{ flex: 1, padding: "20px", overflowY: "auto" }}>
        <h1>Vendor Command Center: {selectedVendor?.name}</h1>
        <div
          style={{
            marginBottom: "20px",
            padding: "15px",
            border: "1px solid #555",
            borderRadius: "5px",
            width: "100%",
          }}>
          <h3>Details</h3>
          <p>
            <strong>ID:</strong> {selectedVendor?.id}
          </p>
          <p>
            <strong>Type:</strong> {selectedVendor?.serviceType}
          </p>
          <p>
            <strong>Contact Info:</strong> {selectedVendor?.phoneNumber} /{" "}
            {selectedVendor?.email}
          </p>
          {/* NEW: Dynamic Attribute Display */}
          {attributeDisplay.length > 0 && (
            <div
              style={{
                marginTop: "10px",
                borderTop: "1px dashed #666",
                paddingTop: "10px",
              }}>
              <h4>Specific Attributes</h4>
              {attributeDisplay}
            </div>
          )}
        </div>

        <h2 style={{ marginTop: "30px" }}>Related Data</h2>

        {/* NEW: Reusable Documents Section for Vendors */}
        <DocumentsSection entityId={vendorIdString} entityType="Vendor" />

        <VendorEventsTable vendorId={vendorIdString as Guid} />
        <RelatedTasks vendorId={vendorIdString} />
        <RelatedNotes vendorId={vendorIdString} />
      </div>
    );
  };

  return (
    <div style={{ display: "flex", height: "100%", minHeight: "800px" }}>
      {renderVendorListPanel()}
      {renderVendorDashboard()}
    </div>
  );
}

export default VendorsPage;


// ==========================================
// FILE: frontend_harness/src/components/NotesPage.tsx 
// ==========================================
// FILE: frontend_harness/src/components/NotesPage.tsx

import { useState, useEffect, type FormEvent } from "react";
import { apiClient } from "../apiClient";
import { type NoteDto, type CreateNoteDto } from "../types";
import { AxiosError } from "axios";

// Define an explicit type for the data sent in the command,
// including the new lookup fields for clarity
type NoteCommandData = Omit<CreateNoteDto, "vendorName"> & {
  contactEmail?: string;
  eventName?: string;
  vendorName?: string; // This maps to the backend VendorName field in the command
  taskTitle?: string;
};

type UpdateNoteDto = Pick<NoteDto, "id" | "content">;

const NotesPage = () => {
  const [notes, setNotes] = useState<NoteDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Form state for creating a new note
  const initialNewNoteState: Partial<NoteCommandData> = {
    content: "",
    contactId: null,
    eventId: null,
    taskId: null,
    vendorId: null,
    // String lookup fields
    contactEmail: undefined,
    eventName: undefined,
    vendorName: undefined,
    taskTitle: undefined,
  };

  const [newNote, setNewNote] =
    useState<Partial<NoteCommandData>>(initialNewNoteState);

  // State for which note is being edited
  const [editingNote, setEditingNote] = useState<NoteDto | null>(null);

  // --- NEW: PHASE 29 Dynamic Linkage State ---
  const [entityTypeToLink, setEntityTypeToLink] = useState<
    "Contact" | "Event" | "Vendor" | "Task" | null
  >(null);
  const [linkValue, setLinkValue] = useState("");
  // ------------------------------------------

  const fetchNotes = async () => {
    try {
      setLoading(true);
      const response = await apiClient.get<NoteDto[]>("/api/notes");
      setNotes(response.data);
      setError(null);
    } catch (err) {
      setError("Failed to fetch notes.");
      console.error(err);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchNotes();
  }, []);

  // --- PHASE 29: Dynamic Linkage Handlers ---
  const handleEntityTypeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const type = e.target.value as
      | "Contact"
      | "Event"
      | "Vendor"
      | "Task"
      | "None";
    setEntityTypeToLink(type === "None" ? null : type);
    setLinkValue("");
    // Clear all previous link-related fields in newNote state
    setNewNote({
      ...newNote,
      contactId: null,
      eventId: null,
      taskId: null,
      vendorId: null,
      contactEmail: undefined,
      eventName: undefined,
      vendorName: undefined,
      taskTitle: undefined,
    });
  };

  const handleLinkValueChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setLinkValue(e.target.value);
  };

  const getLinkPlaceholder = () => {
    switch (entityTypeToLink) {
      case "Contact":
        return "Contact Email (e.g., jane@example.com)";
      case "Event":
        return "Event Name (e.g., Summer Gala 2026)";
      case "Vendor":
        return "Vendor Name (e.g., The Jazz Trio)";
      case "Task":
        return "Task Title (e.g., Book Venue)";
      default:
        return "Enter Name, Title, or Email";
    }
  };

  // --- PHASE 29: Payload Construction ---
  const constructCreatePayload = (): Partial<NoteCommandData> => {
    const payload: Partial<NoteCommandData> = {
      content: newNote.content,
    };

    if (entityTypeToLink === "Contact" && linkValue) {
      payload.contactEmail = linkValue;
    } else if (entityTypeToLink === "Event" && linkValue) {
      payload.eventName = linkValue;
    } else if (entityTypeToLink === "Vendor" && linkValue) {
      payload.vendorName = linkValue; // Maps to VendorName on backend command
    } else if (entityTypeToLink === "Task" && linkValue) {
      payload.taskTitle = linkValue;
    }
    // If IDs were manually put in (or if no dynamic link is selected,
    // they are sent as null/undefined, which is fine)

    return payload;
  };
  // ------------------------------------------

  const handleCreateSubmit = async (e: FormEvent) => {
    e.preventDefault();

    if (!newNote.content) {
      setError("Content is required.");
      return;
    }

    const payload = constructCreatePayload();

    try {
      // NOTE: We don't map string lookups to GUIDs on the FE. The FE only sends
      // the string values and the BE handler resolves them.
      const response = await apiClient.post<NoteDto>("/api/notes", payload);
      setNotes([response.data, ...notes]);

      setNewNote(initialNewNoteState); // Reset form
      setEntityTypeToLink(null);
      setLinkValue("");

      setError(null);
    } catch (err: unknown) {
      console.error(err);
      if (err instanceof AxiosError && err.response?.data?.errors) {
        // Find the 'Must Have At Least One Link' error and present it clearly
        const validationMessage = Object.values(err.response.data.errors)
          .flat()
          .join(", ");
        setError(
          validationMessage ||
            "Failed to create note. Ensure at least one ID is provided."
        );
      } else {
        setError("Failed to create note. Ensure at least one ID is provided.");
      }
    }
  };

  const handleUpdateSubmit = async (e: FormEvent) => {
    e.preventDefault();
    if (!editingNote) return;

    const updatePayload: UpdateNoteDto = {
      id: editingNote.id,
      content: editingNote.content,
    };
    try {
      await apiClient.put(`/api/notes/${editingNote.id}`, updatePayload);
      setNotes(notes.map((n) => (n.id === editingNote.id ? editingNote : n)));
      setEditingNote(null);
      setError(null);
    } catch (err: unknown) {
      console.error(err);
      setError("Failed to update note.");
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm("Are you sure you want to delete this note?")) {
      try {
        await apiClient.delete(`/api/notes/${id}`);
        setNotes(notes.filter((n) => n.id !== id));
        setError(null);
      } catch (err) {
        setError("Failed to delete note.");
        console.error(err);
      }
    }
  };

  // --- Render Logic ---

  if (loading) return <p>Loading notes...</p>;
  return (
    <div className="module-page">
      <h2>Notes Module</h2>
      {error && (
        <p className="error-message" style={{ color: "red" }}>
          {error}
        </p>
      )}

      {/* --- Create or Edit Form --- */}
      <form onSubmit={editingNote ? handleUpdateSubmit : handleCreateSubmit}>
        <h3>{editingNote ? "Edit Note" : "Create New Note"}</h3>
        <textarea
          placeholder="Note content..."
          value={editingNote ? editingNote.content : newNote.content}
          onChange={(e) =>
            editingNote
              ? setEditingNote({ ...editingNote, content: e.target.value })
              : setNewNote({ ...newNote, content: e.target.value })
          }
        />

        {/* --- Foreign Key Inputs (Dynamic Link for Create) --- */}
        {!editingNote && (
          <fieldset
            style={{
              border: "1px dashed #666",
              padding: "1rem",
              margin: "1rem 0",
            }}>
            <legend style={{ padding: "0 0.5rem" }}>
              Attach Note By ID or Lookup
            </legend>

            {/* Link Type Selector */}
            <div style={{ marginBottom: "0.5rem" }}>
              <label style={{ display: "block" }}>Link Type:</label>
              <select
                value={entityTypeToLink ?? "None"}
                onChange={handleEntityTypeChange}
                style={{ width: "100%", padding: "4px" }}>
                <option value="None">-- Select Entity Type --</option>
                <option value="Contact">Contact (by Email)</option>
                <option value="Event">Event (by Name)</option>
                <option value="Vendor">Vendor (by Name)</option>
                <option value="Task">Task (by Title)</option>
              </select>
            </div>

            {/* Lookup Value Input */}
            {entityTypeToLink && (
              <div style={{ marginBottom: "0.5rem" }}>
                <label style={{ display: "block" }}>Lookup Value:</label>
                <input
                  type={entityTypeToLink === "Contact" ? "email" : "text"}
                  value={linkValue}
                  onChange={handleLinkValueChange}
                  placeholder={getLinkPlaceholder()}
                  style={{ width: "100%" }}
                />
              </div>
            )}

            <p style={{ fontSize: "0.8rem", color: "#aaa", marginTop: "1rem" }}>
              *If you use the dropdown above, only the lookup value is sent. If
              you need to link by GUID, please use the Task/Vendor/Contact
              pages.
            </p>
          </fieldset>
        )}

        <button type="submit">
          {editingNote ? "Update Note" : "Create Note"}
        </button>
        {editingNote && (
          <button type="button" onClick={() => setEditingNote(null)}>
            Cancel Edit
          </button>
        )}
      </form>

      {/* --- Notes Table --- */}
      <h3>Existing Notes</h3>
      <table className="harness-table" style={{ width: "100%" }}>
        <thead>
          <tr>
            <th>ID</th>
            <th>Content</th>
            <th>Contact ID</th>
            <th>Event ID</th>
            <th>Task ID</th>
            <th>Vendor ID</th>
            <th>Vendor Name</th> {/* Granularity */}
            <th>Created At</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {notes.map((note) => (
            <tr key={note.id}>
              <td>{note.id.substring(0, 8)}...</td>
              <td>{note.content.substring(0, 50)}...</td>
              <td>
                {note.contactId
                  ? note.contactId.substring(0, 8) + "..."
                  : "N/A"}
              </td>
              <td>
                {note.eventId ? note.eventId.substring(0, 8) + "..." : "N/A"}
              </td>
              <td>
                {note.taskId ? note.taskId.substring(0, 8) + "..." : "N/A"}
              </td>
              <td>
                {note.vendorId ? note.vendorId.substring(0, 8) + "..." : "N/A"}
              </td>
              <td>{note.vendorName ?? "N/A"}</td>
              <td>{new Date(note.createdAt).toLocaleString()}</td>
              <td>
                <button
                  className="edit-button"
                  onClick={() => setEditingNote(note)}>
                  Edit
                </button>
                <button
                  className="delete-button"
                  onClick={() => handleDelete(note.id)}>
                  Delete
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

export default NotesPage;


// ==========================================
// FILE: frontend_harness/src/components/BudgetOverview.tsx 
// ==========================================
import type { EventFinancials } from "../types";

interface Props {
  data: EventFinancials;
  onEditBudget: () => void;
}

export default function BudgetOverview({ data, onEditBudget }: Props) {
  // Color Logic: Green < 80%, Yellow < 100%, Red >= 100%
  const getProgressColor = () => {
    if (data.burnRate >= 1) return "bg-red-600";
    if (data.burnRate > 0.8) return "bg-yellow-500";
    return "bg-emerald-500";
  };

  const percentage = Math.min(data.burnRate * 100, 100);

  return (
    <div className="p-6 rounded-xl shadow-sm border border-gray-600 bg-[#333] text-white mb-8">
      {/* PHASE 26 ADDITION: BUDGET LOCK STATUS BANNER */}
      {data.isLocked ? (
        <div className="bg-red-900/50 border border-red-700 p-3 rounded-lg flex items-center mb-6">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 20 20"
            fill="currentColor"
            className="w-5 h-5 text-red-400 mr-3">
            <path
              fillRule="evenodd"
              d="M10 1a4.5 4.5 0 0 0-4.5 4.5V9H5a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2h-.5V5.5A4.5 4.5 0 0 0 10 1Zm3 8V5.5a3 3 0 1 0-6 0V9h6Z"
              clipRule="evenodd"
            />
          </svg>
          <span className="text-sm font-medium text-red-300">
            BUDGET LOCKED: Contract Signed. This budget cannot be edited.
          </span>
        </div>
      ) : (
        <div className="bg-emerald-900/50 border border-emerald-700 p-3 rounded-lg flex items-center mb-6">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 20 20"
            fill="currentColor"
            className="w-5 h-5 text-emerald-400 mr-3">
            <path d="M10 1a.75.75 0 0 1 .75.75V3a.75.75 0 1 1-1.5 0V1.75A.75.75 0 0 1 10 1ZM5.5 5.5a.75.75 0 0 0-1.5 0v2.75a.75.75 0 0 0 1.5 0V5.5ZM16 8.25a.75.75 0 0 1 1.5 0v-2.5a.75.75 0 0 1-1.5 0v2.5ZM5.5 12.5a.75.75 0 0 0-1.5 0v2.75a.75.75 0 0 0 1.5 0v-2.75ZM16 14.75a.75.75 0 0 1 1.5 0v-2.5a.75.75 0 0 1-1.5 0v2.5ZM10 6a4 4 0 0 1 4 4v.75c0 1.05.57 2.053 1.5 2.5a.75.75 0 0 1-.6 1.34c-1.288-.574-2.15-1.782-2.3-3.14h-1.3c-.15 1.358-1.012 2.566-2.3 3.14a.75.75 0 0 1-.6-1.34c.93-.447 1.5-1.45 1.5-2.5V10a4 4 0 0 1 4-4Z" />
          </svg>
          <span className="text-sm font-medium text-emerald-300">
            BUDGET UNLOCKED: Ready for updates.
          </span>
        </div>
      )}

      <div className="flex justify-between items-start mb-6">
        <div>
          <h3 className="text-xl font-bold text-white">Budget Overview</h3>
          <p className="text-sm text-gray-400 mt-1">{data.currency} Ledger</p>
        </div>
        <button
          onClick={onEditBudget}
          disabled={data.isLocked} // DISABLES BUTTON WHEN LOCKED
          className={`px-3 py-1 text-sm rounded transition-colors ${
            data.isLocked
              ? "bg-gray-800 text-gray-500 cursor-not-allowed border border-gray-700"
              : "bg-gray-700 hover:bg-gray-600 text-white border border-gray-500"
          }`}>
          {data.isLocked ? "Budget Locked" : "Edit Budget"}
        </button>
      </div>

      {/* Stat Cards */}
      <div className="grid grid-cols-3 gap-6 mb-8">
        <div className="p-4 bg-[#444] rounded-lg border border-gray-600">
          <p className="text-xs text-gray-400 uppercase tracking-wider mb-1">
            Total Budget
          </p>
          <p className="text-2xl font-bold text-white">
            ${data.budgetTotal.toLocaleString()}
          </p>
        </div>
        <div className="p-4 bg-[#444] rounded-lg border border-gray-600">
          <p className="text-xs text-gray-400 uppercase tracking-wider mb-1">
            Spent
          </p>
          <p className="text-2xl font-bold text-white">
            ${data.totalSpent.toLocaleString()}
          </p>
        </div>
        <div className="p-4 bg-[#444] rounded-lg border border-gray-600">
          <p className="text-xs text-gray-400 uppercase tracking-wider mb-1">
            Remaining
          </p>
          <p
            className={`text-2xl font-bold ${
              data.remainingBudget < 0 ? "text-red-400" : "text-emerald-400"
            }`}>
            ${data.remainingBudget.toLocaleString()}
          </p>
        </div>
      </div>

      {/* Progress Bar Section */}
      <div className="relative pt-1">
        <div className="flex mb-2 items-center justify-between text-sm">
          <span className="font-semibold uppercase tracking-wide text-gray-300">
            Burn Rate
          </span>
          <span className="font-bold text-white">
            {Math.round(data.burnRate * 100)}%
          </span>
        </div>
        <div className="overflow-hidden h-3 mb-4 text-xs flex rounded-full bg-gray-700 border border-gray-600">
          <div
            style={{ width: `${percentage}%` }}
            className={`shadow-none flex flex-col text-center whitespace-nowrap text-white justify-center ${getProgressColor()} transition-all duration-500`}></div>
        </div>
      </div>

      {data.notes && (
        <div className="mt-4 text-sm text-gray-400 italic border-l-4 border-gray-500 pl-3">
          "{data.notes}"
        </div>
      )}
    </div>
  );
}


// ==========================================
// FILE: frontend_harness/src/components/TasksPage.tsx 
// ==========================================
// FILE: frontend_harness/src/components/TasksPage.tsx (COMPLETE FILE)

import { useEffect, useState } from "react";
import { apiClient } from "../apiClient";
import type { TaskDto } from "../types";
import axios from "axios";

// Define an explicit type for the data sent in the command,
// including the new lookup fields for clarity
type TaskCommandData = Omit<TaskDto, "id" | "createdAt" | "vendorName"> & {
  contactEmail?: string;
  eventName?: string;
  vendorName?: string; // This maps to the backend VendorName field in the command
};
type ValidationErrors = { [key: string]: string[] };

function TasksPage() {
  const [tasks, setTasks] = useState<TaskDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const initialFormState: Partial<TaskCommandData> = {
    title: "",
    description: null,
    status: "NotStarted", // Default enum string
    priority: "Medium", // Default enum string
    dueDate: null,
    // Original GUID fields (cleared for the form but used in DTO)
    contactId: null,
    eventId: null,
    vendorId: null,
    // String lookup fields
    contactEmail: undefined,
    eventName: undefined,
    vendorName: undefined,
  };

  const [formData, setFormData] =
    useState<Partial<TaskCommandData>>(initialFormState);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<ValidationErrors>(
    {}
  );

  // --- NEW: PHASE 29 Dynamic Linkage State ---
  const [entityTypeToLink, setEntityTypeToLink] = useState<
    "Contact" | "Event" | "Vendor" | null
  >(null);
  const [linkValue, setLinkValue] = useState("");
  // ------------------------------------------

  const isEditing = editingId !== null;

  const fetchTasks = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiClient.get<TaskDto[]>("/api/tasks");
      setTasks(response.data);
    } catch (err: unknown) {
      console.error(err);
      setError("Failed to fetch tasks.");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchTasks();
  }, []);

  const handleDelete = async (id: string) => {
    if (!window.confirm("Are you sure you want to delete this task?")) return;
    try {
      await apiClient.delete(`/api/tasks/${id}`);
      await fetchTasks();
    } catch (err) {
      console.error(err);
      alert("Failed to delete task.");
    }
  };

  const handleEdit = (task: TaskDto) => {
    setEditingId(task.id);

    // Clear dynamic link state when editing, as the fields are GUID-based on update
    setEntityTypeToLink(null);
    setLinkValue("");

    // Format date for date input
    setFormData({
      ...task,
      dueDate: task.dueDate ? task.dueDate.slice(0, 10) : null,
      vendorId: task.vendorId ?? null,
      contactId: task.contactId ?? null,
      eventId: task.eventId ?? null,
      // Clear string lookup fields when editing an existing task by ID
      contactEmail: undefined,
      eventName: undefined,
      vendorName: undefined,
    });
    setValidationErrors({});
    window.scrollTo(0, 0);
  };

  const handleCancel = () => {
    setEditingId(null);
    setFormData(initialFormState);
    setEntityTypeToLink(null); // Reset link state
    setLinkValue(""); // Reset link value
    setValidationErrors({});
  };

  const handleChange = (
    e: React.ChangeEvent<
      HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement
    >
  ) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value === "" ? null : value,
    }));
  };

  // --- PHASE 29: Dynamic Linkage Handler ---
  const handleEntityTypeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const type = e.target.value as "Contact" | "Event" | "Vendor" | "None";
    setEntityTypeToLink(type === "None" ? null : type);
    setLinkValue("");
    // Clear all previous link-related fields in formData to prevent conflicts
    setFormData({
      ...formData,
      contactId: null,
      eventId: null,
      vendorId: null,
      contactEmail: undefined,
      eventName: undefined,
      vendorName: undefined,
    });
  };

  const handleLinkValueChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setLinkValue(e.target.value);
  };

  // --- PHASE 29: Payload Construction ---
  const constructPayload = (
    baseData: Partial<TaskCommandData>
  ): TaskCommandData => {
    const payload: Partial<TaskCommandData> = {
      ...baseData,
      description: baseData.description ?? null,
      dueDate: baseData.dueDate ?? null,
    };

    // If we are editing, we submit the GUIDs (contactId, eventId, etc.)
    // already present in formData, and string fields are undefined.
    if (isEditing) {
      return payload as TaskCommandData;
    }

    // If creating, we inject the dynamic linkage values into the string lookup fields.
    // GUID fields are null, string fields hold the lookup value.
    if (entityTypeToLink === "Contact" && linkValue) {
      payload.contactEmail = linkValue;
      payload.contactId = null; // Ensure ID is null
    } else if (entityTypeToLink === "Event" && linkValue) {
      payload.eventName = linkValue;
      payload.eventId = null; // Ensure ID is null
    } else if (entityTypeToLink === "Vendor" && linkValue) {
      payload.vendorName = linkValue; // Maps to VendorName on backend command
      payload.vendorId = null; // Ensure ID is null
    }

    return payload as TaskCommandData;
  };
  // ------------------------------------------

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setValidationErrors({});

    const payload = constructPayload(formData);

    const promise = isEditing
      ? apiClient.put(`/api/tasks/${editingId}`, payload)
      : apiClient.post("/api/tasks", payload);

    try {
      await promise;
      handleCancel();
      await fetchTasks();
    } catch (err: unknown) {
      if (axios.isAxiosError(err) && err.response?.status === 400) {
        setValidationErrors(
          err.response.data.errors || { General: ["Validation Error"] }
        );
      } else {
        console.error(err);
        alert("An unexpected error occurred.");
      }
    }
  };

  if (error) return <p style={{ color: "red" }}>{error}</p>;

  // Helper to determine the placeholder text
  const getLinkPlaceholder = () => {
    switch (entityTypeToLink) {
      case "Contact":
        return "Contact Email (e.g., jane@example.com)";
      case "Event":
        return "Event Name (e.g., Summer Gala 2026)";
      case "Vendor":
        return "Vendor Name (e.g., The Jazz Trio)";
      default:
        return "Enter ID, Name, or Email";
    }
  };

  return (
    <div>
      <div
        style={{
          marginBottom: "2rem",
          padding: "1rem",
          border: "1px solid #555",
        }}>
        <h2>{isEditing ? "Edit Task" : "Create Task"}</h2>
        <form onSubmit={handleSubmit}>
          {/* Form fields */}
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Title: </label>
            <input
              name="title"
              value={formData.title ?? ""}
              onChange={handleChange}
            />
            {validationErrors.Title && (
              <div style={{ color: "red" }}>{validationErrors.Title[0]}</div>
            )}
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Description: </label>
            <textarea
              name="description"
              value={formData.description ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Due Date: </label>
            <input
              name="dueDate"
              type="date"
              value={formData.dueDate ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Status: </label>
            <select
              name="status"
              value={formData.status ?? "NotStarted"}
              onChange={handleChange}>
              <option value="NotStarted">Not Started</option>
              <option value="InProgress">In Progress</option>
              <option value="Completed">Completed</option>
            </select>
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Priority: </label>
            <select
              name="priority"
              value={formData.priority ?? "Medium"}
              onChange={handleChange}>
              <option value="Low">Low</option>
              <option value="Medium">Medium</option>
              <option value="High">High</option>
            </select>
          </div>

          {/* --- PHASE 29: DYNAMIC LINKING SECTION --- */}
          {!isEditing && (
            <div
              style={{
                margin: "1rem 0",
                padding: "1rem",
                border: "1px dashed #666",
                borderRadius: "4px",
              }}>
              <h4 style={{ marginTop: 0 }}>
                Link Task To: (Name or Email Lookup)
              </h4>
              <div style={{ marginBottom: "0.5rem" }}>
                <label style={{ display: "block" }}>Link Type:</label>
                <select
                  value={entityTypeToLink ?? "None"}
                  onChange={handleEntityTypeChange}
                  style={{ width: "100%", padding: "4px" }}>
                  <option value="None">-- Select Entity Type --</option>
                  <option value="Contact">Contact (by Email)</option>
                  <option value="Event">Event (by Name)</option>
                  <option value="Vendor">Vendor (by Name)</option>
                </select>
              </div>
              {entityTypeToLink && (
                <div style={{ marginBottom: "0.5rem" }}>
                  <label style={{ display: "block" }}>Lookup Value:</label>
                  <input
                    type={entityTypeToLink === "Contact" ? "email" : "text"}
                    value={linkValue}
                    onChange={handleLinkValueChange}
                    placeholder={getLinkPlaceholder()}
                    style={{ width: "100%" }}
                  />
                </div>
              )}
            </div>
          )}

          {/* --- LEGACY GUID INPUTS (Hidden on Create, Used on Edit) --- */}
          {/* On Edit mode, we submit the existing GUIDs. */}
          {/* NOTE: We only display the GUIDs on edit if you need to change the parent via GUID */}
          {isEditing && (
            <>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Contact ID (Optional): </label>
                <input
                  name="contactId"
                  value={formData.contactId ?? ""}
                  onChange={handleChange}
                />
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Event ID (Optional): </label>
                <input
                  name="eventId"
                  value={formData.eventId ?? ""}
                  onChange={handleChange}
                />
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Vendor ID (Optional): </label>
                <input
                  name="vendorId"
                  value={formData.vendorId ?? ""}
                  onChange={handleChange}
                />
              </div>
            </>
          )}
          {/* ---------------------------------------------------- */}

          {validationErrors.General && (
            <div style={{ color: "red", marginTop: "1rem" }}>
              {validationErrors.General[0]}
            </div>
          )}

          <button type="submit">{isEditing ? "Save Changes" : "Create"}</button>
          {isEditing && (
            <button
              type="button"
              onClick={handleCancel}
              style={{ marginLeft: "0.5rem" }}>
              Cancel
            </button>
          )}
        </form>
      </div>

      <h2>Tasks List</h2>
      {loading ? (
        <p>Loading Tasks...</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Title</th>
              <th>Status</th>
              <th>Priority</th>
              <th>Due Date</th>
              <th>Vendor</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {tasks.map((task) => (
              <tr key={task.id}>
                <td>{task.id}</td>
                <td>{task.title}</td>
                <td>{task.status}</td>
                <td>{task.priority}</td>
                <td>
                  {task.dueDate
                    ? new Date(task.dueDate).toLocaleDateString()
                    : "N/A"}
                </td>
                <td>{task.vendorName ?? "N/A"}</td>
                <td>
                  <button
                    onClick={() => handleEdit(task)}
                    style={{ color: "blue" }}>
                    Edit
                  </button>
                  <button
                    onClick={() => handleDelete(task.id)}
                    style={{ color: "red", marginLeft: "0.5rem" }}>
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

export default TasksPage;


// ==========================================
// FILE: frontend_harness/src/components/RelatedTables.tsx 
// ==========================================
import { useEffect, useState } from "react";
import { useSelectionContext } from "../context/useSelectionContext";
import { apiClient } from "../apiClient";
import type {
  TaskDto,
  NoteDto,
  EventDto,
  ContactDto,
  Guid,
  EmailLogDto,
} from "../types";

// Add vendorId to the props of the related tables
interface RelatedTableProps {
  contactId?: Guid | null;
  eventId?: Guid | null;
  vendorId?: Guid | null;
}

// --- Utility function to determine the API path and selection ID ---
const getApiContext = (
  props: RelatedTableProps,
  selectedContactId: Guid | null,
  selectedEventId: Guid | null,
  resource: "tasks" | "notes"
) => {
  // 1. Check for explicit props (used by Command Centers)
  if (props.vendorId) {
    return {
      id: props.vendorId,
      url: `/api/${resource}?vendorId=${props.vendorId}`,
      label: "Vendor",
    };
  }
  if (props.contactId) {
    return {
      id: props.contactId,
      url: `/api/${resource}?contactId=${props.contactId}`,
      label: "Contact",
    };
  }
  if (props.eventId) {
    return {
      id: props.eventId,
      url: `/api/${resource}?eventId=${props.eventId}`,
      label: "Event",
    };
  }

  // 2. Fall back to context (used by old pages/global lists)
  if (selectedContactId) {
    return {
      id: selectedContactId,
      url: `/api/${resource}?contactId=${selectedContactId}`,
      label: "Contact",
    };
  }
  if (selectedEventId) {
    return {
      id: selectedEventId,
      url: `/api/${resource}?eventId=${selectedEventId}`,
      label: "Event",
    };
  }
  return { id: null, url: null, label: null };
};

// --- 1. RelatedTasks ---
export function RelatedTasks(props: RelatedTableProps) {
  const { selectedContactId, selectedEventId } = useSelectionContext();
  const [tasks, setTasks] = useState<TaskDto[]>([]);
  const [loading, setLoading] = useState(false);

  const context = getApiContext(
    props,
    selectedContactId,
    selectedEventId,
    "tasks"
  );
  const selectedId = context.id;
  const apiUrl = context.url;
  const contextLabel = context.label;

  useEffect(() => {
    if (!selectedId || !apiUrl) {
      setTasks([]);
      return;
    }

    const fetchTasks = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<TaskDto[]>(apiUrl);
        setTasks(response.data);
      } catch (err) {
        console.error("Failed to fetch related tasks:", err);
      } finally {
        setLoading(false);
      }
    };

    fetchTasks();
  }, [selectedId, apiUrl]);

  if (!selectedId) return null;
  if (loading) return <p>Loading related tasks...</p>;

  const safeContextLabel = contextLabel as string;

  return (
    <div style={{ marginTop: "2rem" }}>
      {/* FIX: Show Full ID */}
      <h3>
        Related Tasks (for {safeContextLabel} ID: {selectedId})
      </h3>
      {tasks.length === 0 ? (
        <p>No tasks found for this {safeContextLabel.toLowerCase()}.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Title</th>
              <th>Status</th>
              <th>Due Date</th>
              <th>Linked Vendor</th> {/* NEW COLUMN HEADER */}
              <th>Linked Contact</th> {/* NEW COLUMN HEADER */}
              <th>Linked Event</th> {/* NEW COLUMN HEADER */}
            </tr>
          </thead>
          <tbody>
            {tasks.map((task) => (
              <tr key={task.id}>
                {/* FIX: Show Full ID (Shortened for space) */}
                <td>{task.id.substring(0, 8)}...</td>
                <td>{task.title}</td>
                <td>{task.status}</td>
                <td>
                  {task.dueDate
                    ? new Date(task.dueDate).toLocaleDateString()
                    : "N/A"}
                </td>
                {/* PHASE 28: Vendor Granularity */}
                <td>
                  {task.vendorName ??
                    (task.vendorId
                      ? `ID: ${task.vendorId.substring(0, 8)}...`
                      : "N/A")}
                </td>
                {/* PHASE 28: Contact/Event Granularity */}
                <td>
                  {task.contactId
                    ? `ID: ${task.contactId.substring(0, 8)}...`
                    : "N/A"}
                </td>
                <td>
                  {task.eventId
                    ? `ID: ${task.eventId.substring(0, 8)}...`
                    : "N/A"}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

// --- 2. RelatedNotes ---
export function RelatedNotes(props: RelatedTableProps) {
  const { selectedContactId, selectedEventId } = useSelectionContext();
  const [notes, setNotes] = useState<NoteDto[]>([]);
  const [loading, setLoading] = useState(false);

  const context = getApiContext(
    props,
    selectedContactId,
    selectedEventId,
    "notes"
  );
  const selectedId = context.id;
  const apiUrl = context.url;
  const contextLabel = context.label;

  useEffect(() => {
    if (!selectedId || !apiUrl) {
      setNotes([]);
      return;
    }

    const fetchNotes = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<NoteDto[]>(apiUrl);
        setNotes(response.data);
      } catch (err) {
        console.error("Failed to fetch related notes:", err);
      } finally {
        setLoading(false);
      }
    };

    fetchNotes();
  }, [selectedId, apiUrl]);

  if (!selectedId) return null;
  if (loading) return <p>Loading related notes...</p>;

  const safeContextLabel = contextLabel as string;

  return (
    <div style={{ marginTop: "2rem" }}>
      {/* FIX: Show Full ID */}
      <h3>
        Related Notes (for {safeContextLabel} ID: {selectedId})
      </h3>
      {notes.length === 0 ? (
        <p>No notes found for this {safeContextLabel.toLowerCase()}.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Content</th>
              <th>Linked Vendor</th> {/* NEW COLUMN HEADER */}
              <th>Linked Contact</th> {/* NEW COLUMN HEADER */}
              <th>Linked Event</th> {/* NEW COLUMN HEADER */}
            </tr>
          </thead>
          <tbody>
            {notes.map((note) => (
              <tr key={note.id}>
                {/* FIX: Show Full ID (Shortened for space) */}
                <td>{note.id.substring(0, 8)}...</td>
                <td>{note.content}</td>
                {/* PHASE 28: Vendor Granularity */}
                <td>
                  {note.vendorName ??
                    (note.vendorId
                      ? `ID: ${note.vendorId.substring(0, 8)}...`
                      : "N/A")}
                </td>
                {/* PHASE 28: Contact/Event Granularity */}
                <td>
                  {note.contactId
                    ? `ID: ${note.contactId.substring(0, 8)}...`
                    : "N/A"}
                </td>
                <td>
                  {note.eventId
                    ? `ID: ${note.eventId.substring(0, 8)}...`
                    : "N/A"}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

// --- 3. ContactEventsTable ---
export function ContactEventsTable() {
  const { selectedContactId } = useSelectionContext();
  const [events, setEvents] = useState<EventDto[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (!selectedContactId) {
      setEvents([]);
      return;
    }

    const fetchEvents = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<EventDto[]>(
          `/api/contacts/${selectedContactId}/events`
        );
        setEvents(response.data);
      } catch (err) {
        console.error("Failed to fetch contact's events:", err);
      } finally {
        setLoading(false);
      }
    };

    fetchEvents();
  }, [selectedContactId]);

  if (!selectedContactId) return null;
  if (loading) return <p>Loading related events...</p>;

  return (
    <div style={{ marginTop: "2rem" }}>
      {/* FIX: Show Full ID */}
      <h3>Related Events (for Contact ID: {selectedContactId})</h3>
      {events.length === 0 ? (
        <p>No events found linked to this contact.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Name</th>
              <th>Status</th>
              <th>Start</th>
              <th>Location</th>
            </tr>
          </thead>
          <tbody>
            {events.map((event) => (
              <tr key={event.id}>
                {/* FIX: Show Full ID */}
                <td>{event.id}</td>
                <td>{event.name}</td>
                <td>{event.status}</td>
                <td>{new Date(event.startDateTime).toLocaleString()}</td>
                <td>{event.location ?? "N/A"}</td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

// --- 4. EventParticipantsTable ---
interface EventParticipantsTableProps {
  onUnlinkSuccess: () => void;
}

export function EventParticipantsTable({
  onUnlinkSuccess,
}: EventParticipantsTableProps) {
  const { selectedEventId } = useSelectionContext();
  const [contacts, setContacts] = useState<ContactDto[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    const fetchContacts = async () => {
      if (!selectedEventId) {
        setContacts([]);
        return;
      }
      setLoading(true);
      try {
        const response = await apiClient.get<ContactDto[]>(
          `/api/events/${selectedEventId}/contacts`
        );
        setContacts(response.data);
      } catch (err) {
        console.error("Failed to fetch event participants:", err);
      } finally {
        setLoading(false);
      }
    };

    fetchContacts();
  }, [selectedEventId]);

  const handleUnlink = async (contactId: string) => {
    if (!selectedEventId) return;
    if (
      !window.confirm(
        "Are you sure you want to remove this contact from the event?"
      )
    )
      return;

    try {
      await apiClient.delete(
        `/api/events/${selectedEventId}/contacts/${contactId}`
      );
      onUnlinkSuccess();
    } catch (err) {
      console.error("Failed to unlink contact:", err);
      alert("Failed to unlink contact.");
    }
  };

  if (!selectedEventId) return null;
  if (loading) return <p>Loading event participants...</p>;

  return (
    <div style={{ marginTop: "2rem" }}>
      <h3>Event Participants (Staff/Guests)</h3>
      {contacts.length === 0 ? (
        <p>No participants linked to this event.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>First Name</th>
              <th>Last Name</th>
              <th>Email</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {contacts.map((contact) => (
              <tr key={contact.id}>
                {/* FIX: Show Full ID */}
                <td>{contact.id}</td>
                <td>{contact.firstName}</td>
                <td>{contact.lastName}</td>
                <td>{contact.email}</td>
                <td>
                  <button
                    onClick={() => handleUnlink(contact.id)}
                    style={{ color: "red", cursor: "pointer" }}>
                    Unlink
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

// --- 5. EmailHistoryTable ---
export function EmailHistoryTable() {
  const { selectedContactId } = useSelectionContext();
  const [logs, setLogs] = useState<EmailLogDto[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (!selectedContactId) {
      setLogs([]);
      return;
    }

    const fetchLogs = async () => {
      setLoading(true);
      try {
        const res = await apiClient.get<EmailLogDto[]>(
          `/api/contacts/${selectedContactId}/email-logs`
        );
        setLogs(res.data);
      } catch (err) {
        console.error("Failed to fetch email logs", err);
      } finally {
        setLoading(false);
      }
    };

    fetchLogs();
  }, [selectedContactId]);

  if (!selectedContactId) return null;

  return (
    <div style={{ marginTop: "2rem" }}>
      <h3>Email History (for Contact ID: {selectedContactId})</h3>
      {loading ? (
        <p>Loading logs...</p>
      ) : logs.length === 0 ? (
        <p>No emails sent to this contact.</p>
      ) : (
        <table
          border={1}
          cellPadding={5}
          style={{ width: "100%", borderCollapse: "collapse" }}>
          <thead>
            <tr style={{ background: "#333", color: "#fff" }}>
              <th>Subject</th>
              <th>Sent At</th>
              <th>Status</th>
              <th>Message</th>
            </tr>
          </thead>
          <tbody>
            {logs.map((log) => (
              <tr key={log.id}>
                <td>{log.subject}</td>
                <td>{new Date(log.sentAt).toLocaleString()}</td>
                <td
                  style={{
                    color: log.isSuccess ? "lightgreen" : "#ff6b6b",
                    fontWeight: "bold",
                  }}>
                  {log.isSuccess ? "Success" : "Failed"}
                </td>
                <td
                  style={{
                    maxWidth: "300px",
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    whiteSpace: "nowrap",
                  }}>
                  {log.errorMessage ? log.errorMessage : "Sent via SendGrid"}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

export default function RelatedTables() {
  return (
    <div>
      <RelatedTasks />
      <RelatedNotes />
    </div>
  );
}


// ==========================================
// FILE: frontend_harness/src/components/DashboardPage.tsx 
// ==========================================
// FILE: frontend_harness/src/components/DashboardPage.tsx

import { useEffect, useState, useCallback } from "react";
import {
  apiClient,
  updateContact,
  submitLead,
  deleteContact as deleteContactClient,
  initializeTestFixtures,
} from "../apiClient";
import { SendEmailModal } from "./SendEmailModal";
import type {
  DashboardStatsDto,
  ContactDto,
  VendorDto,
  EventDto,
} from "../types";

// --- INTERFACES ---

interface TestExecutionPanelProps {
  contacts: ContactDto[];
  logTestResult: (
    message: string,
    level: "PASS" | "FAIL" | "INFO" | "WARN"
  ) => void;
}

// --- COMPONENT: Test Execution Panel (Enhanced) ---

const TestExecutionPanel: React.FC<TestExecutionPanelProps> = ({
  contacts,
  logTestResult,
}) => {
  // State for Manual Live Tests
  const [manualContactId, setManualContactId] = useState("");
  const [manualTemplateId, setManualTemplateId] = useState("");

  // --- 1. LIVE EMAIL TEST ---
  const executeLiveEmail = async () => {
    if (!manualContactId || !manualTemplateId) {
      alert("Please enter both Contact ID and Template ID.");
      return;
    }

    logTestResult(
      `Attempting to send Email to Contact: ${manualContactId}...`,
      "INFO"
    );

    try {
      await apiClient.post("/api/templates/send-email", {
        contactId: manualContactId,
        templateId: manualTemplateId,
      });
      logTestResult("SUCCESS: Email request sent to SendGrid.", "PASS");
      alert("Email Queued Successfully!");
    } catch (e: unknown) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      logTestResult(`FAILED: Could not send email. Error: ${errorMsg}`, "FAIL");
    }
  };

  // --- 2. LIVE SMS TEST ---
  const executeLiveSms = async () => {
    if (!manualContactId || !manualTemplateId) {
      alert("Please enter both Contact ID and Template ID.");
      return;
    }

    logTestResult(
      `Attempting to send SMS to Contact: ${manualContactId}...`,
      "INFO"
    );

    try {
      await apiClient.post("/api/automation/send-sms", {
        contactId: manualContactId,
        templateId: manualTemplateId,
      });
      logTestResult("SUCCESS: SMS request sent to Twilio.", "PASS");
      alert("SMS Queued Successfully! Check your phone.");
    } catch (e: unknown) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      logTestResult(`FAILED: Could not send SMS. Error: ${errorMsg}`, "FAIL");
    }
  };

  // --- 3. SYSTEM INTEGRITY (CRUD) TESTS ---
  const runSystemTests = useCallback(async () => {
    const output = document.getElementById("test-log-output");
    if (output) output.innerHTML = ""; // Clear log

    const testContact = contacts[0];

    logTestResult("Starting System Integrity Check...", "INFO");

    if (!testContact) {
      logTestResult(
        "ABORT: No contacts found in database to test against.",
        "WARN"
      );
      return;
    }

    // A. Lead Submission
    try {
      const leadId = await submitLead({
        firstName: "Auto",
        lastName: "Lead",
        email: `auto_lead_${Date.now()}@test.com`,
        source: "Dashboard Test Harness",
      });
      logTestResult(
        `POST /leads/submit: PASS. Created ID: ${leadId.substring(0, 8)}...`,
        "PASS"
      );

      // Cleanup
      await deleteContactClient(leadId);
      logTestResult(`DELETE /contacts: PASS. Cleaned up test lead.`, "PASS");
    } catch (e: unknown) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      logTestResult(`Lead Flow FAILED: ${errorMsg}`, "FAIL");
    }

    // B. Update Contact
    try {
      await updateContact(testContact.id, {
        ...testContact,
        lastName: "UpdatedByTest",
      });
      logTestResult(
        `PUT /contacts: PASS. Updated Contact ${testContact.id.substring(
          0,
          8
        )}.`,
        "PASS"
      );
    } catch (e: unknown) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      logTestResult(`Contact Update FAILED: ${errorMsg}`, "FAIL");
    }

    logTestResult("System Integrity Check Complete.", "INFO");
  }, [contacts, logTestResult]);

  return (
    <div className="mt-8 p-6 border border-gray-700 rounded-xl bg-gray-900 shadow-2xl">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-xl font-bold text-white flex items-center gap-2">
          <span className="w-3 h-3 bg-green-500 rounded-full animate-pulse"></span>
          API Test Lab
        </h2>
        <span className="text-xs font-mono text-gray-500">v48.0.1</span>
      </div>

      {/* --- LIVE LAB SECTION --- */}
      <div className="bg-gray-800 p-4 rounded-lg mb-6 border border-gray-700">
        <h3 className="text-sm font-bold text-blue-400 uppercase tracking-wider mb-4">
          Live Communication Lab
        </h3>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
          <div>
            <label className="block text-xs text-gray-400 mb-1">
              Target Contact ID (UUID)
            </label>
            <input
              value={manualContactId}
              onChange={(e) => setManualContactId(e.target.value)}
              placeholder="e.g. 3fa85f64-..."
              className="w-full bg-gray-900 border border-gray-600 rounded p-2 text-sm text-white font-mono focus:border-blue-500 outline-none"
            />
          </div>
          <div>
            <label className="block text-xs text-gray-400 mb-1">
              Template ID (UUID)
            </label>
            <input
              value={manualTemplateId}
              onChange={(e) => setManualTemplateId(e.target.value)}
              placeholder="e.g. 8efe1c11-..."
              className="w-full bg-gray-900 border border-gray-600 rounded p-2 text-sm text-white font-mono focus:border-purple-500 outline-none"
            />
          </div>
        </div>

        <div className="flex gap-3">
          <button
            onClick={executeLiveEmail}
            className="flex-1 bg-indigo-600 hover:bg-indigo-500 text-white py-2 rounded font-medium transition-colors text-sm">
            Test Real Email
          </button>
          <button
            onClick={executeLiveSms}
            className="flex-1 bg-green-600 hover:bg-green-500 text-white py-2 rounded font-medium transition-colors text-sm">
            Test Real SMS
          </button>
        </div>
      </div>

      {/* --- SYSTEM BUTTONS --- */}
      <button
        onClick={runSystemTests}
        className="w-full bg-gray-700 hover:bg-gray-600 text-gray-200 py-2 rounded font-medium transition-colors text-sm border border-gray-600 mb-4">
        Run CRUD Integrity Suite
      </button>

      {/* --- LOG OUTPUT --- */}
      <div className="bg-black rounded-lg p-3 border border-gray-800">
        <h4 className="text-gray-500 text-[10px] font-bold uppercase mb-2">
          Execution Log:
        </h4>
        <div
          id="test-log-output"
          className="h-32 overflow-y-auto font-mono text-xs space-y-1 text-gray-300"></div>
      </div>
    </div>
  );
};

// --- MAIN PAGE COMPONENT ---

export default function DashboardPage() {
  const [stats, setStats] = useState<DashboardStatsDto | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");

  // Modal State
  const [isEmailModalOpen, setIsEmailModalOpen] = useState(false);
  const [selectedEventId, setSelectedEventId] = useState("");

  // Data for props
  const [contacts, setContacts] = useState<ContactDto[]>([]);
  const [vendors, setVendors] = useState<VendorDto[]>([]); // Kept for modal props
  const [isFixturesInitialized, setIsFixturesInitialized] = useState(false);

  // Logger
  const logTestResult = useCallback(
    (message: string, level: "PASS" | "FAIL" | "INFO" | "WARN") => {
      let color = "#e5e7eb"; // gray-200
      if (level === "PASS") color = "#4ade80"; // green-400
      if (level === "FAIL") color = "#f87171"; // red-400
      if (level === "WARN") color = "#fbbf24"; // amber-400

      const logEntry = `<div style="color: ${color}; margin-bottom: 2px;">
      <span style="opacity: 0.5;">[${new Date().toLocaleTimeString()}]</span> 
      <strong>${level}:</strong> ${message}
    </div>`;

      const output = document.getElementById("test-log-output");
      if (output) {
        output.innerHTML += logEntry;
        output.scrollTop = output.scrollHeight;
      }
    },
    []
  );

  useEffect(() => {
    const loadDashboardData = async () => {
      try {
        setLoading(true);

        // Run fixtures once
        if (!isFixturesInitialized) {
          logTestResult("Initializing Database Fixtures...", "INFO");
          await initializeTestFixtures();
          setIsFixturesInitialized(true);
          logTestResult("Fixtures Initialized.", "PASS");
        }

        const [statsRes, contactsRes, vendorsRes] = await Promise.all([
          apiClient.get<DashboardStatsDto>("/api/dashboard"),
          apiClient.get<ContactDto[]>("/api/contacts"),
          apiClient.get<VendorDto[]>("/api/vendors"),
        ]);

        setStats(statsRes.data);
        setContacts(contactsRes.data);
        setVendors(vendorsRes.data);
        setLoading(false);
      } catch (err: unknown) {
        console.error(err); // Log for debugging
        setError("Dashboard failed to load. Ensure backend is running.");
        setLoading(false);
      }
    };
    loadDashboardData();
  }, [isFixturesInitialized, logTestResult]);

  if (loading)
    return (
      <div className="min-h-screen flex items-center justify-center text-gray-500 animate-pulse">
        Loading Command Center...
      </div>
    );

  if (error)
    return (
      <div className="p-8 m-8 bg-red-900/20 border border-red-800 text-red-200 rounded-lg">
        <h3 className="font-bold">Connection Error</h3>
        <p>{error}</p>
      </div>
    );

  if (!stats) return null;

  return (
    <div className="space-y-8 pb-10 max-w-7xl mx-auto px-4 sm:px-6">
      {/* 1. TEST EXECUTION PANEL (Top for easy access during Dev) */}
      <TestExecutionPanel contacts={contacts} logTestResult={logTestResult} />

      {/* 2. HEADER */}
      <div className="flex flex-col sm:flex-row justify-between items-end border-b border-gray-800 pb-6 gap-4">
        <div>
          <h1 className="text-4xl font-extrabold text-white tracking-tight">
            Command Center
          </h1>
          <p className="text-gray-400 mt-1">
            LCD Entertainment System Overview
          </p>
        </div>
        <div className="text-right">
          <div className="inline-flex items-center px-3 py-1 rounded-full bg-green-900/30 border border-green-800 text-green-400 text-xs font-bold uppercase tracking-wide">
            Phase 48: Active
          </div>
        </div>
      </div>

      {/* 3. STAT CARDS */}
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
        <StatCard
          label="Total Contacts"
          value={stats.totalContacts}
          color="border-blue-500"
        />
        <StatCard
          label="Active Events"
          value={stats.activeEvents}
          color="border-purple-500"
        />
        <StatCard
          label="Pending Tasks"
          value={stats.pendingTasks}
          color="border-yellow-500"
        />
        <StatCard
          label="Recent Emails"
          value={stats.recentEmails}
          color="border-green-500"
        />
      </div>

      {/* 4. UPCOMING EVENTS LIST */}
      <div className="bg-gray-800 rounded-2xl border border-gray-700 shadow-xl overflow-hidden">
        <div className="p-6 border-b border-gray-700 bg-gray-800/50">
          <h2 className="text-xl font-bold text-white">Upcoming Schedule</h2>
        </div>
        <div className="divide-y divide-gray-700">
          {stats.upcomingEvents.length === 0 ? (
            <div className="p-8 text-center text-gray-500 italic">
              No events scheduled.
            </div>
          ) : (
            stats.upcomingEvents.map((evt: EventDto) => (
              <div
                key={evt.id}
                className="p-6 flex flex-col sm:flex-row items-start sm:items-center gap-6 hover:bg-gray-700/30 transition-all">
                {/* Date Badge */}
                <div className="bg-gray-900 w-16 h-16 rounded-xl border border-gray-600 flex flex-col items-center justify-center flex-shrink-0">
                  <span className="text-[10px] text-gray-400 uppercase font-black">
                    {new Date(evt.startDateTime).toLocaleString("default", {
                      month: "short",
                    })}
                  </span>
                  <span className="text-2xl font-black text-white">
                    {new Date(evt.startDateTime).getDate()}
                  </span>
                </div>

                {/* Info */}
                <div className="flex-grow">
                  <h3 className="text-lg font-bold text-white">{evt.name}</h3>
                  <div className="flex flex-wrap gap-4 mt-1 text-sm text-gray-400">
                    <span className="flex items-center gap-1">
                      <span>ðŸ“</span> {evt.location || "TBD"}
                    </span>
                    <span className="flex items-center gap-1">
                      <span>ðŸ•’</span>{" "}
                      {new Date(evt.startDateTime).toLocaleTimeString([], {
                        hour: "2-digit",
                        minute: "2-digit",
                      })}
                    </span>
                  </div>
                </div>

                {/* Quick Action */}
                <button
                  onClick={() => {
                    setSelectedEventId(evt.id);
                    setIsEmailModalOpen(true);
                  }}
                  className="w-full sm:w-auto bg-gray-900 hover:bg-blue-600 border border-gray-600 hover:border-blue-500 text-gray-300 hover:text-white px-4 py-2 rounded-lg text-sm font-bold transition-all shadow-sm">
                  Send Comms
                </button>
              </div>
            ))
          )}
        </div>
      </div>

      {/* 5. EMAIL MODAL */}
      <SendEmailModal
        isOpen={isEmailModalOpen}
        onClose={() => setIsEmailModalOpen(false)}
        eventId={selectedEventId}
        availableContacts={contacts}
        availableVendors={vendors}
      />
    </div>
  );
}

// --- HELPER COMPONENT ---
function StatCard({
  label,
  value,
  color,
}: {
  label: string;
  value: number;
  color: string;
}) {
  return (
    <div
      className={`bg-gray-800 p-6 rounded-2xl border-b-4 ${color} shadow-lg transition-transform hover:scale-[1.02]`}>
      <p className="text-gray-400 text-xs font-black uppercase mb-1 tracking-widest">
        {label}
      </p>
      <p className="text-4xl font-black text-white">{value}</p>
    </div>
  );
}


// ==========================================
// FILE: frontend_harness/src/apiClient.ts 
// ==========================================
// FILE: frontend_harness/src/apiClient.ts (COMPLETE REPLACEMENT)
import axios from 'axios';
import { 
  type Document, 
  type EventFinancials, 
  type SendTemplateEmailCommand,
  type TemplateDto, 
  type ContactDto,
  type VendorDto,
  type EventDto,
  type TaskDto,
  type NoteDto,
  type EmailLogDto,
  type SubmitLeadCommand,
  RecipientType,
} from './types';


// Define the base URL of your local API
const API_BASE_URL = 'http://localhost:5179';

export const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// =======================================================
// CORE SERVICES
// =======================================================

// --- DOCUMENT SERVICES ---

export const uploadDocument = async (
  file: File, 
  relatedEntityId: string, 
  relatedEntityType: string,
  category: string
): Promise<Document> => {
  const formData = new FormData();
  formData.append('file', file);
  formData.append('relatedEntityId', relatedEntityId);
  formData.append('relatedEntityType', relatedEntityType);
  formData.append('category', category);

  const response = await apiClient.post<Document>('/api/documents', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  });
  return response.data;
};

export const deleteDocument = async (id: number): Promise<void> => {
  await apiClient.delete(`/api/documents/${id}`);
};

// --- FINANCIALS SERVICES ---

export const getEventFinancials = async (eventId: string): Promise<EventFinancials> => {
  const response = await apiClient.get<EventFinancials>(`/api/events/${eventId}/financials`);
  return response.data;
};

export const upsertBudget = async (
  eventId: string, 
  totalAmount: number, 
  currency: string, 
  notes?: string
): Promise<string> => {
  const payload = { eventId, totalAmount, currency, notes };
  const response = await apiClient.post<string>(`/api/events/${eventId}/financials/budget`, payload);
  return response.data;
};

export const addExpense = async (
  eventId: string,
  description: string,
  amount: number,
  dateIncurred: string, // ISO String
  category: string,
  vendorId?: string,
  linkedDocumentId?: number
): Promise<string> => {
  const payload = { eventId, description, amount, dateIncurred, category, vendorId, linkedDocumentId };
  const response = await apiClient.post<string>(`/api/events/${eventId}/financials/expenses`, payload);
  return response.data;
};


// --- TEMPLATE SERVICES ---

export const templates = {
  getAll: async () => {
    const response = await apiClient.get<TemplateDto[]>('/api/templates');
    return response.data;
  },
  create: async (data: unknown) => {
    const response = await apiClient.post<string>('/api/templates', data);
    return response.data;
  },
  sendEmail: async (command: SendTemplateEmailCommand) => {
    // Uses POST /api/templates/send
    await apiClient.post('/api/templates/send', command);
  }
};

/**
 * Initializes required contacts, vendors, and events for testing.
 * @returns The ID of the primary contact created.
 */
export const initializeTestFixtures = async (): Promise<string> => {
  const response = await apiClient.post<string>('/api/contacts/init-fixtures');
  return response.data;
};

// =======================================================
// FULL CRUD IMPLEMENTATION (PHASE 31)
// =======================================================

// --- CONTACTS CRUD & RELATIONS ---

export const updateContact = async (id: string, data: Partial<ContactDto>): Promise<void> => {
  await apiClient.put(`/api/contacts/${id}`, data);
};

export const deleteContact = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/contacts/${id}`);
};

export const getContactEmailLogs = async (contactId: string): Promise<EmailLogDto[]> => {
  const response = await apiClient.get<EmailLogDto[]>(`/api/contacts/${contactId}/email-logs`);
  return response.data;
};

// --- EVENTS CRUD & RELATIONS ---

export const updateEvent = async (id: string, data: Partial<EventDto>): Promise<void> => {
  await apiClient.put(`/api/events/${id}`, data);
};

export const deleteEvent = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/events/${id}`);
};

export const unlinkContactFromEvent = async (eventId: string, contactId: string): Promise<void> => {
  await apiClient.delete(`/api/events/${eventId}/contacts/${contactId}`);
};


// --- VENDORS CRUD ---

export const updateVendor = async (id: string, data: Partial<VendorDto>): Promise<void> => {
  await apiClient.put(`/api/vendors/${id}`, data);
};

export const deleteVendor = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/vendors/${id}`);
};


// --- TASKS CRUD ---
// (TasksController only has Create/Update/Delete - Reads are handled via GetTasksQuery)
export const updateTask = async (id: string, data: Partial<TaskDto>): Promise<void> => {
  await apiClient.put(`/api/tasks/${id}`, data);
};

export const deleteTask = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/tasks/${id}`);
};


// --- NOTES CRUD ---
// (NotesController only has Update/Delete - Create returns DTO)
export const updateNote = async (id: string, data: Partial<NoteDto>): Promise<void> => {
  // NOTE: Notes only allow updating 'content' per the business logic
  await apiClient.put(`/api/notes/${id}`, data); 
};

export const deleteNote = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/notes/${id}`);
};


// --- AUTOMATION & LEADS ---

export const submitLead = async (command: SubmitLeadCommand): Promise<string> => {
  const response = await apiClient.post<string>('/api/leads/submit', command);
  return response.data;
};

export const scheduleFollowUp = async (
  contactId: string, 
  templateId: string, 
  scheduleTime: string, // ISO String
  type: RecipientType = RecipientType.Contact
): Promise<string> => {
  const payload = { contactId, templateId, scheduleTime, type };
  const response = await apiClient.post<string>('/api/automation/schedule-followup', payload);
  return response.data;
};

// ==========================================
// FILE: frontend_harness/src/App.tsx 
// ==========================================
import {
  SignedIn,
  SignedOut,
  UserButton,
  useAuth,
  RedirectToSignIn,
} from "@clerk/clerk-react";
import { apiClient } from "./apiClient";
import { useEffect, useState } from "react";

import DashboardPage from "./components/DashboardPage"; // NEW IMPORT
import ContactsPage from "./components/ContactsPage";
import EventsPage from "./components/EventsPage";
import TasksPage from "./components/TasksPage";
import VendorsPage from "./components/VendorsPage";
import NotesPage from "./components/NotesPage";
import TemplatesPage from "./components/TemplatesPage";

import { SelectionProvider } from "./context/SelectionProvider";

type PageView =
  | "dashboard" // NEW TYPE
  | "contacts"
  | "events"
  | "tasks"
  | "vendors"
  | "notes"
  | "templates";

function App() {
  const [isApiReady, setIsApiReady] = useState(false);
  // CHANGED: Default to "dashboard"
  const [currentPage, setCurrentPage] = useState<PageView>("dashboard");
  const { getToken } = useAuth();

  useEffect(() => {
    const setupAxiosInterceptor = async () => {
      const interceptorId = apiClient.interceptors.request.use(
        async (config) => {
          const token = await getToken();

          if (token) {
            config.headers.Authorization = `Bearer ${token}`;
          }
          return config;
        },
        (error) => {
          return Promise.reject(error);
        }
      );

      setIsApiReady(true);

      return () => {
        apiClient.interceptors.request.eject(interceptorId);
        setIsApiReady(false);
      };
    };
    setupAxiosInterceptor();
  }, [getToken]);

  const renderPage = () => {
    switch (currentPage) {
      case "dashboard": // NEW CASE
        return <DashboardPage />;
      case "contacts":
        return <ContactsPage />;
      case "events":
        return <EventsPage />;
      case "tasks":
        return <TasksPage />;
      case "vendors":
        return <VendorsPage />;
      case "notes":
        return <NotesPage />;
      case "templates":
        return <TemplatesPage />;
      default:
        return <DashboardPage />;
    }
  };

  return (
    <SelectionProvider>
      <div>
        <header
          style={{
            padding: "1rem",
            display: "flex",
            justifyContent: "flex-end",
            borderBottom: "1px solid #333",
            marginBottom: "1rem",
          }}>
          <SignedIn>
            <UserButton />
          </SignedIn>
        </header>
        <main style={{ padding: "1rem" }}>
          <SignedIn>
            <div
              style={{
                display: "flex",
                alignItems: "center",
                justifyContent: "space-between",
                marginBottom: "1rem",
              }}>
              <h1>CRM_Vivid Command Center</h1>
            </div>

            <nav
              className="harness-nav"
              style={{
                marginBottom: "2rem",
                display: "flex",
                gap: "0.5rem",
                flexWrap: "wrap",
              }}>
              <button
                onClick={() => setCurrentPage("dashboard")}
                disabled={currentPage === "dashboard"}
                style={{
                  fontWeight: currentPage === "dashboard" ? "bold" : "normal",
                }}>
                ðŸ“Š Dashboard
              </button>
              <button
                onClick={() => setCurrentPage("contacts")}
                disabled={currentPage === "contacts"}>
                Contacts
              </button>
              <button
                onClick={() => setCurrentPage("events")}
                disabled={currentPage === "events"}>
                Events
              </button>
              <button
                onClick={() => setCurrentPage("tasks")}
                disabled={currentPage === "tasks"}>
                Tasks
              </button>
              <button
                onClick={() => setCurrentPage("vendors")}
                disabled={currentPage === "vendors"}>
                Vendors
              </button>
              <button
                onClick={() => setCurrentPage("notes")}
                disabled={currentPage === "notes"}>
                Notes
              </button>
              <button
                onClick={() => setCurrentPage("templates")}
                disabled={currentPage === "templates"}>
                Templates
              </button>
            </nav>

            <main className="harness-main">
              {isApiReady ? renderPage() : <p>Initializing API client...</p>}
            </main>
          </SignedIn>

          <SignedOut>
            <RedirectToSignIn />
          </SignedOut>
        </main>
      </div>
    </SelectionProvider>
  );
}

export default App;


// ==========================================
// FILE: frontend_harness/src/main.tsx 
// ==========================================
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.tsx";
import "./index.css";
import { ClerkProvider } from "@clerk/clerk-react";

// Import your env variable
const PUBLISHABLE_KEY = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY;

if (!PUBLISHABLE_KEY) {
  throw new Error("Missing Publishable Key");
}

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ClerkProvider publishableKey={PUBLISHABLE_KEY}>
      <App />
    </ClerkProvider>
  </React.StrictMode>
);


// ==========================================
// FILE: frontend_harness/src/context/useSelectionContext.tsx 
// ==========================================
import { useContext } from "react";
// Import the raw context from its new, separate file
import { SelectionContext } from "./internalContext";

// This is the only export, and it's a hook.
// This also satisfies the linter.
export const useSelectionContext = () => {
  const context = useContext(SelectionContext);
  if (context === undefined) {
    throw new Error(
      "useSelectionContext must be used within a SelectionProvider"
    );
  }
  return context;
};


// ==========================================
// FILE: frontend_harness/src/context/SelectionProvider.tsx 
// ==========================================
// frontend_harness/src/context/SelectionProvider.tsx (FULL FILE - Corrected)
import React, { useState, useMemo } from "react";
import { SelectionContext } from "./internalContext";
import type { Guid } from "../types"; // FIX: Added 'type' keyword (TS1484)

interface SelectionProviderProps {
  children: React.ReactNode;
}

export const SelectionProvider: React.FC<SelectionProviderProps> = ({
  children,
}) => {
  const [selectedContactId, setSelectedContactId] = useState<Guid | null>(null);
  const [selectedEventId, setSelectedEventId] = useState<Guid | null>(null);
  // NEW: State for selected vendor
  const [selectedVendorId, setSelectedVendorId] = useState<Guid | null>(null);

  const contextValue = useMemo(
    () => ({
      selectedContactId,
      setSelectedContactId,
      selectedEventId,
      setSelectedEventId,
      selectedVendorId, // NEW: Include in context value
      setSelectedVendorId, // NEW: Include in context value
    }),
    [selectedContactId, selectedEventId, selectedVendorId]
  ); // NEW: Include in dependency array

  return (
    <SelectionContext.Provider value={contextValue}>
      {children}
    </SelectionContext.Provider>
  );
};


// ==========================================
// FILE: frontend_harness/src/context/internalContext.tsx 
// ==========================================
// frontend_harness/src/context/internalContext.tsx
import { createContext } from "react";

// Define the shape of the context state
export interface SelectionContextType {
  selectedContactId: string | null;
  setSelectedContactId: (id: string | null) => void;
  selectedEventId: string | null;
  setSelectedEventId: (id: string | null) => void;
  // NEW: Vendor selection properties
  selectedVendorId: string | null;
  setSelectedVendorId: (id: string | null) => void;
}

// Create the context with an initial undefined value
export const SelectionContext = createContext<SelectionContextType | undefined>(
  undefined
);


// ==========================================
// FILE: frontend_harness/src/types.ts 
// ==========================================
// FILE: frontend_harness/src/types.ts

// ==========================================
// ENUMS & CONSTANTS
// ==========================================

export const LeadStage = {
  NewLead: 0,
  InDiscussion: 1,
  ProposalSent: 2,
  Negotiating: 3,
  Won: 4,
  Lost: 5
} as const;
export type LeadStage = typeof LeadStage[keyof typeof LeadStage];

export const ConnectionStatus = {
  Unknown: 0,
  NeedToMeet: 1,
  MetAlready: 2,
  DoesntNeed: 3,
  NeedAndDoesntHave: 4,
  NeedAndHas: 5,
  HasAndNeedsToMeet: 6
} as const;
export type ConnectionStatus = typeof ConnectionStatus[keyof typeof ConnectionStatus];

export const TaskStatus = {
  Pending: 0,
  InProgress: 1,
  Completed: 2,
  Overdue: 3
} as const;
export type TaskStatus = typeof TaskStatus[keyof typeof TaskStatus];

export const TaskPriority = {
  Low: 0,
  Medium: 1,
  High: 2,
  Critical: 3
} as const;
export type TaskPriority = typeof TaskPriority[keyof typeof TaskPriority];

export const RecipientType = {
  Contact: 0,
  Vendor: 1
} as const;
export type RecipientType = typeof RecipientType[keyof typeof RecipientType];

// ==========================================
// CORE DTOs
// ==========================================

export interface ContactDto {
  id: string;
  firstName: string;
  lastName?: string;
  email: string;
  phoneNumber?: string;     // CHANGED: Matches C# PhoneNumber (was phone)
  title?: string;
  organization?: string;

  // Pipeline Fields
  stage: LeadStage;
  connectionStatus: ConnectionStatus;
  isLead: boolean;
  followUpCount: number;
  lastContactedAt?: string; // CHANGED: Matches C# LastContactedAt (was lastContactDate)
  source?: string;

  // Event Role
  role?: string;            // ADDED: Matches C# Role
  
  // Flexible Data
  attributes?: Record<string, unknown>; // CHANGED: any -> unknown
}

export interface VendorDto {
  id: string;
  name: string;
  serviceType: string;
  contactName?: string;
  email?: string;
  phoneNumber?: string;     // CHANGED: Matches C# PhoneNumber (was phone)
  website?: string;
  address?: string;
  attributes?: Record<string, unknown>; // CHANGED: any -> unknown
}

// ==========================================
// EVENT & ACTIVITY DTOs
// ==========================================

export interface EventDto {
  id: string;
  name: string;
  description: string | null;
  startDateTime: string; // ISO 8601 string
  endDateTime: string;   // ISO 8601 string
  location: string | null;
  isPublic: boolean;
  status: string; 
}

export interface ActivityDto {
  id: string;
  type: string;
  description: string;
  timestamp: string;
  entityId?: string;
  entityType?: string;
}

// ==========================================
// TASK & NOTE DTOs
// ==========================================

export interface TaskDto {
  id: string;
  title: string;
  description?: string;
  dueDate?: string;
  status: TaskStatus;
  priority: TaskPriority;
  contactId?: string;
  eventId?: string;
  assignedToUserId?: string;
}

export interface NoteDto {
  id: string;
  content: string;
  contactId?: string;
  eventId?: string;
  authorId?: string;
  createdAt: string;
}

// ==========================================
// DOCUMENT & FINANCIAL DTOs
// ==========================================

export interface DocumentDto {
  id: string;
  fileName: string;
  fileType: string;
  fileSize: number;
  url: string; // or relative path
  uploadedAt: string;
  contactId?: string;
  eventId?: string;
}

export interface ExpenseDto {
  id: string;
  description: string;
  amount: number;
  category: string;
  dateIncurred: string;
  eventId?: string;
  vendorId?: string;
}

export interface BudgetDto {
  id: string;
  eventId: string;
  totalBudget: number;
  allocated: number;
  spent: number;
  remaining: number;
}

// ==========================================
// TEMPLATE & DASHBOARD DTOs
// ==========================================

export interface TemplateDto {
  id: string;
  name: string;
  type: number; // 0 = Email, 1 = SMS
  subject?: string;
  content?: string;
}

export interface DashboardStatsDto {
  totalContacts: number;
  activeEvents: number;
  pendingTasks: number;
  recentEmails: number;
  upcomingEvents: EventDto[];
}

// ==========================================
// COMMAND PAYLOADS
// ==========================================

export interface ScheduleEmailCommand {
  contact: ContactDto;
  templateContent: string;
  subject: string;
  scheduleTime: string; // ISO String
}

export interface SendTemplateEmailCommand {
  eventId: string;
  templateId: string;
  targetEntityId: string;
  recipientType: number;
}

export interface EmailLogDto {
  id: string;
  contactId: string;
  templateId?: string;
  subject: string;
  sentAt: string; // ISO Date
  status: string; // 'Sent', 'Failed', etc.
  opened: boolean;
}

export interface SubmitLeadCommand {
  firstName: string;
  lastName: string;
  email: string;
  source: string;
  phoneNumber?: string;
}
// Composite object for the Financials view
export interface EventFinancials {
  budget: BudgetDto | null;
  expenses: ExpenseDto[];
}

// ==========================================
// FILE: frontend_harness/src/components/TemplatesPage.tsx 
// ==========================================
import { useEffect, useState } from "react";
import { apiClient } from "../apiClient";
import type { TemplateDto, CreateTemplateDto } from "../types"; // FIX: Added 'type' keyword

export default function TemplatesPage() {
  const [templates, setTemplates] = useState<TemplateDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");

  // Form State
  const [formData, setFormData] = useState<CreateTemplateDto>({
    name: "",
    subject: "",
    content: "",
    type: "Email", // Default
  });

  useEffect(() => {
    fetchTemplates();
  }, []);

  const fetchTemplates = async () => {
    try {
      const response = await apiClient.get<TemplateDto[]>("/api/templates");
      setTemplates(response.data);
    } catch (err) {
      console.error(err);
      setError("Failed to load templates.");
    } finally {
      setLoading(false);
    }
  };

  const handleCreate = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await apiClient.post("/api/templates", formData);
      // Reset form
      setFormData({
        name: "",
        subject: "",
        content: "",
        type: "Email",
      });
      fetchTemplates();
    } catch (err) {
      console.error(err);
      alert("Failed to create template.");
    }
  };

  const handleDelete = async (id: string) => {
    if (!confirm("Are you sure you want to delete this template?")) return;
    try {
      await apiClient.delete(`/api/templates/${id}`);
      fetchTemplates();
    } catch (err) {
      console.error(err);
      alert("Failed to delete template.");
    }
  };

  return (
    <div className="p-4">
      <h2 className="text-xl font-bold mb-4">Templates</h2>

      {/* CREATE FORM */}
      <div className="mb-8 p-4 border rounded shadow-sm bg-gray-50">
        <h3 className="font-semibold mb-2">New Template</h3>
        <form onSubmit={handleCreate} className="space-y-3">
          <div>
            <label className="block text-sm font-medium">Name (Internal)</label>
            <input
              className="border p-1 w-full"
              value={formData.name}
              onChange={(e) =>
                setFormData({ ...formData, name: e.target.value })
              }
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium">Type</label>
            <select
              className="border p-1 w-full"
              value={formData.type}
              onChange={(e) =>
                setFormData({ ...formData, type: e.target.value })
              }>
              <option value="Email">Email</option>
              <option value="SMS">SMS</option>
            </select>
          </div>

          {formData.type === "Email" && (
            <div>
              <label className="block text-sm font-medium">Subject Line</label>
              <input
                className="border p-1 w-full"
                value={formData.subject || ""}
                onChange={(e) =>
                  setFormData({ ...formData, subject: e.target.value })
                }
              />
            </div>
          )}

          <div>
            <label className="block text-sm font-medium">Content Body</label>
            <textarea
              className="border p-1 w-full h-24"
              value={formData.content}
              onChange={(e) =>
                setFormData({ ...formData, content: e.target.value })
              }
              required
            />
          </div>

          <button
            type="submit"
            className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">
            Save Template
          </button>
        </form>
      </div>

      {/* LIST */}
      {loading ? (
        <p>Loading...</p>
      ) : error ? (
        <p className="text-red-500">{error}</p>
      ) : (
        <table className="w-full border-collapse border">
          <thead>
            <tr className="bg-gray-100">
              <th className="border p-2 text-left">Name</th>
              <th className="border p-2 text-left">Type</th>
              <th className="border p-2 text-left">Subject</th>
              <th className="border p-2 text-left">Preview</th>
              <th className="border p-2 text-center">Actions</th>
            </tr>
          </thead>
          <tbody>
            {templates.map((t) => (
              <tr key={t.id} className="hover:bg-gray-50">
                <td className="border p-2 font-medium">{t.name}</td>
                <td className="border p-2">
                  <span
                    className={`px-2 py-1 rounded text-xs ${
                      t.type === "Email"
                        ? "bg-blue-100 text-blue-800"
                        : "bg-green-100 text-green-800"
                    }`}>
                    {t.type}
                  </span>
                </td>
                <td className="border p-2 text-gray-600">{t.subject || "â€”"}</td>
                <td className="border p-2 text-gray-500 text-sm">
                  {t.content.substring(0, 50)}
                  {t.content.length > 50 && "..."}
                </td>
                <td className="border p-2 text-center">
                  <button
                    onClick={() => handleDelete(t.id)}
                    className="text-red-600 hover:underline text-sm">
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}


// ==========================================
// FILE: frontend_harness/src/components/FinancialsSection.tsx 
// ==========================================
import { useCallback, useEffect, useState } from "react";
import type { EventFinancials, Expense } from "../types";
import { getEventFinancials, addExpense, upsertBudget } from "../apiClient";
import BudgetOverview from "./BudgetOverview";

interface Props {
  eventId: string;
  // NEW PROP: Accepts a key from the parent to force reload
  refreshKey: number;
}

export default function FinancialsSection({ eventId, refreshKey }: Props) {
  const [financials, setFinancials] = useState<EventFinancials | null>(null);
  const [loading, setLoading] = useState(true);

  // Form State
  const [showAddExpense, setShowAddExpense] = useState(false);
  const [newExpense, setNewExpense] = useState({
    description: "",
    amount: 0,
    category: "General",
    dateIncurred: new Date().toISOString().split("T")[0],
  });

  // Renamed loadData to fetchFinancials for clarity
  const fetchFinancials = useCallback(async () => {
    try {
      setLoading(true);
      const data = await getEventFinancials(eventId);
      setFinancials(data);
    } catch (error) {
      console.error("Failed to load financials", error);
    } finally {
      setLoading(false);
    }
  }, [eventId]); // Dependency: Only changes if the eventId itself changes

  // FIX: Reruns fetchFinancials whenever eventId OR refreshKey changes
  // The 'refreshKey' forces a re-render/re-fetch whenever the parent updates the key.
  useEffect(() => {
    fetchFinancials();
  }, [fetchFinancials, refreshKey]); // Added refreshKey as a direct trigger

  const handleCreateBudget = async () => {
    const amountStr = prompt("Enter Total Budget Amount:", "10000");
    if (!amountStr) return;
    await upsertBudget(eventId, parseFloat(amountStr), "USD", "Initial Budget");
    fetchFinancials();
  };

  const handleSubmitExpense = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newExpense.amount || !newExpense.description) return;

    await addExpense(
      eventId,
      newExpense.description,
      newExpense.amount,
      new Date(newExpense.dateIncurred).toISOString(),
      newExpense.category
    );

    setShowAddExpense(false);
    setNewExpense({
      description: "",
      amount: 0,
      category: "General",
      dateIncurred: new Date().toISOString().split("T")[0],
    });
    fetchFinancials();
  };

  if (loading)
    return (
      <div className="p-8 text-center text-gray-400">Calculating Ledger...</div>
    );

  // Scenario 1: No Budget Exists
  if (
    !financials ||
    (financials.budgetTotal === 0 && financials.expenses.length === 0)
  ) {
    return (
      <div className="text-center p-12 bg-[#333] rounded-xl border border-dashed border-gray-600 mb-8">
        <h3 className="text-lg font-medium text-white">No Budget Set</h3>
        <p className="mt-1 text-gray-400">
          Initialize a budget to start tracking expenses.
        </p>
        <button
          onClick={handleCreateBudget}
          className="mt-4 px-6 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition-colors">
          Create Budget
        </button>
      </div>
    );
  }

  return (
    <div className="space-y-8">
      <BudgetOverview data={financials} onEditBudget={handleCreateBudget} />

      <div className="flex justify-between items-center mb-4">
        <h3 className="text-xl font-bold text-white">Expenses</h3>
        <button
          onClick={() => setShowAddExpense(!showAddExpense)}
          className="px-4 py-2 bg-indigo-600 text-white rounded-md text-sm hover:bg-indigo-700 font-medium transition-colors">
          {showAddExpense ? "Cancel" : "+ Add Expense"}
        </button>
      </div>

      {showAddExpense && (
        <form
          onSubmit={handleSubmitExpense}
          className="bg-[#444] p-6 rounded-lg mb-6 border border-gray-600 grid grid-cols-1 md:grid-cols-4 gap-4 items-end">
          <div className="md:col-span-2">
            <label className="block text-xs font-medium text-gray-300 mb-1">
              Description
            </label>
            <input
              type="text"
              value={newExpense.description}
              onChange={(e) =>
                setNewExpense({ ...newExpense, description: e.target.value })
              }
              className="w-full rounded bg-[#333] border-gray-600 text-white p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500"
              required
            />
          </div>
          <div>
            <label className="block text-xs font-medium text-gray-300 mb-1">
              Amount ($)
            </label>
            <input
              type="number"
              value={newExpense.amount}
              onChange={(e) =>
                setNewExpense({
                  ...newExpense,
                  amount: parseFloat(e.target.value),
                })
              }
              className="w-full rounded bg-[#333] border-gray-600 text-white p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500"
              required
            />
          </div>
          <div>
            <label className="block text-xs font-medium text-gray-300 mb-1">
              Category
            </label>
            <select
              value={newExpense.category}
              onChange={(e) =>
                setNewExpense({ ...newExpense, category: e.target.value })
              }
              className="w-full rounded bg-[#333] border-gray-600 text-white p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500">
              {[
                "General",
                "Venue",
                "Catering",
                "Talent",
                "Production",
                "Marketing",
              ].map((c) => (
                <option key={c} value={c}>
                  {c}
                </option>
              ))}
            </select>
          </div>
          <button
            type="submit"
            className="bg-emerald-600 text-white py-2 px-4 rounded hover:bg-emerald-700 font-medium">
            Save
          </button>
        </form>
      )}

      <div className="bg-[#333] border border-gray-600 rounded-lg overflow-hidden shadow-md">
        <table className="table-fixed w-full text-left">
          <thead className="bg-[#222] text-gray-300 uppercase text-xs tracking-wider border-b border-gray-600">
            <tr>
              <th className="px-6 py-4 w-[15%]">Date</th>
              <th className="px-6 py-4 w-[35%]">Description</th>
              <th className="px-6 py-4 w-[15%]">Category</th>
              <th className="px-6 py-4 w-[15%]">Vendor</th>
              <th className="px-6 py-4 w-[20%] text-right">Amount</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-700">
            {financials.expenses.map((expense: Expense) => (
              <tr
                key={expense.id}
                className="hover:bg-[#383838] transition-colors">
                <td className="px-6 py-4 text-sm text-gray-300">
                  {new Date(expense.dateIncurred).toLocaleDateString()}
                </td>
                <td className="px-6 py-4 text-sm font-medium text-white">
                  {expense.description}
                  {expense.linkedDocumentName && (
                    <span className="ml-2 px-2 py-0.5 bg-blue-900 text-blue-200 text-xs rounded-full border border-blue-700">
                      Invoice
                    </span>
                  )}
                </td>
                <td className="px-6 py-4 text-sm text-gray-300">
                  <span className="px-2 py-1 text-xs font-semibold rounded-full bg-[#444] text-gray-200 border border-gray-600">
                    {expense.category}
                  </span>
                </td>
                <td className="px-6 py-4 text-sm text-gray-300">
                  {expense.vendorName || "-"}
                </td>
                <td className="px-6 py-4 text-sm text-right font-mono font-medium text-emerald-400">
                  ${expense.amount.toLocaleString()}
                </td>
              </tr>
            ))}
            {financials.expenses.length === 0 && (
              <tr>
                <td
                  colSpan={5}
                  className="px-6 py-8 text-center text-sm text-gray-500">
                  No expenses recorded yet.
                </td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
}


// ==========================================
// FILE: frontend_harness/src/components/VendorEventsTable.tsx 
// ==========================================
import React, { useState, useEffect, useCallback } from "react";
import { apiClient } from "../apiClient";
import type { EventDto, Guid } from "../types";

interface VendorEventsTableProps {
  vendorId: Guid;
}

const VendorEventsTable: React.FC<VendorEventsTableProps> = ({ vendorId }) => {
  const [events, setEvents] = useState<EventDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // FIX: Wrap in useCallback to satisfy ESLint and allow usage in useEffect + Retry button
  const fetchEvents = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const response = await apiClient.get<EventDto[]>(
        `/api/vendors/${vendorId}/events`
      );
      setEvents(response.data);
    } catch (err) {
      console.error("Error fetching events for vendor:", err);
      setError("Failed to load events.");
    } finally {
      setLoading(false);
    }
  }, [vendorId]); // Re-create function only if vendorId changes

  useEffect(() => {
    if (vendorId) {
      fetchEvents();
    }
  }, [fetchEvents, vendorId]); // FIX: Added fetchEvents dependency

  if (loading) return <div style={{ padding: "10px" }}>Loading events...</div>;

  if (error)
    return (
      <div style={{ color: "red", padding: "10px" }}>
        {error} <button onClick={fetchEvents}>Retry</button>
      </div>
    );

  return (
    <div style={{ marginBottom: "30px" }}>
      <h3>Events Hired For ({events.length})</h3>
      {events.length === 0 ? (
        <p>This vendor is not currently linked to any events.</p>
      ) : (
        <table style={{ width: "100%", borderCollapse: "collapse" }}>
          <thead>
            <tr style={{ borderBottom: "2px solid #ccc" }}>
              <th style={{ padding: "8px", textAlign: "left" }}>Event Name</th>
              <th style={{ padding: "8px", textAlign: "left" }}>Date</th>
              <th style={{ padding: "8px", textAlign: "left" }}>Status</th>
            </tr>
          </thead>
          <tbody>
            {events.map((event) => (
              <tr key={event.id} style={{ borderBottom: "1px solid #eee" }}>
                <td style={{ padding: "8px" }}>{event.name}</td>
                <td style={{ padding: "8px" }}>
                  {new Date(event.startDateTime).toLocaleDateString()}
                </td>
                <td style={{ padding: "8px" }}>{event.status}</td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
};

export default VendorEventsTable;


// ==========================================
// FILE: frontend_harness/src/components/ContactsPage.tsx 
// ==========================================
// =======================================================
// FILE: frontend_harness/src/components/ContactsPage.tsx
// =======================================================
import { useEffect, useState } from "react";
import { apiClient } from "../apiClient";
import type { ContactDto } from "../types";
import { LeadStage, ConnectionStatus } from "../types";
import axios from "axios";

import { useSelectionContext } from "../context/useSelectionContext";
import {
  RelatedTasks,
  RelatedNotes,
  ContactEventsTable,
  EmailHistoryTable,
} from "./RelatedTables";

type ContactFormData = Omit<ContactDto, "id">;

type ValidationErrors = {
  [key: string]: string[];
};

// Local definition for Template to avoid editing types.ts in this turn
type TemplateDto = {
  id: string;
  name: string;
  content: string;
};

const styleSheet = document.createElement("style");
styleSheet.type = "text/css";
styleSheet.innerText = `
  .contact-row:hover {
    cursor: pointer;
    background-color: #333;
  }
  .selected-row {
    background-color: #004a99;
    color: white;
  }
  .selected-row:hover {
    background-color: #005ac7;
  }
  .modal-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  .modal-content {
    background: #222;
    padding: 2rem;
    border: 1px solid #555;
    min-width: 400px;
    border-radius: 8px;
  }
`;
document.head.appendChild(styleSheet);

function ContactsPage() {
  const [contacts, setContacts] = useState<ContactDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // --- Email Scheduling State ---
  const [templates, setTemplates] = useState<TemplateDto[]>([]);
  const [isEmailModalOpen, setIsEmailModalOpen] = useState(false);
  const [emailConfig, setEmailConfig] = useState({
    contactId: "",
    contactName: "", // For display
    templateId: "",
    sendAt: "",
  });
  // ------------------------------

  const initialFormState: ContactFormData = {
    firstName: "",
    lastName: "",
    email: "",
    phoneNumber: null,
    title: null,
    organization: null,
    // New Pipeline Fields
    stage: LeadStage.NewLead,
    connectionStatus: ConnectionStatus.NeedToMeet,
    isLead: true,
    followUpCount: 0,
    source: null,
    lastContactedAt: null,
  };

  const [formData, setFormData] =
    useState<Partial<ContactDto>>(initialFormState);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<ValidationErrors>(
    {}
  );

  const { selectedContactId, setSelectedContactId } = useSelectionContext();

  const isEditing = editingId !== null;

  const fetchContacts = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiClient.get<ContactDto[]>("/api/contacts");
      setContacts(response.data);
    } catch (err: unknown) {
      console.error(err);
      let errorMessage = "Failed to fetch contacts. An unknown error occurred.";
      if (err instanceof Error) {
        errorMessage = `Failed to fetch contacts: ${err.message}`;
      }
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  // Fetch Templates for the dropdown
  const fetchTemplates = async () => {
    try {
      const response = await apiClient.get<TemplateDto[]>("/api/templates");
      setTemplates(response.data);
    } catch (err) {
      console.error("Failed to load templates", err);
    }
  };

  useEffect(() => {
    fetchContacts();
    fetchTemplates();
    return () => {
      setSelectedContactId(null);
    };
  }, [setSelectedContactId]);

  const handleDelete = async (id: string) => {
    if (!window.confirm("Are you sure you want to delete this contact?")) {
      return;
    }

    if (id === selectedContactId) {
      setSelectedContactId(null);
    }

    try {
      await apiClient.delete(`/api/contacts/${id}`);
      await fetchContacts();
    } catch (err) {
      console.error(err);
      if (err instanceof Error) {
        alert(`Failed to delete contact: ${err.message}`);
      }
    }
  };

  const handleEdit = (contact: ContactDto) => {
    setEditingId(contact.id);
    setFormData(contact);
    setValidationErrors({});
    window.scrollTo(0, 0);
  };

  const handleCancel = () => {
    setEditingId(null);
    setFormData(initialFormState);
    setValidationErrors({});
  };

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>
  ) => {
    const { name, value, type } = e.target;

    setFormData((prev) => {
      let newValue: string | number | boolean | null =
        value === "" ? null : value;

      // Handle Numeric Enums (Stage & ConnectionStatus)
      if (name === "stage" || name === "connectionStatus") {
        newValue = parseInt(value, 10);
      }

      // Handle Checkbox
      if (type === "checkbox") {
        newValue = (e.target as HTMLInputElement).checked;
      }

      return {
        ...prev,
        [name]: newValue,
      };
    });
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setValidationErrors({});

    const payload = {
      ...formData,
      firstName: formData.firstName ?? "",
      lastName: formData.lastName ?? "",
      email: formData.email ?? "",
      stage: formData.stage ?? LeadStage.NewLead,
      connectionStatus:
        formData.connectionStatus ?? ConnectionStatus.NeedToMeet,
      isLead: formData.isLead ?? true,
      followUpCount: formData.followUpCount ?? 0,
    };

    const promise = isEditing
      ? apiClient.put(`/api/contacts/${editingId}`, payload)
      : apiClient.post("/api/contacts", payload);

    try {
      await promise;
      handleCancel();
      await fetchContacts();
    } catch (err: unknown) {
      if (axios.isAxiosError(err) && err.response?.status === 400) {
        const apiErrors = err.response.data.errors || {
          General: ["An unknown validation error occurred."],
        };
        setValidationErrors(apiErrors);
      } else {
        console.error(err);
        alert("An unexpected error occurred.");
      }
    }
  };

  const handleRowClick = (contactId: string) => {
    if (isEditing) {
      handleCancel();
    }

    if (selectedContactId === contactId) {
      setSelectedContactId(null);
    } else {
      setSelectedContactId(contactId);
    }
  };

  // --- Email Modal Handlers ---
  const openEmailModal = (e: React.MouseEvent, contact: ContactDto) => {
    e.stopPropagation(); // Prevent row selection
    setEmailConfig({
      contactId: contact.id,
      contactName: `${contact.firstName} ${contact.lastName}`,
      templateId: templates.length > 0 ? templates[0].id : "",
      sendAt: "",
    });
    setIsEmailModalOpen(true);
  };

  const handleEmailSubmit = async () => {
    if (!emailConfig.templateId) {
      alert("Please select a template.");
      return;
    }

    try {
      await apiClient.post("/api/automation/schedule-email", {
        contactId: emailConfig.contactId,
        templateId: emailConfig.templateId,
        sendAt: emailConfig.sendAt
          ? new Date(emailConfig.sendAt).toISOString()
          : null,
      });
      alert("Email scheduled successfully!");
      setIsEmailModalOpen(false);
    } catch (err) {
      console.error(err);
      alert("Failed to schedule email.");
    }
  };
  // ----------------------------

  if (error) return <p style={{ color: "red" }}>{error}</p>;

  return (
    <div>
      {/* --- Email Modal --- */}
      {isEmailModalOpen && (
        <div className="modal-overlay">
          <div className="modal-content">
            <h3>Send Email to: {emailConfig.contactName}</h3>

            <div style={{ marginBottom: "1rem" }}>
              <label style={{ display: "block", marginBottom: "0.5rem" }}>
                Select Template:
              </label>
              <select
                style={{ width: "100%", padding: "0.5rem" }}
                value={emailConfig.templateId}
                onChange={(e) =>
                  setEmailConfig((prev) => ({
                    ...prev,
                    templateId: e.target.value,
                  }))
                }>
                <option value="">-- Select a Template --</option>
                {templates.map((t) => (
                  <option key={t.id} value={t.id}>
                    {t.name}
                  </option>
                ))}
              </select>
            </div>

            <div style={{ marginBottom: "1rem" }}>
              <label style={{ display: "block", marginBottom: "0.5rem" }}>
                Send At (Optional):
              </label>
              <input
                type="datetime-local"
                style={{ width: "100%", padding: "0.5rem" }}
                value={emailConfig.sendAt}
                onChange={(e) =>
                  setEmailConfig((prev) => ({
                    ...prev,
                    sendAt: e.target.value,
                  }))
                }
              />
              <small>Leave blank to send immediately.</small>
            </div>

            <div
              style={{
                display: "flex",
                justifyContent: "flex-end",
                gap: "1rem",
              }}>
              <button onClick={() => setIsEmailModalOpen(false)}>Cancel</button>
              <button
                onClick={handleEmailSubmit}
                style={{ backgroundColor: "#004a99", color: "white" }}>
                Send Email
              </button>
            </div>
          </div>
        </div>
      )}

      <div
        style={{
          marginBottom: "2rem",
          padding: "1rem",
          border: "1px solid #555",
        }}>
        <h2>{isEditing ? "Edit Contact" : "Create Contact"}</h2>
        <form onSubmit={handleSubmit}>
          {/* --- Identity Fields --- */}
          <div style={{ display: "flex", gap: "1rem" }}>
            <div style={{ marginBottom: "0.5rem", flex: 1 }}>
              <label>First Name: </label>
              <input
                name="firstName"
                value={formData.firstName ?? ""}
                onChange={handleChange}
                style={{ width: "100%" }}
              />
              {validationErrors.FirstName && (
                <div style={{ color: "red" }}>
                  {validationErrors.FirstName[0]}
                </div>
              )}
            </div>
            <div style={{ marginBottom: "0.5rem", flex: 1 }}>
              <label>Last Name: </label>
              <input
                name="lastName"
                value={formData.lastName ?? ""}
                onChange={handleChange}
                style={{ width: "100%" }}
              />
              {validationErrors.LastName && (
                <div style={{ color: "red" }}>
                  {validationErrors.LastName[0]}
                </div>
              )}
            </div>
          </div>

          <div style={{ display: "flex", gap: "1rem" }}>
            <div style={{ marginBottom: "0.5rem", flex: 1 }}>
              <label>Email: </label>
              <input
                name="email"
                value={formData.email ?? ""}
                onChange={handleChange}
                style={{ width: "100%" }}
              />
              {validationErrors.Email && (
                <div style={{ color: "red" }}>{validationErrors.Email[0]}</div>
              )}
            </div>
            <div style={{ marginBottom: "0.5rem", flex: 1 }}>
              <label>Phone: </label>
              <input
                name="phoneNumber"
                value={formData.phoneNumber ?? ""}
                onChange={handleChange}
                style={{ width: "100%" }}
              />
            </div>
          </div>

          {/* --- Pipeline & Strategy Fields (NEW) --- */}
          <div
            style={{
              margin: "1rem 0",
              padding: "1rem",
              border: "1px dashed #666",
              borderRadius: "4px",
            }}>
            <h4 style={{ marginTop: 0, marginBottom: "0.5rem" }}>
              Pipeline Status
            </h4>
            <div style={{ display: "flex", gap: "1rem", flexWrap: "wrap" }}>
              {/* Stage Dropdown */}
              <div style={{ flex: 1 }}>
                <label>Lead Stage: </label>
                <select
                  name="stage"
                  value={formData.stage ?? LeadStage.NewLead}
                  onChange={handleChange}
                  style={{ width: "100%", padding: "4px" }}>
                  {Object.entries(LeadStage).map(([key, value]) => (
                    <option key={key} value={value}>
                      {key}
                    </option>
                  ))}
                </select>
              </div>

              {/* Connection Status Dropdown */}
              <div style={{ flex: 1 }}>
                <label>Connection Status: </label>
                <select
                  name="connectionStatus"
                  value={
                    formData.connectionStatus ?? ConnectionStatus.NeedToMeet
                  }
                  onChange={handleChange}
                  style={{ width: "100%", padding: "4px" }}>
                  {Object.entries(ConnectionStatus).map(([key, value]) => (
                    <option key={key} value={value}>
                      {key}
                    </option>
                  ))}
                </select>
              </div>

              {/* Is Lead Checkbox */}
              <div
                style={{
                  flex: "0 0 auto",
                  display: "flex",
                  alignItems: "center",
                  paddingTop: "1.2rem",
                }}>
                <label
                  style={{
                    display: "flex",
                    alignItems: "center",
                    cursor: "pointer",
                  }}>
                  <input
                    type="checkbox"
                    name="isLead"
                    checked={formData.isLead ?? true}
                    onChange={handleChange}
                    style={{ marginRight: "0.5rem" }}
                  />
                  Is Lead?
                </label>
              </div>
            </div>
          </div>

          <div style={{ marginBottom: "0.5rem" }}>
            <label>Organization: </label>
            <input
              name="organization"
              value={formData.organization ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Title: </label>
            <input
              name="title"
              value={formData.title ?? ""}
              onChange={handleChange}
            />
          </div>

          <button type="submit">{isEditing ? "Save Changes" : "Create"}</button>
          {isEditing && (
            <button
              type="button"
              onClick={handleCancel}
              style={{ marginLeft: "0.5rem" }}>
              Cancel
            </button>
          )}
          {validationErrors.General && (
            <div style={{ color: "red", marginTop: "1rem" }}>
              {validationErrors.General[0]}
            </div>
          )}
        </form>
      </div>

      <h2>Contacts List</h2>
      {loading ? (
        <p>Loading Contacts...</p>
      ) : contacts.length === 0 ? (
        <p>No contacts found.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Name</th>
              <th>Email</th>
              <th>Status</th> {/* NEW COLUMN */}
              <th>Organization</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {contacts.map((contact) => (
              <tr
                key={contact.id}
                className={`
                  contact-row 
                  ${selectedContactId === contact.id ? "selected-row" : ""}
                `}
                onClick={(e) => {
                  if (
                    e.target instanceof HTMLElement &&
                    e.target.tagName !== "BUTTON" &&
                    e.target.tagName !== "SELECT"
                  ) {
                    handleRowClick(contact.id);
                  }
                }}>
                <td>{contact.id.substring(0, 8)}...</td>
                <td>
                  {contact.firstName} {contact.lastName}
                </td>
                <td>{contact.email}</td>
                {/* NEW STATUS COLUMN */}
                <td>
                  <span
                    style={{
                      fontSize: "0.8rem",
                      padding: "2px 4px",
                      background: "#444",
                      borderRadius: "4px",
                    }}>
                    {Object.keys(LeadStage).find(
                      (key) =>
                        LeadStage[key as keyof typeof LeadStage] ===
                        contact.stage
                    )}
                  </span>
                </td>
                <td>{contact.organization ?? "N/A"}</td>
                <td>
                  <button
                    onClick={() => handleEdit(contact)}
                    style={{ color: "lightblue", marginRight: "0.5rem" }}>
                    Edit
                  </button>
                  <button
                    onClick={() => handleDelete(contact.id)}
                    style={{ color: "red", marginRight: "0.5rem" }}>
                    Delete
                  </button>
                  <button
                    onClick={(e) => openEmailModal(e, contact)}
                    style={{ color: "lightgreen" }}>
                    Send Email
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}

      {selectedContactId && (
        <div
          style={{
            borderTop: "2px solid #555",
            marginTop: "3rem",
            paddingTop: "1rem",
          }}>
          <h2>Contact Dashboard: ID {selectedContactId}</h2>
          <ContactEventsTable />
          <RelatedTasks />
          <RelatedNotes />
          <EmailHistoryTable />
        </div>
      )}
    </div>
  );
}

export default ContactsPage;


// ==========================================
// FILE: frontend_harness/src/components/EventsPage.tsx 
// ==========================================
// FILE: frontend_harness/src/components/EventsPage.tsx
import React, { useEffect, useState, useCallback } from "react";
import { apiClient } from "../apiClient";
// FIX 1: Removed unused 'Guid' import
import type { EventDto, ContactDto, VendorDto } from "../types";
import axios from "axios";
import { useSelectionContext } from "../context/useSelectionContext";
import {
  RelatedTasks,
  RelatedNotes,
  EventParticipantsTable,
} from "./RelatedTables";
import { DocumentsSection } from "./DocumentsSection";
// --- NEW: Import the Financials Module ---
import FinancialsSection from "./FinancialsSection";

type EventFormData = Omit<EventDto, "id">;
type ValidationErrors = { [key: string]: string[] };

// --- SUB-COMPONENT: EventVendorAttributesDisplay ---
interface VendorAttributeProps {
  eventVendors: VendorDto[]; // All vendors linked to the event (or fetched separately)
}

const EventVendorAttributesDisplay: React.FC<VendorAttributeProps> = ({
  eventVendors,
}) => {
  // Filter for vendors whose attributes we care about displaying prominently on the dashboard
  const featuredVendors = eventVendors.filter(
    (v) =>
      v.serviceType?.toLowerCase() === "venue" ||
      v.serviceType?.toLowerCase() === "entertainment"
  );

  if (featuredVendors.length === 0) {
    return null;
  }

  return (
    <div
      style={{
        marginTop: "20px",
        padding: "15px",
        border: "1px solid #777",
        borderRadius: "5px",
        backgroundColor: "#333",
      }}>
      <h4 style={{ margin: 0, color: "#ccc" }}>Key Vendor Attributes</h4>
      <div
        style={{
          marginTop: "10px",
          display: "flex",
          flexWrap: "wrap",
          gap: "20px",
        }}>
        {featuredVendors.map((vendor) => {
          let attributeDisplay = null;
          // FIX 2: Changed 'let title' to 'const title'
          const title = vendor.name;

          try {
            if (vendor.attributes) {
              const attrs = JSON.parse(vendor.attributes);

              if (
                vendor.serviceType?.toLowerCase() === "venue" &&
                attrs.Capacity
              ) {
                attributeDisplay = `Capacity: ${attrs.Capacity}`;
              } else if (
                vendor.serviceType?.toLowerCase() === "entertainment" &&
                attrs.Genre
              ) {
                attributeDisplay = `Genre: ${attrs.Genre}`;
              }
            }
          } catch (e) {
            console.error("Error parsing vendor attributes:", e);
          }

          if (!attributeDisplay) {
            // Skip if the required key isn't found
            return null;
          }

          return (
            <div
              key={vendor.id}
              style={{ borderLeft: "3px solid #64b5f6", paddingLeft: "10px" }}>
              <strong style={{ display: "block", color: "#fff" }}>
                {title} ({vendor.serviceType})
              </strong>
              <span style={{ color: "#aaa", fontSize: "0.9rem" }}>
                {attributeDisplay}
              </span>
            </div>
          );
        })}
      </div>
    </div>
  );
};
// --- END EventVendorAttributesDisplay ---

// --- SUB-COMPONENT: ContactLinker ---
interface ContactLinkerProps {
  eventId: string;
  onLinkSuccess: () => void;
}

const ContactLinker: React.FC<ContactLinkerProps> = ({
  eventId,
  onLinkSuccess,
}) => {
  const [contacts, setContacts] = useState<ContactDto[]>([]);
  const [selectedContactId, setSelectedContactId] = useState<string>("");
  const [loading, setLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchContacts = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<ContactDto[]>("/api/contacts");
        setContacts(response.data);
        if (response.data.length > 0) {
          setSelectedContactId(response.data[0].id);
        }
      } catch (err) {
        console.error("Failed to fetch all contacts:", err);
      } finally {
        setLoading(false);
      }
    };
    fetchContacts();
  }, []);

  const handleLink = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!selectedContactId) {
      setError("Please select a contact to link.");
      return;
    }

    setIsSubmitting(true);
    setError(null);
    try {
      const payload = { contactId: selectedContactId };
      await apiClient.post(`/api/events/${eventId}/contacts`, payload);

      onLinkSuccess();
      setError(null);
    } catch (err) {
      const message =
        axios.isAxiosError(err) && err.response?.data?.title
          ? err.response.data.title
          : "Failed to link contact to event.";
      setError(message);
    } finally {
      setIsSubmitting(false);
    }
  };

  if (loading) return <p>Loading contacts for linking...</p>;
  if (contacts.length === 0) return <p>No available contacts to link.</p>;
  return (
    <div
      style={{
        border: "1px dashed #ccc",
        padding: "1rem",
        marginBottom: "1rem",
      }}>
      <h4>Link Contact to Event</h4>
      <form onSubmit={handleLink} style={{ display: "flex", gap: "10px" }}>
        <select
          value={selectedContactId}
          onChange={(e) => setSelectedContactId(e.target.value)}
          disabled={isSubmitting}>
          {contacts.map((contact) => (
            <option key={contact.id} value={contact.id}>
              {contact.firstName} {contact.lastName} ({contact.email})
            </option>
          ))}
        </select>
        <button type="submit" disabled={isSubmitting}>
          {isSubmitting ? "Linking..." : "Link Contact"}
        </button>
      </form>
      {error && (
        <div style={{ color: "red", marginTop: "0.5rem" }}>Error: {error}</div>
      )}
    </div>
  );
};
// --- END ContactLinker ---

function EventsPage() {
  const [events, setEvents] = useState<EventDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // FIX 3: Removed unused 'allVendors' state
  const [eventVendors, setEventVendors] = useState<VendorDto[]>([]);
  // ----------------------------------

  const { selectedEventId, setSelectedEventId } = useSelectionContext();
  const [dashboardKey, setDashboardKey] = useState(0);

  const initialFormState: EventFormData = {
    name: "",
    description: null,
    startDateTime: "",
    endDateTime: "",
    location: null,
    isPublic: false,
    status: "Planned",
  };
  const [formData, setFormData] = useState<Partial<EventDto>>(initialFormState);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<ValidationErrors>(
    {}
  );

  const isEditing = editingId !== null;

  // --- PHASE 29: Fetch Vendor Data for Attribute Display (Simplified) ---
  const fetchAuxiliaryData = useCallback(async () => {
    try {
      // We only need the vendors linked to the *current* event
      // (which implicitly includes their attributes via the backend DTO)
      const eventVendorsResponse = selectedEventId
        ? await apiClient.get<VendorDto[]>(
            `/api/events/${selectedEventId}/vendors`
          )
        : { data: [] as VendorDto[] };

      setEventVendors(eventVendorsResponse.data);
    } catch (err) {
      console.error("Failed to fetch event vendor data:", err);
    }
  }, [selectedEventId]);
  // --------------------------------------------------------

  const forceDashboardRefresh = () => {
    setDashboardKey((prev) => prev + 1);
    fetchAuxiliaryData(); // Refetch vendor data when related tables change
  };

  const fetchEvents = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiClient.get<EventDto[]>("/api/events");
      setEvents(response.data);
    } catch (err: unknown) {
      console.error(err);
      setError("Failed to fetch events.");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchEvents();
  }, []);

  // --- PHASE 29: Refetch auxiliary data when event ID changes ---
  useEffect(() => {
    if (selectedEventId) {
      fetchAuxiliaryData();
    } else {
      setEventVendors([]);
    }
  }, [selectedEventId, fetchAuxiliaryData]);
  // -------------------------------------------------------------

  const handleDelete = async (id: string) => {
    if (!window.confirm("Are you sure you want to delete this event?")) return;
    try {
      await apiClient.delete(`/api/events/${id}`);
      setSelectedEventId(null);
      await fetchEvents();
    } catch (err) {
      console.error(err);
      alert("Failed to delete event.");
    }
  };

  const handleEdit = (event: EventDto) => {
    setEditingId(event.id);
    setFormData({
      ...event,
      startDateTime: event.startDateTime.slice(0, 16),
      endDateTime: event.endDateTime.slice(0, 16),
    });
    setValidationErrors({});
    window.scrollTo(0, 0);
  };

  const handleCancel = () => {
    setEditingId(null);
    setFormData(initialFormState);
    setValidationErrors({});
  };

  const handleChange = (
    e: React.ChangeEvent<
      HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement
    >
  ) => {
    const { name, value, type } = e.target;
    if (type === "checkbox") {
      setFormData((prev) => ({
        ...prev,
        [name]: (e.target as HTMLInputElement).checked,
      }));
    } else {
      setFormData((prev) => ({
        ...prev,
        [name]: value === "" ? null : value,
      }));
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setValidationErrors({});

    const payload = {
      ...formData,
      startDateTime: formData.startDateTime
        ? new Date(formData.startDateTime).toISOString()
        : "",
      endDateTime: formData.endDateTime
        ? new Date(formData.endDateTime).toISOString()
        : "",
    };
    const promise = isEditing
      ? apiClient.put(`/api/events/${editingId}`, payload)
      : apiClient.post("/api/events", payload);

    try {
      await promise;
      handleCancel();
      setSelectedEventId(null);
      await fetchEvents();
    } catch (err: unknown) {
      if (axios.isAxiosError(err) && err.response?.status === 400) {
        setValidationErrors(
          err.response.data.errors || { General: ["Validation Error"] }
        );
      } else {
        console.error(err);
        alert("An unexpected error occurred.");
      }
    }
  };

  const handleRowClick = (eventId: string) => {
    if (selectedEventId === eventId) {
      setSelectedEventId(null);
    } else {
      setSelectedEventId(eventId);
    }
    // The key update forces the entire dashboard section to remount.
    setDashboardKey((prev) => prev + 1);
  };

  if (error) return <p style={{ color: "red" }}>{error}</p>;

  return (
    <div>
      <div
        style={{
          marginBottom: "2rem",
          padding: "1rem",
          border: "1px solid #555",
        }}>
        <h2>{isEditing ? "Edit Event" : "Create Event"}</h2>
        <form onSubmit={handleSubmit}>
          {/* ... (Form fields remain the same) ... */}
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Name: </label>
            <input
              name="name"
              value={formData.name ?? ""}
              onChange={handleChange}
            />
            {validationErrors.Name && (
              <div style={{ color: "red" }}>{validationErrors.Name[0]}</div>
            )}
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Description: </label>
            <textarea
              name="description"
              value={formData.description ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Start Time: </label>
            <input
              name="startDateTime"
              type="datetime-local"
              value={formData.startDateTime ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>End Time: </label>
            <input
              name="endDateTime"
              type="datetime-local"
              value={formData.endDateTime ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Location: </label>
            <input
              name="location"
              value={formData.location ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Status: </label>
            <select
              name="status"
              value={formData.status ?? "Planned"}
              onChange={handleChange}>
              <option value="Planned">Planned</option>
              <option value="Confirmed">Confirmed</option>
              <option value="Cancelled">Cancelled</option>
            </select>
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>
              <input
                name="isPublic"
                type="checkbox"
                checked={formData.isPublic ?? false}
                onChange={handleChange}
              />
              Is Public
            </label>
          </div>

          <button type="submit">{isEditing ? "Save Changes" : "Create"}</button>
          {isEditing && (
            <button
              type="button"
              onClick={handleCancel}
              style={{ marginLeft: "0.5rem" }}>
              Cancel
            </button>
          )}
          {validationErrors.General && (
            <div style={{ color: "red", marginTop: "1rem" }}>
              {validationErrors.General[0]}
            </div>
          )}
        </form>
      </div>

      <h2>Events List (Click a row for related data)</h2>
      {loading ? (
        <p>Loading Events...</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Name</th>
              <th>Status</th>
              <th>Start</th>
              <th>End</th>
              <th>Location</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {events.map((event) => (
              <tr
                key={event.id}
                onClick={() => handleRowClick(event.id)}
                style={{
                  cursor: "pointer",
                  backgroundColor:
                    event.id === selectedEventId ? "#444" : "inherit",
                }}>
                <td>{event.id}</td>
                <td>{event.name}</td>
                <td>{event.status}</td>
                <td>{new Date(event.startDateTime).toLocaleString()}</td>
                <td>{new Date(event.endDateTime).toLocaleString()}</td>
                <td>{event.location ?? "N/A"}</td>
                <td>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      handleEdit(event);
                    }}
                    style={{ color: "blue" }}>
                    Edit
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      handleDelete(event.id);
                    }}
                    style={{ color: "red", marginLeft: "0.5rem" }}>
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}

      {/* --- DASHBOARD --- */}
      {selectedEventId && (
        <div
          key={dashboardKey}
          style={{
            borderTop: "2px solid #555",
            marginTop: "3rem",
            paddingTop: "1rem",
          }}>
          <h2 style={{ marginBottom: "2rem" }}>
            Dashboard: Event ID {selectedEventId}
          </h2>

          {/* --- PHASE 29: DISPLAY VENDOR ATTRIBUTES --- */}
          <EventVendorAttributesDisplay eventVendors={eventVendors} />
          {/* --------------------------------------------- */}

          {/* 1. Financials (High Priority) */}
          <div style={{ marginBottom: "3rem" }}>
            <FinancialsSection
              eventId={selectedEventId}
              refreshKey={dashboardKey}
            />
          </div>

          <hr style={{ margin: "2rem 0", borderColor: "#ccc" }} />

          {/* 2. Contacts & Documents */}
          <div
            style={{
              display: "grid",
              gridTemplateColumns: "1fr 1fr",
              gap: "2rem",
            }}>
            <div>
              <ContactLinker
                eventId={selectedEventId}
                onLinkSuccess={forceDashboardRefresh}
              />
              <EventParticipantsTable onUnlinkSuccess={forceDashboardRefresh} />
            </div>
            <div>
              <DocumentsSection entityId={selectedEventId} entityType="Event" />
            </div>
          </div>

          <hr style={{ margin: "2rem 0", borderColor: "#ccc" }} />

          {/* 3. Operational (Tasks & Notes) */}
          <RelatedTasks />
          <RelatedNotes />
        </div>
      )}
    </div>
  );
}

export default EventsPage;


// ==========================================
// FILE: frontend_harness/src/components/SendEmailModal.tsx 
// ==========================================
// FILE: frontend_harness/src/components/SendEmailModal.tsx

import React, { useState, useEffect } from "react";
import { templates, scheduleEmail } from "../apiClient";
import type { TemplateDto, ContactDto, VendorDto } from "../types";
import { RecipientType } from "../types";

// --- HELPER FUNCTION: Vendor -> ContactDto Transformer ---
// This keeps the component logic clean and ensures DTO compliance.
const mapVendorToContact = (vendor: VendorDto): ContactDto => {
  return {
    id: vendor.id,
    firstName: vendor.name,
    lastName: "", // Vendors don't have separate last names in this context
    email: vendor.email || "",
    phoneNumber: vendor.phoneNumber,
    organization: vendor.serviceType,
    title: "Vendor",
    stage: 0,
    connectionStatus: 0,
    isLead: false,
    followUpCount: 0,
    lastContactedAt: undefined, // Matches types.ts
    source: "Vendor List",
    role: "Vendor", // Matches types.ts
    attributes: {},
  };
};

interface SendEmailModalProps {
  // Removed 'eventId' to prevent unused variable warning
  isOpen: boolean;
  onClose: () => void;
  availableContacts: ContactDto[];
  availableVendors: VendorDto[];
}

export const SendEmailModal: React.FC<SendEmailModalProps> = ({
  isOpen,
  onClose,
  availableContacts,
  availableVendors,
}) => {
  const [templateList, setTemplateList] = useState<TemplateDto[]>([]);
  const [selectedTemplateId, setSelectedTemplateId] = useState<string>("");
  const [selectedRecipientId, setSelectedRecipientId] = useState<string>("");
  const [recipientType, setRecipientType] = useState<RecipientType>(
    RecipientType.Contact
  );
  const [scheduleTime, setScheduleTime] = useState<string>("");
  const [isSending, setIsSending] = useState(false);

  useEffect(() => {
    if (isOpen) {
      loadTemplates();
      // Reset form state on open
      setSelectedTemplateId("");
      setSelectedRecipientId("");
      setScheduleTime("");
      setRecipientType(RecipientType.Contact);
    }
  }, [isOpen]);

  const loadTemplates = async () => {
    try {
      const data = await templates.getAll();
      setTemplateList(data);
    } catch (error) {
      console.error("Failed to load templates", error);
    }
  };

  const handleSend = async () => {
    if (!selectedTemplateId || !selectedRecipientId) return;

    // 1. Find Template
    const selectedTemplate = templateList.find(
      (t) => t.id === selectedTemplateId
    );
    if (!selectedTemplate) {
      alert("Selected template data not found.");
      return;
    }

    // 2. Prepare Contact Payload
    let contactPayload: ContactDto;

    if (recipientType === RecipientType.Contact) {
      const contact = availableContacts.find(
        (c) => c.id === selectedRecipientId
      );
      if (!contact) return;
      contactPayload = contact;
    } else {
      const vendor = availableVendors.find((v) => v.id === selectedRecipientId);
      if (!vendor) return;
      // Use helper to transform Vendor -> ContactDto
      contactPayload = mapVendorToContact(vendor);
    }

    // 3. Send
    setIsSending(true);
    try {
      await scheduleEmail({
        contact: contactPayload,
        templateContent: selectedTemplate.content || "",
        subject: selectedTemplate.subject || "New Message",
        scheduleTime: scheduleTime || new Date().toISOString(),
      });

      alert("Email scheduled successfully!");
      onClose();
    } catch (error) {
      console.error("Failed to schedule email", error);
      alert("Failed to send email. Check console.");
    } finally {
      setIsSending(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 backdrop-blur-sm">
      <div className="bg-gray-900 border border-gray-700 p-6 rounded-xl shadow-2xl w-full max-w-md text-gray-100">
        <div className="flex justify-between items-center mb-6">
          <h2 className="text-xl font-bold text-white">Send Communication</h2>
          <button onClick={onClose} className="text-gray-400 hover:text-white">
            âœ•
          </button>
        </div>

        {/* Template Selector */}
        <div className="mb-5">
          <label className="block text-xs font-bold text-gray-400 uppercase mb-2">
            Select Template
          </label>
          <select
            className="w-full bg-gray-800 border border-gray-600 p-3 rounded-lg text-white focus:ring-2 focus:ring-blue-500 outline-none"
            value={selectedTemplateId}
            onChange={(e) => setSelectedTemplateId(e.target.value)}>
            <option value="">-- Choose a Template --</option>
            {templateList.map((t) => (
              <option key={t.id} value={t.id}>
                {t.name} ({t.type === 0 ? "Email" : "SMS"})
              </option>
            ))}
          </select>
        </div>

        {/* Recipient Type Toggle */}
        <div className="mb-4 bg-gray-800 p-1 rounded-lg flex">
          <button
            onClick={() => {
              setRecipientType(RecipientType.Contact);
              setSelectedRecipientId("");
            }}
            className={`flex-1 py-2 rounded-md text-sm font-medium transition-all ${
              recipientType === RecipientType.Contact
                ? "bg-blue-600 text-white shadow"
                : "text-gray-400 hover:text-white"
            }`}>
            Contact
          </button>
          <button
            onClick={() => {
              setRecipientType(RecipientType.Vendor);
              setSelectedRecipientId("");
            }}
            className={`flex-1 py-2 rounded-md text-sm font-medium transition-all ${
              recipientType === RecipientType.Vendor
                ? "bg-purple-600 text-white shadow"
                : "text-gray-400 hover:text-white"
            }`}>
            Vendor
          </button>
        </div>

        {/* Recipient Selector */}
        <div className="mb-5">
          <label className="block text-xs font-bold text-gray-400 uppercase mb-2">
            Select{" "}
            {recipientType === RecipientType.Contact ? "Contact" : "Vendor"}
          </label>
          <select
            className="w-full bg-gray-800 border border-gray-600 p-3 rounded-lg text-white focus:ring-2 focus:ring-blue-500 outline-none"
            value={selectedRecipientId}
            onChange={(e) => setSelectedRecipientId(e.target.value)}>
            <option value="">-- Choose Recipient --</option>
            {recipientType === RecipientType.Contact
              ? availableContacts.map((c) => (
                  <option key={c.id} value={c.id}>
                    {c.firstName} {c.lastName}
                  </option>
                ))
              : availableVendors.map((v) => (
                  <option key={v.id} value={v.id}>
                    {v.name} ({v.serviceType})
                  </option>
                ))}
          </select>
        </div>

        {/* Schedule Time */}
        <div className="mb-6">
          <label className="block text-xs font-bold text-gray-400 uppercase mb-2">
            Send At (Optional)
          </label>
          <input
            type="datetime-local"
            className="w-full bg-gray-800 border border-gray-600 p-3 rounded-lg text-white focus:ring-2 focus:ring-blue-500 outline-none"
            value={scheduleTime}
            onChange={(e) => setScheduleTime(e.target.value)}
          />
          <p className="text-xs text-gray-500 mt-1">
            Leave blank to send immediately.
          </p>
        </div>

        {/* Action Buttons */}
        <div className="flex gap-3 pt-2">
          <button
            onClick={onClose}
            className="flex-1 py-3 bg-gray-800 text-gray-300 hover:bg-gray-700 rounded-lg font-medium transition-colors">
            Cancel
          </button>
          <button
            onClick={handleSend}
            disabled={isSending || !selectedTemplateId || !selectedRecipientId}
            className="flex-1 py-3 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-500 hover:to-indigo-500 text-white rounded-lg font-bold shadow-lg disabled:opacity-50 disabled:cursor-not-allowed transition-all">
            {isSending ? "Confirm & Send" : "Confirm & Send"}
          </button>
        </div>
      </div>
    </div>
  );
};


// ==========================================
// FILE: frontend_harness/src/components/FileUploader.tsx 
// ==========================================
import React, { useState } from "react";
import axios from "axios";
import { uploadDocument } from "../apiClient";
import type { Document } from "../types"; // Fix: Type-only import

interface FileUploaderProps {
  relatedEntityId: string;
  relatedEntityType: "Event" | "Vendor" | "Contact" | "Task";
  onUploadSuccess?: (document: Document) => void;
}

// Hardcoded categories for The Librarian
const DOCUMENT_CATEGORIES = [
  "General",
  "Invoice",
  "Contract",
  "Rider",
  "Marketing",
  "Legal",
];

export const FileUploader: React.FC<FileUploaderProps> = ({
  relatedEntityId,
  relatedEntityType,
  onUploadSuccess,
}) => {
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [category, setCategory] = useState<string>("General"); // Default category

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files || e.target.files.length === 0) return;

    const file = e.target.files[0];
    await handleUpload(file);
  };

  const handleUpload = async (file: File) => {
    setIsUploading(true);
    setError(null);

    try {
      // Pass the selected category to the API
      const result = await uploadDocument(
        file,
        relatedEntityId,
        relatedEntityType,
        category
      );
      if (onUploadSuccess) {
        onUploadSuccess(result);
      }
    } catch (err) {
      console.error(err);

      let errorMessage = "Failed to upload file.";

      if (axios.isAxiosError(err) && err.response?.data) {
        const data = err.response.data;
        if (typeof data === "string") {
          errorMessage = data;
        } else if (typeof data === "object") {
          if (data.message) {
            errorMessage = data.message;
            if (data.details) errorMessage += ` (${data.details})`;
          } else if (data.title) {
            errorMessage = data.title;
          } else if (data.errors) {
            errorMessage = Object.values(data.errors).flat().join(", ");
          }
        }
      } else if (err instanceof Error) {
        errorMessage = err.message;
      }

      setError(errorMessage);
    } finally {
      setIsUploading(false);
    }
  };

  return (
    <div className="p-4 border-2 border-dashed border-gray-300 rounded-lg bg-gray-50 text-center hover:bg-gray-100 transition-colors">
      {/* Category Selector */}
      <div
        style={{
          marginBottom: "1rem",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          gap: "10px",
        }}>
        <label style={{ fontSize: "0.9rem", fontWeight: "600", color: "#555" }}>
          Document Type:
        </label>
        <select
          value={category}
          onChange={(e) => setCategory(e.target.value)}
          disabled={isUploading}
          style={{
            padding: "5px 10px",
            borderRadius: "4px",
            border: "1px solid #ccc",
            fontSize: "0.9rem",
            backgroundColor: "white",
            color: "#333",
          }}>
          {DOCUMENT_CATEGORIES.map((cat) => (
            <option key={cat} value={cat}>
              {cat}
            </option>
          ))}
        </select>
      </div>

      <input
        type="file"
        id={`file-upload-${relatedEntityId}`}
        className="hidden"
        onChange={handleFileChange}
        disabled={isUploading}
      />
      <label
        htmlFor={`file-upload-${relatedEntityId}`}
        className="cursor-pointer flex flex-col items-center justify-center">
        {isUploading ? (
          <span className="text-blue-600 font-semibold">Uploading...</span>
        ) : (
          <>
            <span className="text-gray-700 font-medium">
              Click to Upload Document
            </span>
            <span className="text-xs text-gray-500 mt-1">
              (PDF, DOCX, PNG, JPG)
            </span>
          </>
        )}
      </label>

      {error && (
        <div
          style={{
            color: "red",
            marginTop: "10px",
            fontSize: "0.85rem",
            maxHeight: "100px",
            overflowY: "auto",
            textAlign: "left",
            padding: "5px",
            background: "#fff0f0",
            border: "1px solid #ffcccc",
          }}>
          <strong>Error:</strong> {error}
        </div>
      )}
    </div>
  );
};


// ==========================================
// FILE: frontend_harness/src/components/DocumentsSection.tsx 
// ==========================================
import React, { useEffect, useState } from "react";
import { apiClient, deleteDocument } from "../apiClient";
import type { Document } from "../types";
import { FileUploader } from "./FileUploader";

interface DocumentsSectionProps {
  entityId: string;
  entityType: "Event" | "Vendor" | "Contact" | "Task"; // Reusable!
}

export const DocumentsSection: React.FC<DocumentsSectionProps> = ({
  entityId,
  entityType,
}) => {
  const [documents, setDocuments] = useState<Document[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchDocuments = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<Document[]>("/api/documents", {
          params: { relatedEntityId: entityId, relatedEntityType: entityType },
        });
        setDocuments(response.data);
      } catch (err) {
        console.error("Failed to load documents", err);
      } finally {
        setLoading(false);
      }
    };

    if (entityId) fetchDocuments();
  }, [entityId, entityType]);

  const handleUploadSuccess = (newDoc: Document) => {
    setDocuments((prev) => [newDoc, ...prev]);
  };

  const handleDeleteDocument = async (id: number) => {
    if (
      !window.confirm(
        "Are you sure you want to permanently delete this document?"
      )
    )
      return;

    try {
      await deleteDocument(id);
      setDocuments((prev) => prev.filter((doc) => doc.id !== id));
    } catch (err) {
      console.error("Failed to delete document", err);
      alert("Failed to delete document.");
    }
  };

  const formatFileSize = (bytes: number) => {
    if (bytes === 0) return "0 Bytes";
    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  };

  // Helper for Category Badges
  const getCategoryColor = (cat: string) => {
    switch (cat) {
      case "Invoice":
        return "#e0f2fe"; // Light Blue
      case "Contract":
        return "#fce7f3"; // Pink
      case "Legal":
        return "#fee2e2"; // Red
      case "Marketing":
        return "#dcfce7"; // Green
      default:
        return "#f3f4f6"; // Grey
    }
  };

  const getCategoryTextColor = (cat: string) => {
    switch (cat) {
      case "Invoice":
        return "#0369a1";
      case "Contract":
        return "#be185d";
      case "Legal":
        return "#b91c1c";
      case "Marketing":
        return "#15803d";
      default:
        return "#374151";
    }
  };

  return (
    <div
      style={{
        border: "1px solid #ddd",
        borderRadius: "8px",
        padding: "1.5rem",
        marginTop: "2rem",
        backgroundColor: "#ffffff",
        color: "#333",
        boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
      }}>
      <h3
        style={{
          borderBottom: "2px solid #eee",
          paddingBottom: "0.5rem",
          marginBottom: "1rem",
          color: "#222",
        }}>
        {entityType} Documents
      </h3>

      <div style={{ marginBottom: "1.5rem" }}>
        <FileUploader
          relatedEntityId={entityId}
          relatedEntityType={entityType}
          onUploadSuccess={handleUploadSuccess}
        />
      </div>

      {loading ? (
        <p style={{ color: "#666" }}>Loading documents...</p>
      ) : documents.length === 0 ? (
        <div
          style={{
            textAlign: "center",
            padding: "2rem",
            backgroundColor: "#f9fafb",
            borderRadius: "6px",
            border: "1px dashed #ccc",
            color: "#666",
          }}>
          No documents archived.
        </div>
      ) : (
        <div style={{ overflowX: "auto" }}>
          <table
            style={{
              width: "100%",
              borderCollapse: "collapse",
              fontSize: "0.95rem",
            }}>
            <thead>
              <tr
                style={{
                  backgroundColor: "#374151",
                  color: "#ffffff",
                  textAlign: "left",
                }}>
                <th style={{ padding: "12px", borderTopLeftRadius: "6px" }}>
                  File Name
                </th>
                <th style={{ padding: "12px" }}>Category</th> {/* NEW COLUMN */}
                <th style={{ padding: "12px" }}>Size</th>
                <th style={{ padding: "12px" }}>Uploaded</th>
                <th style={{ padding: "12px", borderTopRightRadius: "6px" }}>
                  Action
                </th>
              </tr>
            </thead>
            <tbody>
              {documents.map((doc, index) => (
                <tr
                  key={doc.id}
                  style={{
                    borderBottom: "1px solid #eee",
                    backgroundColor: index % 2 === 0 ? "#fff" : "#f8f9fa",
                  }}>
                  <td
                    style={{
                      padding: "12px",
                      color: "#333",
                      fontWeight: "500",
                    }}>
                    {doc.fileName}
                  </td>
                  <td style={{ padding: "12px" }}>
                    <span
                      style={{
                        backgroundColor: getCategoryColor(doc.category),
                        color: getCategoryTextColor(doc.category),
                        padding: "4px 8px",
                        borderRadius: "12px",
                        fontSize: "0.8rem",
                        fontWeight: "600",
                      }}>
                      {doc.category || "General"}
                    </span>
                  </td>
                  <td style={{ padding: "12px", color: "#555" }}>
                    {formatFileSize(doc.size)}
                  </td>
                  <td style={{ padding: "12px", color: "#555" }}>
                    {new Date(doc.uploadedAt).toLocaleDateString()}
                  </td>
                  <td style={{ padding: "12px" }}>
                    <a
                      href={`http://localhost:5179${doc.url}`}
                      target="_blank"
                      rel="noreferrer"
                      style={{
                        color: "#2563eb",
                        fontWeight: "600",
                        textDecoration: "none",
                        marginRight: "10px",
                      }}>
                      Download
                    </a>
                    <button
                      onClick={() => handleDeleteDocument(doc.id)}
                      style={{
                        color: "#dc2626",
                        fontWeight: "600",
                        background: "none",
                        border: "none",
                        cursor: "pointer",
                      }}>
                      Delete
                    </button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );
};


// ==========================================
// FILE: frontend_harness/src/components/VendorsPage.tsx 
// ==========================================
// FILE: frontend_harness/src/components/VendorsPage.tsx

import React, { useEffect, useState, useCallback, useRef } from "react";
import { apiClient } from "../apiClient";
import type { VendorDto, Guid } from "../types";
import axios from "axios";
import { useSelectionContext } from "../context/useSelectionContext";
import { RelatedTasks, RelatedNotes } from "./RelatedTables";
import VendorEventsTable from "./VendorEventsTable";
import { DocumentsSection } from "./DocumentsSection"; // NEW: The Reusable Component

type VendorFormData = Omit<VendorDto, "id">;
type ValidationErrors = { [key: string]: string[] };

const initialFormState: VendorFormData = {
  name: "",
  phoneNumber: null,
  email: null,
  serviceType: "Other",
  attributes: null, // NEW: Include attributes
};

function VendorsPage() {
  const [vendors, setVendors] = useState<VendorDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const { selectedVendorId, setSelectedVendorId } = useSelectionContext();

  const selectedVendorIdRef = useRef(selectedVendorId);
  useEffect(() => {
    selectedVendorIdRef.current = selectedVendorId;
  }, [selectedVendorId]);

  const [formData, setFormData] =
    useState<Partial<VendorDto>>(initialFormState);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<ValidationErrors>(
    {}
  );

  // --- NEW: Dynamic Attribute State ---
  const [dynamicFields, setDynamicFields] = useState<{
    Capacity?: number | string;
    Genre?: string;
  }>({});

  const isEditing = editingId !== null;
  const selectedVendor = vendors.find((v) => v.id === selectedVendorId);

  // Function to initialize dynamic fields from the current formData.attributes
  const initializeDynamicFields = useCallback(
    (attributesString: string | null) => {
      if (!attributesString) {
        setDynamicFields({});
        return;
      }
      try {
        const parsed = JSON.parse(attributesString);
        // Set the dynamic fields, ensuring Capacity is handled as a number/string
        setDynamicFields({
          Capacity: parsed.Capacity || "",
          Genre: parsed.Genre || "",
        });
      } catch (e) {
        console.error("Failed to parse vendor attributes JSON:", e);
        setDynamicFields({});
      }
    },
    []
  );

  const fetchVendors = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiClient.get<VendorDto[]>("/api/vendors");
      setVendors(response.data);
      return response.data;
    } catch (err: unknown) {
      console.error(err);
      setError("Failed to fetch vendors.");
      return [];
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    let mounted = true;

    fetchVendors().then((data) => {
      if (mounted && data && data.length > 0 && !selectedVendorIdRef.current) {
        setSelectedVendorId(data[0].id);
      }
    });

    return () => {
      mounted = false;
      setSelectedVendorId(null);
    };
  }, [fetchVendors, setSelectedVendorId]);

  const handleDelete = async (id: string) => {
    if (!window.confirm("Are you sure you want to delete this vendor?")) return;
    try {
      await apiClient.delete(`/api/vendors/${id}`);
      if (selectedVendorId === id) {
        setSelectedVendorId(null);
      }
      await fetchVendors();
    } catch (err) {
      console.error(err);
      alert("Failed to delete vendor.");
    }
  };

  const handleEdit = (vendor: VendorDto) => {
    setEditingId(vendor.id);
    setFormData(vendor);
    initializeDynamicFields(vendor.attributes); // Initialize dynamic fields when editing
    setValidationErrors({});
    window.scrollTo(0, 0);
  };

  const handleCancel = () => {
    setEditingId(null);
    setFormData(initialFormState);
    setDynamicFields({}); // Clear dynamic fields
    setValidationErrors({});
  };

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>
  ) => {
    const { name, value } = e.target;
    // When ServiceType changes, reset the dynamic fields state
    if (name === "serviceType") {
      setDynamicFields({});
    }

    setFormData((prev) => ({
      ...prev,
      [name]: value === "" ? null : value,
    }));
  };

  // NEW: Handle changes for dynamic fields separately
  const handleDynamicChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setDynamicFields((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  const getAttributesJson = () => {
    const cleanFields = Object.entries(dynamicFields)
      .filter(([, value]) => value !== null && value !== "" && value !== 0)
      .reduce((acc, [key, value]) => {
        // Attempt to parse number fields back to number types for cleaner JSON
        if (
          key === "Capacity" &&
          typeof value === "string" &&
          !isNaN(Number(value))
        ) {
          acc[key] = Number(value);
        } else {
          acc[key] = value;
        }
        return acc;
      }, {} as Record<string, string | number>);

    if (Object.keys(cleanFields).length === 0) {
      return null;
    }
    return JSON.stringify(cleanFields);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setValidationErrors({});

    // --- PHASE 27: Inject serialized attributes into payload ---
    const attributesJson = getAttributesJson();

    const payload = {
      ...formData,
      name: formData.name ?? "",
      serviceType: formData.serviceType ?? "Other",
      attributes: attributesJson, // INJECT THE JSON STRING
    };
    // -------------------------------------------------------------

    const promise = isEditing
      ? apiClient.put(`/api/vendors/${editingId}`, payload)
      : apiClient.post("/api/vendors", payload);

    try {
      await promise;
      handleCancel();
      await fetchVendors();
    } catch (err: unknown) {
      if (axios.isAxiosError(err) && err.response?.status === 400) {
        setValidationErrors(
          err.response.data.errors || { General: ["Validation Error"] }
        );
      } else {
        console.error(err);
        alert("An unexpected error occurred.");
      }
    }
  };

  if (error) return <p style={{ color: "red" }}>{error}</p>;

  // --- NEW: Dynamic Field Renderer ---
  const renderDynamicFields = (serviceType: string | null | undefined) => {
    if (serviceType?.toLowerCase() === "venue") {
      return (
        <div style={{ marginBottom: "0.5rem" }}>
          <label>Venue Capacity: </label>
          <input
            name="Capacity"
            type="number"
            value={dynamicFields.Capacity ?? ""}
            onChange={handleDynamicChange}
            placeholder="Max Capacity (e.g., 500)"
            style={{
              width: "100%",
              padding: "8px",
              backgroundColor: "#333",
              color: "white",
              border: "1px solid #555",
            }}
          />
        </div>
      );
    }
    if (serviceType?.toLowerCase() === "entertainment") {
      return (
        <div style={{ marginBottom: "0.5rem" }}>
          <label>Artist Genre: </label>
          <input
            name="Genre"
            type="text"
            value={dynamicFields.Genre ?? ""}
            onChange={handleDynamicChange}
            placeholder="e.g., Jazz, EDM, Acoustic"
            style={{
              width: "100%",
              padding: "8px",
              backgroundColor: "#333",
              color: "white",
              border: "1px solid #555",
            }}
          />
        </div>
      );
    }
    return null;
  };

  const renderVendorListPanel = () => (
    <div
      style={{
        flex: "0 0 350px",
        padding: "1rem",
        borderRight: "1px solid #555",
        overflowY: "auto",
      }}>
      <h2>Vendors List</h2>
      <button
        onClick={() => {
          setEditingId(null);
          setFormData(initialFormState);
          setDynamicFields({}); // Ensure state is reset
          setSelectedVendorId(null);
        }}
        style={{ marginBottom: "1rem", padding: "10px" }}>
        + Add New Vendor
      </button>

      {loading ? (
        <p>Loading Vendors...</p>
      ) : (
        <ul style={{ listStyle: "none", padding: 0 }}>
          {vendors.map((vendor) => (
            <li
              key={vendor.id}
              onClick={() => setSelectedVendorId(vendor.id as Guid)}
              style={{
                padding: "10px",
                marginBottom: "5px",
                cursor: "pointer",
                border: "1px solid #555",
                backgroundColor:
                  vendor.id === selectedVendorId ? "#444" : "#2a2a2a",
                borderRadius: "4px",
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                color: "white",
              }}>
              <div>
                <strong>{vendor.name}</strong> <br />
                <span style={{ fontSize: "0.8rem", color: "#ccc" }}>
                  {vendor.serviceType}
                  {/* NEW: Display a dynamic attribute if present */}
                  {vendor.attributes &&
                    (() => {
                      try {
                        const attrs = JSON.parse(vendor.attributes);
                        if (attrs.Capacity)
                          return ` | Capacity: ${attrs.Capacity}`;
                        if (attrs.Genre) return ` | Genre: ${attrs.Genre}`;
                        return null;
                      } catch {
                        return null; // Ignore invalid JSON
                      }
                    })()}
                </span>
              </div>
              <div style={{ fontSize: "0.8rem" }}>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    handleEdit(vendor);
                  }}
                  style={{
                    color: "#64b5f6",
                    marginRight: "5px",
                    padding: "2px 5px",
                    background: "transparent",
                    border: "none",
                    cursor: "pointer",
                  }}>
                  Edit
                </button>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    handleDelete(vendor.id as Guid);
                  }}
                  style={{
                    color: "#ef5350",
                    padding: "2px 5px",
                    background: "transparent",
                    border: "none",
                    cursor: "pointer",
                  }}>
                  Delete
                </button>
              </div>
            </li>
          ))}
        </ul>
      )}
    </div>
  );

  const renderVendorDashboard = () => {
    if (isEditing || !selectedVendorId) {
      return (
        <div style={{ flex: 1, padding: "20px", overflowY: "auto" }}>
          <div
            style={{
              padding: "1rem",
              border: "1px solid #555",
              width: "100%",
            }}>
            <h2>
              {isEditing
                ? `Edit Vendor: ${selectedVendor?.name}`
                : "Create New Vendor"}
            </h2>
            <form onSubmit={handleSubmit}>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Name: </label>
                <input
                  name="name"
                  value={formData.name ?? ""}
                  onChange={handleChange}
                  style={{
                    width: "100%",
                    padding: "8px",
                    backgroundColor: "#333",
                    color: "white",
                    border: "1px solid #555",
                  }}
                />
                {validationErrors.Name && (
                  <div style={{ color: "#ef5350" }}>
                    {validationErrors.Name[0]}
                  </div>
                )}
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Email: </label>
                <input
                  name="email"
                  type="email"
                  value={formData.email ?? ""}
                  onChange={handleChange}
                  style={{
                    width: "100%",
                    padding: "8px",
                    backgroundColor: "#333",
                    color: "white",
                    border: "1px solid #555",
                  }}
                />
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Phone Number: </label>
                <input
                  name="phoneNumber"
                  value={formData.phoneNumber ?? ""}
                  onChange={handleChange}
                  style={{
                    width: "100%",
                    padding: "8px",
                    backgroundColor: "#333",
                    color: "white",
                    border: "1px solid #555",
                  }}
                />
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Service Type: </label>
                <select
                  name="serviceType"
                  value={formData.serviceType ?? "Other"}
                  onChange={handleChange}
                  style={{
                    width: "100%",
                    padding: "8px",
                    backgroundColor: "#333",
                    color: "white",
                    border: "1px solid #555",
                  }}>
                  {/* NOTE: Added Entertainment option as a requirement example */}
                  <option value="Catering">Catering</option>
                  <option value="Security">Security</option>
                  <option value="Venue">Venue</option>
                  <option value="Entertainment">Entertainment</option>
                  <option value="Florist">Florist</option>
                  <option value="Photography">Photography</option>
                  <option value="Videography">Videography</option>
                  <option value="Other">Other</option>
                </select>
              </div>

              {/* --- PHASE 27: Dynamic Attribute Fields RENDER HERE --- */}
              {renderDynamicFields(formData.serviceType)}

              {validationErrors.Attributes && (
                <div style={{ color: "#ef5350", marginTop: "0.5rem" }}>
                  {/* Display validation error for the JSON field */}
                  {validationErrors.Attributes[0]}
                </div>
              )}
              {/* -------------------------------------------------------- */}

              <button
                type="submit"
                style={{
                  marginTop: "10px",
                  padding: "10px 20px",
                  cursor: "pointer",
                }}>
                {isEditing ? "Save Changes" : "Create"}
              </button>
              {isEditing && (
                <button
                  type="button"
                  onClick={handleCancel}
                  style={{
                    marginLeft: "0.5rem",
                    marginTop: "10px",
                    padding: "10px 20px",
                    cursor: "pointer",
                  }}>
                  Cancel
                </button>
              )}
              {validationErrors.General && (
                <div style={{ color: "#ef5350", marginTop: "1rem" }}>
                  {validationErrors.General[0]}
                </div>
              )}
            </form>
          </div>
        </div>
      );
    }

    const vendorIdString = selectedVendorId as string;

    // --- PHASE 27: Dashboard View ---
    const parsedAttributes = selectedVendor?.attributes
      ? JSON.parse(selectedVendor.attributes)
      : {};

    const attributeDisplay = Object.entries(parsedAttributes).map(
      ([key, value]) => (
        <p key={key}>
          <strong>{key}:</strong> {value as string}
        </p>
      )
    );

    return (
      <div style={{ flex: 1, padding: "20px", overflowY: "auto" }}>
        <h1>Vendor Command Center: {selectedVendor?.name}</h1>
        <div
          style={{
            marginBottom: "20px",
            padding: "15px",
            border: "1px solid #555",
            borderRadius: "5px",
            width: "100%",
          }}>
          <h3>Details</h3>
          <p>
            <strong>ID:</strong> {selectedVendor?.id}
          </p>
          <p>
            <strong>Type:</strong> {selectedVendor?.serviceType}
          </p>
          <p>
            <strong>Contact Info:</strong> {selectedVendor?.phoneNumber} /{" "}
            {selectedVendor?.email}
          </p>
          {/* NEW: Dynamic Attribute Display */}
          {attributeDisplay.length > 0 && (
            <div
              style={{
                marginTop: "10px",
                borderTop: "1px dashed #666",
                paddingTop: "10px",
              }}>
              <h4>Specific Attributes</h4>
              {attributeDisplay}
            </div>
          )}
        </div>

        <h2 style={{ marginTop: "30px" }}>Related Data</h2>

        {/* NEW: Reusable Documents Section for Vendors */}
        <DocumentsSection entityId={vendorIdString} entityType="Vendor" />

        <VendorEventsTable vendorId={vendorIdString as Guid} />
        <RelatedTasks vendorId={vendorIdString} />
        <RelatedNotes vendorId={vendorIdString} />
      </div>
    );
  };

  return (
    <div style={{ display: "flex", height: "100%", minHeight: "800px" }}>
      {renderVendorListPanel()}
      {renderVendorDashboard()}
    </div>
  );
}

export default VendorsPage;


// ==========================================
// FILE: frontend_harness/src/components/NotesPage.tsx 
// ==========================================
// FILE: frontend_harness/src/components/NotesPage.tsx

import { useState, useEffect, type FormEvent } from "react";
import { apiClient } from "../apiClient";
import { type NoteDto, type CreateNoteDto } from "../types";
import { AxiosError } from "axios";

// Define an explicit type for the data sent in the command,
// including the new lookup fields for clarity
type NoteCommandData = Omit<CreateNoteDto, "vendorName"> & {
  contactEmail?: string;
  eventName?: string;
  vendorName?: string; // This maps to the backend VendorName field in the command
  taskTitle?: string;
};

type UpdateNoteDto = Pick<NoteDto, "id" | "content">;

const NotesPage = () => {
  const [notes, setNotes] = useState<NoteDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Form state for creating a new note
  const initialNewNoteState: Partial<NoteCommandData> = {
    content: "",
    contactId: null,
    eventId: null,
    taskId: null,
    vendorId: null,
    // String lookup fields
    contactEmail: undefined,
    eventName: undefined,
    vendorName: undefined,
    taskTitle: undefined,
  };

  const [newNote, setNewNote] =
    useState<Partial<NoteCommandData>>(initialNewNoteState);

  // State for which note is being edited
  const [editingNote, setEditingNote] = useState<NoteDto | null>(null);

  // --- NEW: PHASE 29 Dynamic Linkage State ---
  const [entityTypeToLink, setEntityTypeToLink] = useState<
    "Contact" | "Event" | "Vendor" | "Task" | null
  >(null);
  const [linkValue, setLinkValue] = useState("");
  // ------------------------------------------

  const fetchNotes = async () => {
    try {
      setLoading(true);
      const response = await apiClient.get<NoteDto[]>("/api/notes");
      setNotes(response.data);
      setError(null);
    } catch (err) {
      setError("Failed to fetch notes.");
      console.error(err);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchNotes();
  }, []);

  // --- PHASE 29: Dynamic Linkage Handlers ---
  const handleEntityTypeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const type = e.target.value as
      | "Contact"
      | "Event"
      | "Vendor"
      | "Task"
      | "None";
    setEntityTypeToLink(type === "None" ? null : type);
    setLinkValue("");
    // Clear all previous link-related fields in newNote state
    setNewNote({
      ...newNote,
      contactId: null,
      eventId: null,
      taskId: null,
      vendorId: null,
      contactEmail: undefined,
      eventName: undefined,
      vendorName: undefined,
      taskTitle: undefined,
    });
  };

  const handleLinkValueChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setLinkValue(e.target.value);
  };

  const getLinkPlaceholder = () => {
    switch (entityTypeToLink) {
      case "Contact":
        return "Contact Email (e.g., jane@example.com)";
      case "Event":
        return "Event Name (e.g., Summer Gala 2026)";
      case "Vendor":
        return "Vendor Name (e.g., The Jazz Trio)";
      case "Task":
        return "Task Title (e.g., Book Venue)";
      default:
        return "Enter Name, Title, or Email";
    }
  };

  // --- PHASE 29: Payload Construction ---
  const constructCreatePayload = (): Partial<NoteCommandData> => {
    const payload: Partial<NoteCommandData> = {
      content: newNote.content,
    };

    if (entityTypeToLink === "Contact" && linkValue) {
      payload.contactEmail = linkValue;
    } else if (entityTypeToLink === "Event" && linkValue) {
      payload.eventName = linkValue;
    } else if (entityTypeToLink === "Vendor" && linkValue) {
      payload.vendorName = linkValue; // Maps to VendorName on backend command
    } else if (entityTypeToLink === "Task" && linkValue) {
      payload.taskTitle = linkValue;
    }
    // If IDs were manually put in (or if no dynamic link is selected,
    // they are sent as null/undefined, which is fine)

    return payload;
  };
  // ------------------------------------------

  const handleCreateSubmit = async (e: FormEvent) => {
    e.preventDefault();

    if (!newNote.content) {
      setError("Content is required.");
      return;
    }

    const payload = constructCreatePayload();

    try {
      // NOTE: We don't map string lookups to GUIDs on the FE. The FE only sends
      // the string values and the BE handler resolves them.
      const response = await apiClient.post<NoteDto>("/api/notes", payload);
      setNotes([response.data, ...notes]);

      setNewNote(initialNewNoteState); // Reset form
      setEntityTypeToLink(null);
      setLinkValue("");

      setError(null);
    } catch (err: unknown) {
      console.error(err);
      if (err instanceof AxiosError && err.response?.data?.errors) {
        // Find the 'Must Have At Least One Link' error and present it clearly
        const validationMessage = Object.values(err.response.data.errors)
          .flat()
          .join(", ");
        setError(
          validationMessage ||
            "Failed to create note. Ensure at least one ID is provided."
        );
      } else {
        setError("Failed to create note. Ensure at least one ID is provided.");
      }
    }
  };

  const handleUpdateSubmit = async (e: FormEvent) => {
    e.preventDefault();
    if (!editingNote) return;

    const updatePayload: UpdateNoteDto = {
      id: editingNote.id,
      content: editingNote.content,
    };
    try {
      await apiClient.put(`/api/notes/${editingNote.id}`, updatePayload);
      setNotes(notes.map((n) => (n.id === editingNote.id ? editingNote : n)));
      setEditingNote(null);
      setError(null);
    } catch (err: unknown) {
      console.error(err);
      setError("Failed to update note.");
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm("Are you sure you want to delete this note?")) {
      try {
        await apiClient.delete(`/api/notes/${id}`);
        setNotes(notes.filter((n) => n.id !== id));
        setError(null);
      } catch (err) {
        setError("Failed to delete note.");
        console.error(err);
      }
    }
  };

  // --- Render Logic ---

  if (loading) return <p>Loading notes...</p>;
  return (
    <div className="module-page">
      <h2>Notes Module</h2>
      {error && (
        <p className="error-message" style={{ color: "red" }}>
          {error}
        </p>
      )}

      {/* --- Create or Edit Form --- */}
      <form onSubmit={editingNote ? handleUpdateSubmit : handleCreateSubmit}>
        <h3>{editingNote ? "Edit Note" : "Create New Note"}</h3>
        <textarea
          placeholder="Note content..."
          value={editingNote ? editingNote.content : newNote.content}
          onChange={(e) =>
            editingNote
              ? setEditingNote({ ...editingNote, content: e.target.value })
              : setNewNote({ ...newNote, content: e.target.value })
          }
        />

        {/* --- Foreign Key Inputs (Dynamic Link for Create) --- */}
        {!editingNote && (
          <fieldset
            style={{
              border: "1px dashed #666",
              padding: "1rem",
              margin: "1rem 0",
            }}>
            <legend style={{ padding: "0 0.5rem" }}>
              Attach Note By ID or Lookup
            </legend>

            {/* Link Type Selector */}
            <div style={{ marginBottom: "0.5rem" }}>
              <label style={{ display: "block" }}>Link Type:</label>
              <select
                value={entityTypeToLink ?? "None"}
                onChange={handleEntityTypeChange}
                style={{ width: "100%", padding: "4px" }}>
                <option value="None">-- Select Entity Type --</option>
                <option value="Contact">Contact (by Email)</option>
                <option value="Event">Event (by Name)</option>
                <option value="Vendor">Vendor (by Name)</option>
                <option value="Task">Task (by Title)</option>
              </select>
            </div>

            {/* Lookup Value Input */}
            {entityTypeToLink && (
              <div style={{ marginBottom: "0.5rem" }}>
                <label style={{ display: "block" }}>Lookup Value:</label>
                <input
                  type={entityTypeToLink === "Contact" ? "email" : "text"}
                  value={linkValue}
                  onChange={handleLinkValueChange}
                  placeholder={getLinkPlaceholder()}
                  style={{ width: "100%" }}
                />
              </div>
            )}

            <p style={{ fontSize: "0.8rem", color: "#aaa", marginTop: "1rem" }}>
              *If you use the dropdown above, only the lookup value is sent. If
              you need to link by GUID, please use the Task/Vendor/Contact
              pages.
            </p>
          </fieldset>
        )}

        <button type="submit">
          {editingNote ? "Update Note" : "Create Note"}
        </button>
        {editingNote && (
          <button type="button" onClick={() => setEditingNote(null)}>
            Cancel Edit
          </button>
        )}
      </form>

      {/* --- Notes Table --- */}
      <h3>Existing Notes</h3>
      <table className="harness-table" style={{ width: "100%" }}>
        <thead>
          <tr>
            <th>ID</th>
            <th>Content</th>
            <th>Contact ID</th>
            <th>Event ID</th>
            <th>Task ID</th>
            <th>Vendor ID</th>
            <th>Vendor Name</th> {/* Granularity */}
            <th>Created At</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {notes.map((note) => (
            <tr key={note.id}>
              <td>{note.id.substring(0, 8)}...</td>
              <td>{note.content.substring(0, 50)}...</td>
              <td>
                {note.contactId
                  ? note.contactId.substring(0, 8) + "..."
                  : "N/A"}
              </td>
              <td>
                {note.eventId ? note.eventId.substring(0, 8) + "..." : "N/A"}
              </td>
              <td>
                {note.taskId ? note.taskId.substring(0, 8) + "..." : "N/A"}
              </td>
              <td>
                {note.vendorId ? note.vendorId.substring(0, 8) + "..." : "N/A"}
              </td>
              <td>{note.vendorName ?? "N/A"}</td>
              <td>{new Date(note.createdAt).toLocaleString()}</td>
              <td>
                <button
                  className="edit-button"
                  onClick={() => setEditingNote(note)}>
                  Edit
                </button>
                <button
                  className="delete-button"
                  onClick={() => handleDelete(note.id)}>
                  Delete
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

export default NotesPage;


// ==========================================
// FILE: frontend_harness/src/components/BudgetOverview.tsx 
// ==========================================
import type { EventFinancials } from "../types";

interface Props {
  data: EventFinancials;
  onEditBudget: () => void;
}

export default function BudgetOverview({ data, onEditBudget }: Props) {
  // Color Logic: Green < 80%, Yellow < 100%, Red >= 100%
  const getProgressColor = () => {
    if (data.burnRate >= 1) return "bg-red-600";
    if (data.burnRate > 0.8) return "bg-yellow-500";
    return "bg-emerald-500";
  };

  const percentage = Math.min(data.burnRate * 100, 100);

  return (
    <div className="p-6 rounded-xl shadow-sm border border-gray-600 bg-[#333] text-white mb-8">
      {/* PHASE 26 ADDITION: BUDGET LOCK STATUS BANNER */}
      {data.isLocked ? (
        <div className="bg-red-900/50 border border-red-700 p-3 rounded-lg flex items-center mb-6">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 20 20"
            fill="currentColor"
            className="w-5 h-5 text-red-400 mr-3">
            <path
              fillRule="evenodd"
              d="M10 1a4.5 4.5 0 0 0-4.5 4.5V9H5a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2h-.5V5.5A4.5 4.5 0 0 0 10 1Zm3 8V5.5a3 3 0 1 0-6 0V9h6Z"
              clipRule="evenodd"
            />
          </svg>
          <span className="text-sm font-medium text-red-300">
            BUDGET LOCKED: Contract Signed. This budget cannot be edited.
          </span>
        </div>
      ) : (
        <div className="bg-emerald-900/50 border border-emerald-700 p-3 rounded-lg flex items-center mb-6">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 20 20"
            fill="currentColor"
            className="w-5 h-5 text-emerald-400 mr-3">
            <path d="M10 1a.75.75 0 0 1 .75.75V3a.75.75 0 1 1-1.5 0V1.75A.75.75 0 0 1 10 1ZM5.5 5.5a.75.75 0 0 0-1.5 0v2.75a.75.75 0 0 0 1.5 0V5.5ZM16 8.25a.75.75 0 0 1 1.5 0v-2.5a.75.75 0 0 1-1.5 0v2.5ZM5.5 12.5a.75.75 0 0 0-1.5 0v2.75a.75.75 0 0 0 1.5 0v-2.75ZM16 14.75a.75.75 0 0 1 1.5 0v-2.5a.75.75 0 0 1-1.5 0v2.5ZM10 6a4 4 0 0 1 4 4v.75c0 1.05.57 2.053 1.5 2.5a.75.75 0 0 1-.6 1.34c-1.288-.574-2.15-1.782-2.3-3.14h-1.3c-.15 1.358-1.012 2.566-2.3 3.14a.75.75 0 0 1-.6-1.34c.93-.447 1.5-1.45 1.5-2.5V10a4 4 0 0 1 4-4Z" />
          </svg>
          <span className="text-sm font-medium text-emerald-300">
            BUDGET UNLOCKED: Ready for updates.
          </span>
        </div>
      )}

      <div className="flex justify-between items-start mb-6">
        <div>
          <h3 className="text-xl font-bold text-white">Budget Overview</h3>
          <p className="text-sm text-gray-400 mt-1">{data.currency} Ledger</p>
        </div>
        <button
          onClick={onEditBudget}
          disabled={data.isLocked} // DISABLES BUTTON WHEN LOCKED
          className={`px-3 py-1 text-sm rounded transition-colors ${
            data.isLocked
              ? "bg-gray-800 text-gray-500 cursor-not-allowed border border-gray-700"
              : "bg-gray-700 hover:bg-gray-600 text-white border border-gray-500"
          }`}>
          {data.isLocked ? "Budget Locked" : "Edit Budget"}
        </button>
      </div>

      {/* Stat Cards */}
      <div className="grid grid-cols-3 gap-6 mb-8">
        <div className="p-4 bg-[#444] rounded-lg border border-gray-600">
          <p className="text-xs text-gray-400 uppercase tracking-wider mb-1">
            Total Budget
          </p>
          <p className="text-2xl font-bold text-white">
            ${data.budgetTotal.toLocaleString()}
          </p>
        </div>
        <div className="p-4 bg-[#444] rounded-lg border border-gray-600">
          <p className="text-xs text-gray-400 uppercase tracking-wider mb-1">
            Spent
          </p>
          <p className="text-2xl font-bold text-white">
            ${data.totalSpent.toLocaleString()}
          </p>
        </div>
        <div className="p-4 bg-[#444] rounded-lg border border-gray-600">
          <p className="text-xs text-gray-400 uppercase tracking-wider mb-1">
            Remaining
          </p>
          <p
            className={`text-2xl font-bold ${
              data.remainingBudget < 0 ? "text-red-400" : "text-emerald-400"
            }`}>
            ${data.remainingBudget.toLocaleString()}
          </p>
        </div>
      </div>

      {/* Progress Bar Section */}
      <div className="relative pt-1">
        <div className="flex mb-2 items-center justify-between text-sm">
          <span className="font-semibold uppercase tracking-wide text-gray-300">
            Burn Rate
          </span>
          <span className="font-bold text-white">
            {Math.round(data.burnRate * 100)}%
          </span>
        </div>
        <div className="overflow-hidden h-3 mb-4 text-xs flex rounded-full bg-gray-700 border border-gray-600">
          <div
            style={{ width: `${percentage}%` }}
            className={`shadow-none flex flex-col text-center whitespace-nowrap text-white justify-center ${getProgressColor()} transition-all duration-500`}></div>
        </div>
      </div>

      {data.notes && (
        <div className="mt-4 text-sm text-gray-400 italic border-l-4 border-gray-500 pl-3">
          "{data.notes}"
        </div>
      )}
    </div>
  );
}


// ==========================================
// FILE: frontend_harness/src/components/TasksPage.tsx 
// ==========================================
// FILE: frontend_harness/src/components/TasksPage.tsx (COMPLETE FILE)

import { useEffect, useState } from "react";
import { apiClient } from "../apiClient";
import type { TaskDto } from "../types";
import axios from "axios";

// Define an explicit type for the data sent in the command,
// including the new lookup fields for clarity
type TaskCommandData = Omit<TaskDto, "id" | "createdAt" | "vendorName"> & {
  contactEmail?: string;
  eventName?: string;
  vendorName?: string; // This maps to the backend VendorName field in the command
};
type ValidationErrors = { [key: string]: string[] };

function TasksPage() {
  const [tasks, setTasks] = useState<TaskDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const initialFormState: Partial<TaskCommandData> = {
    title: "",
    description: null,
    status: "NotStarted", // Default enum string
    priority: "Medium", // Default enum string
    dueDate: null,
    // Original GUID fields (cleared for the form but used in DTO)
    contactId: null,
    eventId: null,
    vendorId: null,
    // String lookup fields
    contactEmail: undefined,
    eventName: undefined,
    vendorName: undefined,
  };

  const [formData, setFormData] =
    useState<Partial<TaskCommandData>>(initialFormState);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<ValidationErrors>(
    {}
  );

  // --- NEW: PHASE 29 Dynamic Linkage State ---
  const [entityTypeToLink, setEntityTypeToLink] = useState<
    "Contact" | "Event" | "Vendor" | null
  >(null);
  const [linkValue, setLinkValue] = useState("");
  // ------------------------------------------

  const isEditing = editingId !== null;

  const fetchTasks = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiClient.get<TaskDto[]>("/api/tasks");
      setTasks(response.data);
    } catch (err: unknown) {
      console.error(err);
      setError("Failed to fetch tasks.");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchTasks();
  }, []);

  const handleDelete = async (id: string) => {
    if (!window.confirm("Are you sure you want to delete this task?")) return;
    try {
      await apiClient.delete(`/api/tasks/${id}`);
      await fetchTasks();
    } catch (err) {
      console.error(err);
      alert("Failed to delete task.");
    }
  };

  const handleEdit = (task: TaskDto) => {
    setEditingId(task.id);

    // Clear dynamic link state when editing, as the fields are GUID-based on update
    setEntityTypeToLink(null);
    setLinkValue("");

    // Format date for date input
    setFormData({
      ...task,
      dueDate: task.dueDate ? task.dueDate.slice(0, 10) : null,
      vendorId: task.vendorId ?? null,
      contactId: task.contactId ?? null,
      eventId: task.eventId ?? null,
      // Clear string lookup fields when editing an existing task by ID
      contactEmail: undefined,
      eventName: undefined,
      vendorName: undefined,
    });
    setValidationErrors({});
    window.scrollTo(0, 0);
  };

  const handleCancel = () => {
    setEditingId(null);
    setFormData(initialFormState);
    setEntityTypeToLink(null); // Reset link state
    setLinkValue(""); // Reset link value
    setValidationErrors({});
  };

  const handleChange = (
    e: React.ChangeEvent<
      HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement
    >
  ) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value === "" ? null : value,
    }));
  };

  // --- PHASE 29: Dynamic Linkage Handler ---
  const handleEntityTypeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const type = e.target.value as "Contact" | "Event" | "Vendor" | "None";
    setEntityTypeToLink(type === "None" ? null : type);
    setLinkValue("");
    // Clear all previous link-related fields in formData to prevent conflicts
    setFormData({
      ...formData,
      contactId: null,
      eventId: null,
      vendorId: null,
      contactEmail: undefined,
      eventName: undefined,
      vendorName: undefined,
    });
  };

  const handleLinkValueChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setLinkValue(e.target.value);
  };

  // --- PHASE 29: Payload Construction ---
  const constructPayload = (
    baseData: Partial<TaskCommandData>
  ): TaskCommandData => {
    const payload: Partial<TaskCommandData> = {
      ...baseData,
      description: baseData.description ?? null,
      dueDate: baseData.dueDate ?? null,
    };

    // If we are editing, we submit the GUIDs (contactId, eventId, etc.)
    // already present in formData, and string fields are undefined.
    if (isEditing) {
      return payload as TaskCommandData;
    }

    // If creating, we inject the dynamic linkage values into the string lookup fields.
    // GUID fields are null, string fields hold the lookup value.
    if (entityTypeToLink === "Contact" && linkValue) {
      payload.contactEmail = linkValue;
      payload.contactId = null; // Ensure ID is null
    } else if (entityTypeToLink === "Event" && linkValue) {
      payload.eventName = linkValue;
      payload.eventId = null; // Ensure ID is null
    } else if (entityTypeToLink === "Vendor" && linkValue) {
      payload.vendorName = linkValue; // Maps to VendorName on backend command
      payload.vendorId = null; // Ensure ID is null
    }

    return payload as TaskCommandData;
  };
  // ------------------------------------------

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setValidationErrors({});

    const payload = constructPayload(formData);

    const promise = isEditing
      ? apiClient.put(`/api/tasks/${editingId}`, payload)
      : apiClient.post("/api/tasks", payload);

    try {
      await promise;
      handleCancel();
      await fetchTasks();
    } catch (err: unknown) {
      if (axios.isAxiosError(err) && err.response?.status === 400) {
        setValidationErrors(
          err.response.data.errors || { General: ["Validation Error"] }
        );
      } else {
        console.error(err);
        alert("An unexpected error occurred.");
      }
    }
  };

  if (error) return <p style={{ color: "red" }}>{error}</p>;

  // Helper to determine the placeholder text
  const getLinkPlaceholder = () => {
    switch (entityTypeToLink) {
      case "Contact":
        return "Contact Email (e.g., jane@example.com)";
      case "Event":
        return "Event Name (e.g., Summer Gala 2026)";
      case "Vendor":
        return "Vendor Name (e.g., The Jazz Trio)";
      default:
        return "Enter ID, Name, or Email";
    }
  };

  return (
    <div>
      <div
        style={{
          marginBottom: "2rem",
          padding: "1rem",
          border: "1px solid #555",
        }}>
        <h2>{isEditing ? "Edit Task" : "Create Task"}</h2>
        <form onSubmit={handleSubmit}>
          {/* Form fields */}
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Title: </label>
            <input
              name="title"
              value={formData.title ?? ""}
              onChange={handleChange}
            />
            {validationErrors.Title && (
              <div style={{ color: "red" }}>{validationErrors.Title[0]}</div>
            )}
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Description: </label>
            <textarea
              name="description"
              value={formData.description ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Due Date: </label>
            <input
              name="dueDate"
              type="date"
              value={formData.dueDate ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Status: </label>
            <select
              name="status"
              value={formData.status ?? "NotStarted"}
              onChange={handleChange}>
              <option value="NotStarted">Not Started</option>
              <option value="InProgress">In Progress</option>
              <option value="Completed">Completed</option>
            </select>
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Priority: </label>
            <select
              name="priority"
              value={formData.priority ?? "Medium"}
              onChange={handleChange}>
              <option value="Low">Low</option>
              <option value="Medium">Medium</option>
              <option value="High">High</option>
            </select>
          </div>

          {/* --- PHASE 29: DYNAMIC LINKING SECTION --- */}
          {!isEditing && (
            <div
              style={{
                margin: "1rem 0",
                padding: "1rem",
                border: "1px dashed #666",
                borderRadius: "4px",
              }}>
              <h4 style={{ marginTop: 0 }}>
                Link Task To: (Name or Email Lookup)
              </h4>
              <div style={{ marginBottom: "0.5rem" }}>
                <label style={{ display: "block" }}>Link Type:</label>
                <select
                  value={entityTypeToLink ?? "None"}
                  onChange={handleEntityTypeChange}
                  style={{ width: "100%", padding: "4px" }}>
                  <option value="None">-- Select Entity Type --</option>
                  <option value="Contact">Contact (by Email)</option>
                  <option value="Event">Event (by Name)</option>
                  <option value="Vendor">Vendor (by Name)</option>
                </select>
              </div>
              {entityTypeToLink && (
                <div style={{ marginBottom: "0.5rem" }}>
                  <label style={{ display: "block" }}>Lookup Value:</label>
                  <input
                    type={entityTypeToLink === "Contact" ? "email" : "text"}
                    value={linkValue}
                    onChange={handleLinkValueChange}
                    placeholder={getLinkPlaceholder()}
                    style={{ width: "100%" }}
                  />
                </div>
              )}
            </div>
          )}

          {/* --- LEGACY GUID INPUTS (Hidden on Create, Used on Edit) --- */}
          {/* On Edit mode, we submit the existing GUIDs. */}
          {/* NOTE: We only display the GUIDs on edit if you need to change the parent via GUID */}
          {isEditing && (
            <>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Contact ID (Optional): </label>
                <input
                  name="contactId"
                  value={formData.contactId ?? ""}
                  onChange={handleChange}
                />
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Event ID (Optional): </label>
                <input
                  name="eventId"
                  value={formData.eventId ?? ""}
                  onChange={handleChange}
                />
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Vendor ID (Optional): </label>
                <input
                  name="vendorId"
                  value={formData.vendorId ?? ""}
                  onChange={handleChange}
                />
              </div>
            </>
          )}
          {/* ---------------------------------------------------- */}

          {validationErrors.General && (
            <div style={{ color: "red", marginTop: "1rem" }}>
              {validationErrors.General[0]}
            </div>
          )}

          <button type="submit">{isEditing ? "Save Changes" : "Create"}</button>
          {isEditing && (
            <button
              type="button"
              onClick={handleCancel}
              style={{ marginLeft: "0.5rem" }}>
              Cancel
            </button>
          )}
        </form>
      </div>

      <h2>Tasks List</h2>
      {loading ? (
        <p>Loading Tasks...</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Title</th>
              <th>Status</th>
              <th>Priority</th>
              <th>Due Date</th>
              <th>Vendor</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {tasks.map((task) => (
              <tr key={task.id}>
                <td>{task.id}</td>
                <td>{task.title}</td>
                <td>{task.status}</td>
                <td>{task.priority}</td>
                <td>
                  {task.dueDate
                    ? new Date(task.dueDate).toLocaleDateString()
                    : "N/A"}
                </td>
                <td>{task.vendorName ?? "N/A"}</td>
                <td>
                  <button
                    onClick={() => handleEdit(task)}
                    style={{ color: "blue" }}>
                    Edit
                  </button>
                  <button
                    onClick={() => handleDelete(task.id)}
                    style={{ color: "red", marginLeft: "0.5rem" }}>
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

export default TasksPage;


// ==========================================
// FILE: frontend_harness/src/components/RelatedTables.tsx 
// ==========================================
import { useEffect, useState } from "react";
import { useSelectionContext } from "../context/useSelectionContext";
import { apiClient } from "../apiClient";
import type {
  TaskDto,
  NoteDto,
  EventDto,
  ContactDto,
  Guid,
  EmailLogDto,
} from "../types";

// Add vendorId to the props of the related tables
interface RelatedTableProps {
  contactId?: Guid | null;
  eventId?: Guid | null;
  vendorId?: Guid | null;
}

// --- Utility function to determine the API path and selection ID ---
const getApiContext = (
  props: RelatedTableProps,
  selectedContactId: Guid | null,
  selectedEventId: Guid | null,
  resource: "tasks" | "notes"
) => {
  // 1. Check for explicit props (used by Command Centers)
  if (props.vendorId) {
    return {
      id: props.vendorId,
      url: `/api/${resource}?vendorId=${props.vendorId}`,
      label: "Vendor",
    };
  }
  if (props.contactId) {
    return {
      id: props.contactId,
      url: `/api/${resource}?contactId=${props.contactId}`,
      label: "Contact",
    };
  }
  if (props.eventId) {
    return {
      id: props.eventId,
      url: `/api/${resource}?eventId=${props.eventId}`,
      label: "Event",
    };
  }

  // 2. Fall back to context (used by old pages/global lists)
  if (selectedContactId) {
    return {
      id: selectedContactId,
      url: `/api/${resource}?contactId=${selectedContactId}`,
      label: "Contact",
    };
  }
  if (selectedEventId) {
    return {
      id: selectedEventId,
      url: `/api/${resource}?eventId=${selectedEventId}`,
      label: "Event",
    };
  }
  return { id: null, url: null, label: null };
};

// --- 1. RelatedTasks ---
export function RelatedTasks(props: RelatedTableProps) {
  const { selectedContactId, selectedEventId } = useSelectionContext();
  const [tasks, setTasks] = useState<TaskDto[]>([]);
  const [loading, setLoading] = useState(false);

  const context = getApiContext(
    props,
    selectedContactId,
    selectedEventId,
    "tasks"
  );
  const selectedId = context.id;
  const apiUrl = context.url;
  const contextLabel = context.label;

  useEffect(() => {
    if (!selectedId || !apiUrl) {
      setTasks([]);
      return;
    }

    const fetchTasks = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<TaskDto[]>(apiUrl);
        setTasks(response.data);
      } catch (err) {
        console.error("Failed to fetch related tasks:", err);
      } finally {
        setLoading(false);
      }
    };

    fetchTasks();
  }, [selectedId, apiUrl]);

  if (!selectedId) return null;
  if (loading) return <p>Loading related tasks...</p>;

  const safeContextLabel = contextLabel as string;

  return (
    <div style={{ marginTop: "2rem" }}>
      {/* FIX: Show Full ID */}
      <h3>
        Related Tasks (for {safeContextLabel} ID: {selectedId})
      </h3>
      {tasks.length === 0 ? (
        <p>No tasks found for this {safeContextLabel.toLowerCase()}.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Title</th>
              <th>Status</th>
              <th>Due Date</th>
              <th>Linked Vendor</th> {/* NEW COLUMN HEADER */}
              <th>Linked Contact</th> {/* NEW COLUMN HEADER */}
              <th>Linked Event</th> {/* NEW COLUMN HEADER */}
            </tr>
          </thead>
          <tbody>
            {tasks.map((task) => (
              <tr key={task.id}>
                {/* FIX: Show Full ID (Shortened for space) */}
                <td>{task.id.substring(0, 8)}...</td>
                <td>{task.title}</td>
                <td>{task.status}</td>
                <td>
                  {task.dueDate
                    ? new Date(task.dueDate).toLocaleDateString()
                    : "N/A"}
                </td>
                {/* PHASE 28: Vendor Granularity */}
                <td>
                  {task.vendorName ??
                    (task.vendorId
                      ? `ID: ${task.vendorId.substring(0, 8)}...`
                      : "N/A")}
                </td>
                {/* PHASE 28: Contact/Event Granularity */}
                <td>
                  {task.contactId
                    ? `ID: ${task.contactId.substring(0, 8)}...`
                    : "N/A"}
                </td>
                <td>
                  {task.eventId
                    ? `ID: ${task.eventId.substring(0, 8)}...`
                    : "N/A"}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

// --- 2. RelatedNotes ---
export function RelatedNotes(props: RelatedTableProps) {
  const { selectedContactId, selectedEventId } = useSelectionContext();
  const [notes, setNotes] = useState<NoteDto[]>([]);
  const [loading, setLoading] = useState(false);

  const context = getApiContext(
    props,
    selectedContactId,
    selectedEventId,
    "notes"
  );
  const selectedId = context.id;
  const apiUrl = context.url;
  const contextLabel = context.label;

  useEffect(() => {
    if (!selectedId || !apiUrl) {
      setNotes([]);
      return;
    }

    const fetchNotes = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<NoteDto[]>(apiUrl);
        setNotes(response.data);
      } catch (err) {
        console.error("Failed to fetch related notes:", err);
      } finally {
        setLoading(false);
      }
    };

    fetchNotes();
  }, [selectedId, apiUrl]);

  if (!selectedId) return null;
  if (loading) return <p>Loading related notes...</p>;

  const safeContextLabel = contextLabel as string;

  return (
    <div style={{ marginTop: "2rem" }}>
      {/* FIX: Show Full ID */}
      <h3>
        Related Notes (for {safeContextLabel} ID: {selectedId})
      </h3>
      {notes.length === 0 ? (
        <p>No notes found for this {safeContextLabel.toLowerCase()}.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Content</th>
              <th>Linked Vendor</th> {/* NEW COLUMN HEADER */}
              <th>Linked Contact</th> {/* NEW COLUMN HEADER */}
              <th>Linked Event</th> {/* NEW COLUMN HEADER */}
            </tr>
          </thead>
          <tbody>
            {notes.map((note) => (
              <tr key={note.id}>
                {/* FIX: Show Full ID (Shortened for space) */}
                <td>{note.id.substring(0, 8)}...</td>
                <td>{note.content}</td>
                {/* PHASE 28: Vendor Granularity */}
                <td>
                  {note.vendorName ??
                    (note.vendorId
                      ? `ID: ${note.vendorId.substring(0, 8)}...`
                      : "N/A")}
                </td>
                {/* PHASE 28: Contact/Event Granularity */}
                <td>
                  {note.contactId
                    ? `ID: ${note.contactId.substring(0, 8)}...`
                    : "N/A"}
                </td>
                <td>
                  {note.eventId
                    ? `ID: ${note.eventId.substring(0, 8)}...`
                    : "N/A"}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

// --- 3. ContactEventsTable ---
export function ContactEventsTable() {
  const { selectedContactId } = useSelectionContext();
  const [events, setEvents] = useState<EventDto[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (!selectedContactId) {
      setEvents([]);
      return;
    }

    const fetchEvents = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<EventDto[]>(
          `/api/contacts/${selectedContactId}/events`
        );
        setEvents(response.data);
      } catch (err) {
        console.error("Failed to fetch contact's events:", err);
      } finally {
        setLoading(false);
      }
    };

    fetchEvents();
  }, [selectedContactId]);

  if (!selectedContactId) return null;
  if (loading) return <p>Loading related events...</p>;

  return (
    <div style={{ marginTop: "2rem" }}>
      {/* FIX: Show Full ID */}
      <h3>Related Events (for Contact ID: {selectedContactId})</h3>
      {events.length === 0 ? (
        <p>No events found linked to this contact.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Name</th>
              <th>Status</th>
              <th>Start</th>
              <th>Location</th>
            </tr>
          </thead>
          <tbody>
            {events.map((event) => (
              <tr key={event.id}>
                {/* FIX: Show Full ID */}
                <td>{event.id}</td>
                <td>{event.name}</td>
                <td>{event.status}</td>
                <td>{new Date(event.startDateTime).toLocaleString()}</td>
                <td>{event.location ?? "N/A"}</td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

// --- 4. EventParticipantsTable ---
interface EventParticipantsTableProps {
  onUnlinkSuccess: () => void;
}

export function EventParticipantsTable({
  onUnlinkSuccess,
}: EventParticipantsTableProps) {
  const { selectedEventId } = useSelectionContext();
  const [contacts, setContacts] = useState<ContactDto[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    const fetchContacts = async () => {
      if (!selectedEventId) {
        setContacts([]);
        return;
      }
      setLoading(true);
      try {
        const response = await apiClient.get<ContactDto[]>(
          `/api/events/${selectedEventId}/contacts`
        );
        setContacts(response.data);
      } catch (err) {
        console.error("Failed to fetch event participants:", err);
      } finally {
        setLoading(false);
      }
    };

    fetchContacts();
  }, [selectedEventId]);

  const handleUnlink = async (contactId: string) => {
    if (!selectedEventId) return;
    if (
      !window.confirm(
        "Are you sure you want to remove this contact from the event?"
      )
    )
      return;

    try {
      await apiClient.delete(
        `/api/events/${selectedEventId}/contacts/${contactId}`
      );
      onUnlinkSuccess();
    } catch (err) {
      console.error("Failed to unlink contact:", err);
      alert("Failed to unlink contact.");
    }
  };

  if (!selectedEventId) return null;
  if (loading) return <p>Loading event participants...</p>;

  return (
    <div style={{ marginTop: "2rem" }}>
      <h3>Event Participants (Staff/Guests)</h3>
      {contacts.length === 0 ? (
        <p>No participants linked to this event.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>First Name</th>
              <th>Last Name</th>
              <th>Email</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {contacts.map((contact) => (
              <tr key={contact.id}>
                {/* FIX: Show Full ID */}
                <td>{contact.id}</td>
                <td>{contact.firstName}</td>
                <td>{contact.lastName}</td>
                <td>{contact.email}</td>
                <td>
                  <button
                    onClick={() => handleUnlink(contact.id)}
                    style={{ color: "red", cursor: "pointer" }}>
                    Unlink
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

// --- 5. EmailHistoryTable ---
export function EmailHistoryTable() {
  const { selectedContactId } = useSelectionContext();
  const [logs, setLogs] = useState<EmailLogDto[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (!selectedContactId) {
      setLogs([]);
      return;
    }

    const fetchLogs = async () => {
      setLoading(true);
      try {
        const res = await apiClient.get<EmailLogDto[]>(
          `/api/contacts/${selectedContactId}/email-logs`
        );
        setLogs(res.data);
      } catch (err) {
        console.error("Failed to fetch email logs", err);
      } finally {
        setLoading(false);
      }
    };

    fetchLogs();
  }, [selectedContactId]);

  if (!selectedContactId) return null;

  return (
    <div style={{ marginTop: "2rem" }}>
      <h3>Email History (for Contact ID: {selectedContactId})</h3>
      {loading ? (
        <p>Loading logs...</p>
      ) : logs.length === 0 ? (
        <p>No emails sent to this contact.</p>
      ) : (
        <table
          border={1}
          cellPadding={5}
          style={{ width: "100%", borderCollapse: "collapse" }}>
          <thead>
            <tr style={{ background: "#333", color: "#fff" }}>
              <th>Subject</th>
              <th>Sent At</th>
              <th>Status</th>
              <th>Message</th>
            </tr>
          </thead>
          <tbody>
            {logs.map((log) => (
              <tr key={log.id}>
                <td>{log.subject}</td>
                <td>{new Date(log.sentAt).toLocaleString()}</td>
                <td
                  style={{
                    color: log.isSuccess ? "lightgreen" : "#ff6b6b",
                    fontWeight: "bold",
                  }}>
                  {log.isSuccess ? "Success" : "Failed"}
                </td>
                <td
                  style={{
                    maxWidth: "300px",
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    whiteSpace: "nowrap",
                  }}>
                  {log.errorMessage ? log.errorMessage : "Sent via SendGrid"}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

export default function RelatedTables() {
  return (
    <div>
      <RelatedTasks />
      <RelatedNotes />
    </div>
  );
}


// ==========================================
// FILE: frontend_harness/src/components/DashboardPage.tsx 
// ==========================================
// FILE: frontend_harness/src/components/DashboardPage.tsx

import { useEffect, useState, useCallback } from "react";
import {
  apiClient,
  updateContact,
  submitLead,
  deleteContact as deleteContactClient,
  initializeTestFixtures,
} from "../apiClient";
import { SendEmailModal } from "./SendEmailModal";
import type {
  DashboardStatsDto,
  ContactDto,
  VendorDto,
  EventDto,
} from "../types";

// --- INTERFACES ---

interface TestExecutionPanelProps {
  contacts: ContactDto[];
  logTestResult: (
    message: string,
    level: "PASS" | "FAIL" | "INFO" | "WARN"
  ) => void;
}

// --- COMPONENT: Test Execution Panel ---

const TestExecutionPanel: React.FC<TestExecutionPanelProps> = ({
  contacts,
  logTestResult,
}) => {
  // State for Manual Live Tests
  const [manualContactId, setManualContactId] = useState("");
  const [manualTemplateId, setManualTemplateId] = useState("");

  // --- 1. LIVE EMAIL TEST ---
  const executeLiveEmail = async () => {
    if (!manualContactId || !manualTemplateId) {
      alert("Please enter both Contact ID and Template ID.");
      return;
    }

    logTestResult(
      `Attempting to send Email to Contact: ${manualContactId}...`,
      "INFO"
    );

    try {
      await apiClient.post("/api/templates/send-email", {
        contactId: manualContactId,
        templateId: manualTemplateId,
      });
      logTestResult("SUCCESS: Email request sent to SendGrid.", "PASS");
      alert("Email Queued Successfully!");
    } catch (e: unknown) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      logTestResult(`FAILED: Could not send email. Error: ${errorMsg}`, "FAIL");
    }
  };

  // --- 2. LIVE SMS TEST ---
  const executeLiveSms = async () => {
    if (!manualContactId || !manualTemplateId) {
      alert("Please enter both Contact ID and Template ID.");
      return;
    }

    logTestResult(
      `Attempting to send SMS to Contact: ${manualContactId}...`,
      "INFO"
    );

    try {
      await apiClient.post("/api/automation/send-sms", {
        contactId: manualContactId,
        templateId: manualTemplateId,
      });
      logTestResult("SUCCESS: SMS request sent to Twilio.", "PASS");
      alert("SMS Queued Successfully! Check your phone.");
    } catch (e: unknown) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      logTestResult(`FAILED: Could not send SMS. Error: ${errorMsg}`, "FAIL");
    }
  };

  // --- 3. SYSTEM INTEGRITY (CRUD) TESTS ---
  const runSystemTests = useCallback(async () => {
    const output = document.getElementById("test-log-output");
    if (output) output.innerHTML = ""; // Clear log

    const testContact = contacts[0];

    logTestResult("Starting System Integrity Check...", "INFO");

    if (!testContact) {
      logTestResult(
        "ABORT: No contacts found in database to test against.",
        "WARN"
      );
      return;
    }

    // A. Lead Submission
    try {
      const leadId = await submitLead({
        firstName: "Auto",
        lastName: "Lead",
        email: `auto_lead_${Date.now()}@test.com`,
        source: "Dashboard Test Harness",
      });
      logTestResult(
        `POST /leads/submit: PASS. Created ID: ${leadId.substring(0, 8)}...`,
        "PASS"
      );

      // Cleanup
      await deleteContactClient(leadId);
      logTestResult(`DELETE /contacts: PASS. Cleaned up test lead.`, "PASS");
    } catch (e: unknown) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      logTestResult(`Lead Flow FAILED: ${errorMsg}`, "FAIL");
    }

    // B. Update Contact
    try {
      await updateContact(testContact.id, {
        ...testContact,
        lastName: "UpdatedByTest",
      });
      logTestResult(
        `PUT /contacts: PASS. Updated Contact ${testContact.id.substring(
          0,
          8
        )}.`,
        "PASS"
      );
    } catch (e: unknown) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      logTestResult(`Contact Update FAILED: ${errorMsg}`, "FAIL");
    }

    logTestResult("System Integrity Check Complete.", "INFO");
  }, [contacts, logTestResult]);

  return (
    <div className="mt-8 p-6 border border-gray-700 rounded-xl bg-gray-900 shadow-2xl">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-xl font-bold text-white flex items-center gap-2">
          <span className="w-3 h-3 bg-green-500 rounded-full animate-pulse"></span>
          API Test Lab
        </h2>
        <span className="text-xs font-mono text-gray-500">v48.0.3</span>
      </div>

      {/* --- LIVE LAB SECTION --- */}
      <div className="bg-gray-800 p-4 rounded-lg mb-6 border border-gray-700">
        <h3 className="text-sm font-bold text-blue-400 uppercase tracking-wider mb-4">
          Live Communication Lab
        </h3>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
          <div>
            <label className="block text-xs text-gray-400 mb-1">
              Target Contact ID (UUID)
            </label>
            <input
              value={manualContactId}
              onChange={(e) => setManualContactId(e.target.value)}
              placeholder="e.g. 3fa85f64-..."
              className="w-full bg-gray-900 border border-gray-600 rounded p-2 text-sm text-white font-mono focus:border-blue-500 outline-none"
            />
          </div>
          <div>
            <label className="block text-xs text-gray-400 mb-1">
              Template ID (UUID)
            </label>
            <input
              value={manualTemplateId}
              onChange={(e) => setManualTemplateId(e.target.value)}
              placeholder="e.g. 8efe1c11-..."
              className="w-full bg-gray-900 border border-gray-600 rounded p-2 text-sm text-white font-mono focus:border-purple-500 outline-none"
            />
          </div>
        </div>

        <div className="flex gap-3">
          <button
            onClick={executeLiveEmail}
            className="flex-1 bg-indigo-600 hover:bg-indigo-500 text-white py-2 rounded font-medium transition-colors text-sm">
            Test Real Email
          </button>
          <button
            onClick={executeLiveSms}
            className="flex-1 bg-green-600 hover:bg-green-500 text-white py-2 rounded font-medium transition-colors text-sm">
            Test Real SMS
          </button>
        </div>
      </div>

      {/* --- SYSTEM BUTTONS --- */}
      <button
        onClick={runSystemTests}
        className="w-full bg-gray-700 hover:bg-gray-600 text-gray-200 py-2 rounded font-medium transition-colors text-sm border border-gray-600 mb-4">
        Run CRUD Integrity Suite
      </button>

      {/* --- LOG OUTPUT --- */}
      <div className="bg-black rounded-lg p-3 border border-gray-800">
        <h4 className="text-gray-500 text-[10px] font-bold uppercase mb-2">
          Execution Log:
        </h4>
        <div
          id="test-log-output"
          className="h-32 overflow-y-auto font-mono text-xs space-y-1 text-gray-300"></div>
      </div>
    </div>
  );
};

// --- MAIN PAGE COMPONENT ---

export default function DashboardPage() {
  const [stats, setStats] = useState<DashboardStatsDto | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");

  // Modal State
  const [isEmailModalOpen, setIsEmailModalOpen] = useState(false);

  // Data for props
  const [contacts, setContacts] = useState<ContactDto[]>([]);
  const [vendors, setVendors] = useState<VendorDto[]>([]);
  const [isFixturesInitialized, setIsFixturesInitialized] = useState(false);

  // Logger
  const logTestResult = useCallback(
    (message: string, level: "PASS" | "FAIL" | "INFO" | "WARN") => {
      let color = "#e5e7eb"; // gray-200
      if (level === "PASS") color = "#4ade80"; // green-400
      if (level === "FAIL") color = "#f87171"; // red-400
      if (level === "WARN") color = "#fbbf24"; // amber-400

      const logEntry = `<div style="color: ${color}; margin-bottom: 2px;">
      <span style="opacity: 0.5;">[${new Date().toLocaleTimeString()}]</span> 
      <strong>${level}:</strong> ${message}
    </div>`;

      const output = document.getElementById("test-log-output");
      if (output) {
        output.innerHTML += logEntry;
        output.scrollTop = output.scrollHeight;
      }
    },
    []
  );

  useEffect(() => {
    const loadDashboardData = async () => {
      try {
        setLoading(true);

        // Run fixtures once
        if (!isFixturesInitialized) {
          logTestResult("Initializing Database Fixtures...", "INFO");
          await initializeTestFixtures();
          setIsFixturesInitialized(true);
          logTestResult("Fixtures Initialized.", "PASS");
        }

        const [statsRes, contactsRes, vendorsRes] = await Promise.all([
          apiClient.get<DashboardStatsDto>("/api/dashboard"),
          apiClient.get<ContactDto[]>("/api/contacts"),
          apiClient.get<VendorDto[]>("/api/vendors"),
        ]);

        setStats(statsRes.data);
        setContacts(contactsRes.data);
        setVendors(vendorsRes.data);
        setLoading(false);
      } catch (err: unknown) {
        console.error(err);
        setError("Dashboard failed to load. Ensure backend is running.");
        setLoading(false);
      }
    };
    loadDashboardData();
  }, [isFixturesInitialized, logTestResult]);

  if (loading)
    return (
      <div className="min-h-screen flex items-center justify-center text-gray-500 animate-pulse">
        Loading Command Center...
      </div>
    );

  if (error)
    return (
      <div className="p-8 m-8 bg-red-900/20 border border-red-800 text-red-200 rounded-lg">
        <h3 className="font-bold">Connection Error</h3>
        <p>{error}</p>
      </div>
    );

  if (!stats) return null;

  return (
    <div className="space-y-8 pb-10 max-w-7xl mx-auto px-4 sm:px-6">
      {/* 1. TEST EXECUTION PANEL */}
      <TestExecutionPanel contacts={contacts} logTestResult={logTestResult} />

      {/* 2. HEADER */}
      <div className="flex flex-col sm:flex-row justify-between items-end border-b border-gray-800 pb-6 gap-4">
        <div>
          <h1 className="text-4xl font-extrabold text-white tracking-tight">
            Command Center
          </h1>
          <p className="text-gray-400 mt-1">
            LCD Entertainment System Overview
          </p>
        </div>
        <div className="text-right">
          <div className="inline-flex items-center px-3 py-1 rounded-full bg-green-900/30 border border-green-800 text-green-400 text-xs font-bold uppercase tracking-wide">
            Phase 48: Active
          </div>
        </div>
      </div>

      {/* 3. STAT CARDS */}
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
        <StatCard
          label="Total Contacts"
          value={stats.totalContacts}
          color="border-blue-500"
        />
        <StatCard
          label="Active Events"
          value={stats.activeEvents}
          color="border-purple-500"
        />
        <StatCard
          label="Pending Tasks"
          value={stats.pendingTasks}
          color="border-yellow-500"
        />
        <StatCard
          label="Recent Emails"
          value={stats.recentEmails}
          color="border-green-500"
        />
      </div>

      {/* 4. UPCOMING EVENTS LIST */}
      <div className="bg-gray-800 rounded-2xl border border-gray-700 shadow-xl overflow-hidden">
        <div className="p-6 border-b border-gray-700 bg-gray-800/50">
          <h2 className="text-xl font-bold text-white">Upcoming Schedule</h2>
        </div>
        <div className="divide-y divide-gray-700">
          {stats.upcomingEvents.length === 0 ? (
            <div className="p-8 text-center text-gray-500 italic">
              No events scheduled.
            </div>
          ) : (
            stats.upcomingEvents.map((evt: EventDto) => (
              <div
                key={evt.id}
                className="p-6 flex flex-col sm:flex-row items-start sm:items-center gap-6 hover:bg-gray-700/30 transition-all">
                {/* Date Badge */}
                <div className="bg-gray-900 w-16 h-16 rounded-xl border border-gray-600 flex flex-col items-center justify-center flex-shrink-0">
                  <span className="text-[10px] text-gray-400 uppercase font-black">
                    {new Date(evt.startDateTime).toLocaleString("default", {
                      month: "short",
                    })}
                  </span>
                  <span className="text-2xl font-black text-white">
                    {new Date(evt.startDateTime).getDate()}
                  </span>
                </div>

                {/* Info */}
                <div className="flex-grow">
                  <h3 className="text-lg font-bold text-white">{evt.name}</h3>
                  <div className="flex flex-wrap gap-4 mt-1 text-sm text-gray-400">
                    <span className="flex items-center gap-1">
                      <span>ðŸ“</span> {evt.location || "TBD"}
                    </span>
                    <span className="flex items-center gap-1">
                      <span>ðŸ•’</span>{" "}
                      {new Date(evt.startDateTime).toLocaleTimeString([], {
                        hour: "2-digit",
                        minute: "2-digit",
                      })}
                    </span>
                  </div>
                </div>

                {/* Quick Action */}
                <button
                  onClick={() => setIsEmailModalOpen(true)}
                  className="w-full sm:w-auto bg-gray-900 hover:bg-blue-600 border border-gray-600 hover:border-blue-500 text-gray-300 hover:text-white px-4 py-2 rounded-lg text-sm font-bold transition-all shadow-sm">
                  Send Comms
                </button>
              </div>
            ))
          )}
        </div>
      </div>

      {/* 5. EMAIL MODAL */}
      <SendEmailModal
        isOpen={isEmailModalOpen}
        onClose={() => setIsEmailModalOpen(false)}
        availableContacts={contacts}
        availableVendors={vendors}
      />
    </div>
  );
}

// --- HELPER COMPONENT ---
function StatCard({
  label,
  value,
  color,
}: {
  label: string;
  value: number;
  color: string;
}) {
  return (
    <div
      className={`bg-gray-800 p-6 rounded-2xl border-b-4 ${color} shadow-lg transition-transform hover:scale-[1.02]`}>
      <p className="text-gray-400 text-xs font-black uppercase mb-1 tracking-widest">
        {label}
      </p>
      <p className="text-4xl font-black text-white">{value}</p>
    </div>
  );
}


// ==========================================
// FILE: frontend_harness/src/apiClient.ts 
// ==========================================
// FILE: frontend_harness/src/apiClient.ts (COMPLETE REPLACEMENT)
import axios from 'axios';
import { 
  type DocumentDto, 
  type EventFinancials, 
  type SendTemplateEmailCommand,
  type TemplateDto, 
  type ContactDto,
  type VendorDto,
  type EventDto,
  type TaskDto,
  type NoteDto,
  type EmailLogDto,
  type SubmitLeadCommand,
  RecipientType,
} from './types';


// Define the base URL of your local API
const API_BASE_URL = 'http://localhost:5179';

export const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// =======================================================
// CORE SERVICES
// =======================================================

// --- DOCUMENT SERVICES ---

export const uploadDocument = async (
  file: File, 
  relatedEntityId: string, 
  relatedEntityType: string,
  category: string
): Promise<Document> => {
  const formData = new FormData();
  formData.append('file', file);
  formData.append('relatedEntityId', relatedEntityId);
  formData.append('relatedEntityType', relatedEntityType);
  formData.append('category', category);

  const response = await apiClient.post<Document>('/api/documents', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  });
  return response.data;
};

export const deleteDocument = async (id: number): Promise<void> => {
  await apiClient.delete(`/api/documents/${id}`);
};

// --- FINANCIALS SERVICES ---

export const getEventFinancials = async (eventId: string): Promise<EventFinancials> => {
  const response = await apiClient.get<EventFinancials>(`/api/events/${eventId}/financials`);
  return response.data;
};

export const upsertBudget = async (
  eventId: string, 
  totalAmount: number, 
  currency: string, 
  notes?: string
): Promise<string> => {
  const payload = { eventId, totalAmount, currency, notes };
  const response = await apiClient.post<string>(`/api/events/${eventId}/financials/budget`, payload);
  return response.data;
};

export const addExpense = async (
  eventId: string,
  description: string,
  amount: number,
  dateIncurred: string, // ISO String
  category: string,
  vendorId?: string,
  linkedDocumentId?: number
): Promise<string> => {
  const payload = { eventId, description, amount, dateIncurred, category, vendorId, linkedDocumentId };
  const response = await apiClient.post<string>(`/api/events/${eventId}/financials/expenses`, payload);
  return response.data;
};


// --- TEMPLATE SERVICES ---

export const templates = {
  getAll: async () => {
    const response = await apiClient.get<TemplateDto[]>('/api/templates');
    return response.data;
  },
  create: async (data: unknown) => {
    const response = await apiClient.post<string>('/api/templates', data);
    return response.data;
  },
  sendEmail: async (command: SendTemplateEmailCommand) => {
    // Uses POST /api/templates/send
    await apiClient.post('/api/templates/send', command);
  }
};

/**
 * Initializes required contacts, vendors, and events for testing.
 * @returns The ID of the primary contact created.
 */
export const initializeTestFixtures = async (): Promise<string> => {
  const response = await apiClient.post<string>('/api/contacts/init-fixtures');
  return response.data;
};

// =======================================================
// FULL CRUD IMPLEMENTATION (PHASE 31)
// =======================================================

// --- CONTACTS CRUD & RELATIONS ---

export const updateContact = async (id: string, data: Partial<ContactDto>): Promise<void> => {
  await apiClient.put(`/api/contacts/${id}`, data);
};

export const deleteContact = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/contacts/${id}`);
};

export const getContactEmailLogs = async (contactId: string): Promise<EmailLogDto[]> => {
  const response = await apiClient.get<EmailLogDto[]>(`/api/contacts/${contactId}/email-logs`);
  return response.data;
};

// --- EVENTS CRUD & RELATIONS ---

export const updateEvent = async (id: string, data: Partial<EventDto>): Promise<void> => {
  await apiClient.put(`/api/events/${id}`, data);
};

export const deleteEvent = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/events/${id}`);
};

export const unlinkContactFromEvent = async (eventId: string, contactId: string): Promise<void> => {
  await apiClient.delete(`/api/events/${eventId}/contacts/${contactId}`);
};


// --- VENDORS CRUD ---

export const updateVendor = async (id: string, data: Partial<VendorDto>): Promise<void> => {
  await apiClient.put(`/api/vendors/${id}`, data);
};

export const deleteVendor = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/vendors/${id}`);
};


// --- TASKS CRUD ---
// (TasksController only has Create/Update/Delete - Reads are handled via GetTasksQuery)
export const updateTask = async (id: string, data: Partial<TaskDto>): Promise<void> => {
  await apiClient.put(`/api/tasks/${id}`, data);
};

export const deleteTask = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/tasks/${id}`);
};


// --- NOTES CRUD ---
// (NotesController only has Update/Delete - Create returns DTO)
export const updateNote = async (id: string, data: Partial<NoteDto>): Promise<void> => {
  // NOTE: Notes only allow updating 'content' per the business logic
  await apiClient.put(`/api/notes/${id}`, data); 
};

export const deleteNote = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/notes/${id}`);
};


// --- AUTOMATION & LEADS ---

export const submitLead = async (command: SubmitLeadCommand): Promise<string> => {
  const response = await apiClient.post<string>('/api/leads/submit', command);
  return response.data;
};

export const scheduleFollowUp = async (
  contactId: string, 
  templateId: string, 
  scheduleTime: string, // ISO String
  type: RecipientType = RecipientType.Contact
): Promise<string> => {
  const payload = { contactId, templateId, scheduleTime, type };
  const response = await apiClient.post<string>('/api/automation/schedule-followup', payload);
  return response.data;
};

// ==========================================
// FILE: frontend_harness/src/App.tsx 
// ==========================================
import {
  SignedIn,
  SignedOut,
  UserButton,
  useAuth,
  RedirectToSignIn,
} from "@clerk/clerk-react";
import { apiClient } from "./apiClient";
import { useEffect, useState } from "react";

import DashboardPage from "./components/DashboardPage"; // NEW IMPORT
import ContactsPage from "./components/ContactsPage";
import EventsPage from "./components/EventsPage";
import TasksPage from "./components/TasksPage";
import VendorsPage from "./components/VendorsPage";
import NotesPage from "./components/NotesPage";
import TemplatesPage from "./components/TemplatesPage";

import { SelectionProvider } from "./context/SelectionProvider";

type PageView =
  | "dashboard" // NEW TYPE
  | "contacts"
  | "events"
  | "tasks"
  | "vendors"
  | "notes"
  | "templates";

function App() {
  const [isApiReady, setIsApiReady] = useState(false);
  // CHANGED: Default to "dashboard"
  const [currentPage, setCurrentPage] = useState<PageView>("dashboard");
  const { getToken } = useAuth();

  useEffect(() => {
    const setupAxiosInterceptor = async () => {
      const interceptorId = apiClient.interceptors.request.use(
        async (config) => {
          const token = await getToken();

          if (token) {
            config.headers.Authorization = `Bearer ${token}`;
          }
          return config;
        },
        (error) => {
          return Promise.reject(error);
        }
      );

      setIsApiReady(true);

      return () => {
        apiClient.interceptors.request.eject(interceptorId);
        setIsApiReady(false);
      };
    };
    setupAxiosInterceptor();
  }, [getToken]);

  const renderPage = () => {
    switch (currentPage) {
      case "dashboard": // NEW CASE
        return <DashboardPage />;
      case "contacts":
        return <ContactsPage />;
      case "events":
        return <EventsPage />;
      case "tasks":
        return <TasksPage />;
      case "vendors":
        return <VendorsPage />;
      case "notes":
        return <NotesPage />;
      case "templates":
        return <TemplatesPage />;
      default:
        return <DashboardPage />;
    }
  };

  return (
    <SelectionProvider>
      <div>
        <header
          style={{
            padding: "1rem",
            display: "flex",
            justifyContent: "flex-end",
            borderBottom: "1px solid #333",
            marginBottom: "1rem",
          }}>
          <SignedIn>
            <UserButton />
          </SignedIn>
        </header>
        <main style={{ padding: "1rem" }}>
          <SignedIn>
            <div
              style={{
                display: "flex",
                alignItems: "center",
                justifyContent: "space-between",
                marginBottom: "1rem",
              }}>
              <h1>CRM_Vivid Command Center</h1>
            </div>

            <nav
              className="harness-nav"
              style={{
                marginBottom: "2rem",
                display: "flex",
                gap: "0.5rem",
                flexWrap: "wrap",
              }}>
              <button
                onClick={() => setCurrentPage("dashboard")}
                disabled={currentPage === "dashboard"}
                style={{
                  fontWeight: currentPage === "dashboard" ? "bold" : "normal",
                }}>
                ðŸ“Š Dashboard
              </button>
              <button
                onClick={() => setCurrentPage("contacts")}
                disabled={currentPage === "contacts"}>
                Contacts
              </button>
              <button
                onClick={() => setCurrentPage("events")}
                disabled={currentPage === "events"}>
                Events
              </button>
              <button
                onClick={() => setCurrentPage("tasks")}
                disabled={currentPage === "tasks"}>
                Tasks
              </button>
              <button
                onClick={() => setCurrentPage("vendors")}
                disabled={currentPage === "vendors"}>
                Vendors
              </button>
              <button
                onClick={() => setCurrentPage("notes")}
                disabled={currentPage === "notes"}>
                Notes
              </button>
              <button
                onClick={() => setCurrentPage("templates")}
                disabled={currentPage === "templates"}>
                Templates
              </button>
            </nav>

            <main className="harness-main">
              {isApiReady ? renderPage() : <p>Initializing API client...</p>}
            </main>
          </SignedIn>

          <SignedOut>
            <RedirectToSignIn />
          </SignedOut>
        </main>
      </div>
    </SelectionProvider>
  );
}

export default App;


// ==========================================
// FILE: frontend_harness/src/main.tsx 
// ==========================================
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.tsx";
import "./index.css";
import { ClerkProvider } from "@clerk/clerk-react";

// Import your env variable
const PUBLISHABLE_KEY = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY;

if (!PUBLISHABLE_KEY) {
  throw new Error("Missing Publishable Key");
}

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ClerkProvider publishableKey={PUBLISHABLE_KEY}>
      <App />
    </ClerkProvider>
  </React.StrictMode>
);


// ==========================================
// FILE: frontend_harness/src/context/useSelectionContext.tsx 
// ==========================================
import { useContext } from "react";
// Import the raw context from its new, separate file
import { SelectionContext } from "./internalContext";

// This is the only export, and it's a hook.
// This also satisfies the linter.
export const useSelectionContext = () => {
  const context = useContext(SelectionContext);
  if (context === undefined) {
    throw new Error(
      "useSelectionContext must be used within a SelectionProvider"
    );
  }
  return context;
};


// ==========================================
// FILE: frontend_harness/src/context/SelectionProvider.tsx 
// ==========================================
// frontend_harness/src/context/SelectionProvider.tsx (FULL FILE - Corrected)
import React, { useState, useMemo } from "react";
import { SelectionContext } from "./internalContext";
import type { Guid } from "../types"; // FIX: Added 'type' keyword (TS1484)

interface SelectionProviderProps {
  children: React.ReactNode;
}

export const SelectionProvider: React.FC<SelectionProviderProps> = ({
  children,
}) => {
  const [selectedContactId, setSelectedContactId] = useState<Guid | null>(null);
  const [selectedEventId, setSelectedEventId] = useState<Guid | null>(null);
  // NEW: State for selected vendor
  const [selectedVendorId, setSelectedVendorId] = useState<Guid | null>(null);

  const contextValue = useMemo(
    () => ({
      selectedContactId,
      setSelectedContactId,
      selectedEventId,
      setSelectedEventId,
      selectedVendorId, // NEW: Include in context value
      setSelectedVendorId, // NEW: Include in context value
    }),
    [selectedContactId, selectedEventId, selectedVendorId]
  ); // NEW: Include in dependency array

  return (
    <SelectionContext.Provider value={contextValue}>
      {children}
    </SelectionContext.Provider>
  );
};


// ==========================================
// FILE: frontend_harness/src/context/internalContext.tsx 
// ==========================================
// frontend_harness/src/context/internalContext.tsx
import { createContext } from "react";

// Define the shape of the context state
export interface SelectionContextType {
  selectedContactId: string | null;
  setSelectedContactId: (id: string | null) => void;
  selectedEventId: string | null;
  setSelectedEventId: (id: string | null) => void;
  // NEW: Vendor selection properties
  selectedVendorId: string | null;
  setSelectedVendorId: (id: string | null) => void;
}

// Create the context with an initial undefined value
export const SelectionContext = createContext<SelectionContextType | undefined>(
  undefined
);


// ==========================================
// FILE: frontend_harness/src/types.ts 
// ==========================================
// =======================================================
// FILE: frontend_harness/src/types.ts
// GENERATED FROM BACKEND DUMP - DO NOT MODIFY MANUALLY
// =======================================================

// --- ENUMS (String-based via JsonStringEnumConverter) ---

export const TemplateType = {
  Email: "Email",
  SMS: "SMS"
} as const;
export type TemplateType = typeof TemplateType[keyof typeof TemplateType];

export const ExpenseCategory = {
  General: "General",
  Venue: "Venue",
  Catering: "Catering",
  Talent: "Talent",
  Production: "Production",
  Marketing: "Marketing",
  Travel: "Travel",
  Admin: "Admin",
  Legal: "Legal"
} as const;
export type ExpenseCategory = typeof ExpenseCategory[keyof typeof ExpenseCategory];

export const EventStatus = {
  Planned: "Planned",
  InProgress: "InProgress",
  Completed: "Completed",
  Postponed: "Postponed",
  Cancelled: "Cancelled"
} as const;
export type EventStatus = typeof EventStatus[keyof typeof EventStatus];

export const TaskPriority = {
  Low: "Low",
  Medium: "Medium",
  High: "High",
  Urgent: "Urgent"
} as const;
export type TaskPriority = typeof TaskPriority[keyof typeof TaskPriority];

export const VendorType = {
  Catering: "Catering",
  Venue: "Venue",
  Security: "Security",
  Entertainment: "Entertainment",
  Florist: "Florist",
  Photography: "Photography",
  Videography: "Videography",
  Other: "Other"
} as const;
export type VendorType = typeof VendorType[keyof typeof VendorType];

export const ContractStatus = {
  Draft: "Draft",
  Sent: "Sent",
  Viewed: "Viewed",
  Signed: "Signed",
  Voided: "Voided"
} as const;
export type ContractStatus = typeof ContractStatus[keyof typeof ContractStatus];

export const ConnectionStatus = {
  Unknown: "Unknown",
  NeedToMeet: "NeedToMeet",
  MetAlready: "MetAlready",
  DoesntNeed: "DoesntNeed",
  NeedAndDoesntHave: "NeedAndDoesntHave",
  NeedAndHas: "NeedAndHas",
  HasAndNeedsToMeet: "HasAndNeedsToMeet"
} as const;
export type ConnectionStatus = typeof ConnectionStatus[keyof typeof ConnectionStatus];

export const LeadStage = {
  NewLead: "NewLead",
  InDiscussion: "InDiscussion",
  ProposalSent: "ProposalSent",
  Negotiating: "Negotiating",
  Won: "Won",
  Lost: "Lost"
} as const;
export type LeadStage = typeof LeadStage[keyof typeof LeadStage];

export const TaskStatus = {
  NotStarted: "NotStarted",
  InProgress: "InProgress",
  Completed: "Completed",
  Deferred: "Deferred"
} as const;
export type TaskStatus = typeof TaskStatus[keyof typeof TaskStatus];

export const RecipientType = {
  Contact: "Contact",
  Vendor: "Vendor"
} as const;
export type RecipientType = typeof RecipientType[keyof typeof RecipientType];

// --- READ DTOs (from Application/Common/Models) ---

export interface ActivityDto {
  id: string;
  timestamp: string; // DateTime
  activityType: string;
  title: string;
  content: string | null;
  status: string | null;
  relatedEntityId: string | null;
}

export interface ContactDto {
  id: string;
  firstName: string;
  lastName: string | null;
  email: string;
  phoneNumber: string | null;
  title: string | null;
  organization: string | null;
  // Pipeline Fields
  stage: LeadStage;
  connectionStatus: ConnectionStatus;
  isLead: boolean;
  followUpCount: number;
  lastContactedAt: string | null; // DateTime
  source: string | null;
  // Contextual
  role: string | null;
}

export interface ContactTaskSummaryDto {
  contactId: string;
  contactName: string;
  totalTasksAssigned: number;
  totalTasksCompleted: number;
  totalTasksOverdue: number;
}

export interface DashboardStatsDto {
  totalContacts: number;
  activeEvents: number;
  pendingTasks: number;
  recentEmails: number;
  upcomingEvents: EventDto[];
}

export interface DocumentDto {
  id: number;
  fileName: string;
  contentType: string;
  size: number;
  uploadedAt: string; // DateTime
  url: string;
  relatedEntityId: string;
  relatedEntityType: string;
  category: string;
}

export interface EmailLogDto {
  id: string;
  to: string;
  subject: string;
  sentAt: string; // DateTime
  isSuccess: boolean;
  errorMessage: string | null;
}

export interface EventDto {
  id: string;
  name: string;
  description: string | null;
  startDateTime: string; // DateTime
  endDateTime: string; // DateTime
  location: string | null;
  isPublic: boolean;
  status: string; // Mapped to String
}

export interface ExpenseDto {
  id: string;
  budgetId: string;
  description: string;
  amount: number;
  dateIncurred: string; // DateTime
  category: string; // Mapped to String (ExpenseCategory)
  vendorId: string | null;
  vendorName: string | null;
  linkedDocumentId: number | null;
  linkedDocumentName: string | null;
}

export interface EventFinancialsDto {
  eventId: string;
  eventName: string;
  budgetTotal: number;
  currency: string;
  notes: string | null;
  isLocked: boolean;
  expenses: ExpenseDto[];
  totalSpent: number;
  remainingBudget: number;
  burnRate: number;
}

export interface NoteDto {
  id: string;
  content: string;
  createdAt: string; // DateTime
  updatedAt: string | null; // DateTime
  contactId: string | null;
  eventId: string | null;
  taskId: string | null;
  vendorId: string | null;
  vendorName: string | null;
}

export interface TaskDto {
  id: string;
  title: string;
  description: string | null;
  status: string; // Mapped to String (TaskStatus)
  priority: string; // Mapped to String (TaskPriority)
  dueDate: string | null; // DateTime
  createdAt: string; // DateTime
  contactId: string | null;
  eventId: string | null;
  vendorId: string | null;
  vendorName: string | null;
}

export interface TemplateDto {
  id: string;
  name: string;
  subject: string | null;
  content: string;
  type: string; // Mapped to String (TemplateType)
}

export interface VendorDto {
  id: string;
  name: string;
  phoneNumber: string | null;
  email: string | null;
  serviceType: string; // Mapped to String (VendorType)
  attributes: string | null; // JSON string
  role: string | null;
}

export interface VendorSummaryDto {
  vendorId: string;
  vendorName: string;
  totalEventsHiredFor: number;
  totalExpensesPaid: number;
}

// --- WRITE DTOs (Commands) ---

// Automation
export interface ScheduleFollowUpCommand {
  contactId: string;
  templateId: string;
  scheduleTime: string; // DateTime
  type: RecipientType;
}

export interface SendSmsCommand {
  toPhoneNumber: string;
  body: string;
}

// Contacts
export interface CreateContactCommand {
  firstName: string;
  lastName: string | null;
  email: string;
  phoneNumber: string | null;
  title: string | null;
  organization: string | null;
  stage: LeadStage;
  connectionStatus: ConnectionStatus;
  source: string | null;
}

export interface UpdateContactCommand {
  id: string;
  firstName: string;
  lastName: string | null;
  email: string;
  phoneNumber: string | null;
  title: string | null;
  organization: string | null;
  stage: LeadStage;
  connectionStatus: ConnectionStatus;
  source: string | null;
  incrementFollowUpCount: boolean;
}

export interface SubmitLeadCommand {
  firstName: string;
  lastName: string | null;
  email: string;
  phoneNumber: string | null;
  organization: string | null;
  source: string | null;
}

// Documents
export interface UploadDocumentCommand {
  // Usually handled via FormData, but structured here for reference
  fileName: string;
  contentType: string;
  size: number;
  relatedEntityId: string;
  relatedEntityType: string;
  category: string;
}

// Events
export interface CreateEventCommand {
  name: string;
  startDateTime: string; // DateTime
  endDateTime: string; // DateTime
  isPublic: boolean;
  location: string | null;
  description: string | null;
}

export interface UpdateEventCommand {
  id: string;
  name: string;
  startDateTime: string; // DateTime
  endDateTime: string; // DateTime
  isPublic: boolean;
  location: string | null;
  description: string | null;
  status: EventStatus;
}

export interface AddContactToEventCommand {
  eventId: string;
  contactId: string;
  role: string | null;
}

export interface AddVendorToEventCommand {
  eventId: string;
  vendorId: string;
  role: string | null;
}

// Financials
export interface UpsertBudgetCommand {
  eventId: string;
  totalAmount: number;
  currency: string;
  notes: string | null;
}

export interface AddExpenseCommand {
  eventId: string;
  description: string;
  amount: number;
  dateIncurred: string; // DateTime
  category: string; // String to match Enum parsing in backend
  vendorId: string | null;
  linkedDocumentId: number | null;
}

// Notes
export interface CreateNoteCommand {
  content: string;
  contactId: string | null;
  eventId: string | null;
  taskId: string | null;
  vendorId: string | null;
  // String Lookups
  contactEmail: string | null;
  vendorName: string | null;
  eventName: string | null;
  taskTitle: string | null;
}

export interface UpdateNoteCommand {
  id: string;
  content: string;
}

// Tasks
export interface CreateTaskCommand {
  title: string;
  description: string | null;
  status: TaskStatus;
  priority: TaskPriority;
  dueDate: string | null; // DateTime
  contactId: string | null;
  eventId: string | null;
  vendorId: string | null;
  // String Lookups
  contactEmail: string | null;
  vendorName: string | null;
  eventName: string | null;
}

export interface UpdateTaskCommand {
  id: string;
  title: string;
  description: string | null;
  status: TaskStatus;
  priority: TaskPriority;
  dueDate: string | null; // DateTime
  contactId: string | null;
  eventId: string | null;
  vendorId: string | null;
  // String Lookups
  contactEmail: string | null;
  vendorName: string | null;
  eventName: string | null;
}

// Templates
export interface CreateTemplateCommand {
  name: string;
  subject: string | null;
  content: string;
  type: string;
}

export interface UpdateTemplateCommand {
  id: string;
  name: string;
  subject: string | null;
  content: string;
  type: string;
}

export interface SendTemplateEmailCommand {
  eventId: string;
  templateId: string;
  targetEntityId: string;
  recipientType: RecipientType;
}

// Vendors
export interface CreateVendorCommand {
  name: string;
  phoneNumber: string | null;
  email: string | null;
  serviceType: string;
  attributes: string | null; // JSON string
}

export interface UpdateVendorCommand {
  id: string;
  name: string;
  phoneNumber: string | null;
  email: string | null;
  serviceType: string;
  attributes: string | null; // JSON string
}

// Global Types
export type Guid = string;

// ==========================================
// FILE: frontend_harness/src/components/TemplatesPage.tsx 
// ==========================================
import { useEffect, useState } from "react";
import { apiClient } from "../apiClient";
import type { TemplateDto, CreateTemplateDto } from "../types"; // FIX: Added 'type' keyword

export default function TemplatesPage() {
  const [templates, setTemplates] = useState<TemplateDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");

  // Form State
  const [formData, setFormData] = useState<CreateTemplateDto>({
    name: "",
    subject: "",
    content: "",
    type: "Email", // Default
  });

  useEffect(() => {
    fetchTemplates();
  }, []);

  const fetchTemplates = async () => {
    try {
      const response = await apiClient.get<TemplateDto[]>("/api/templates");
      setTemplates(response.data);
    } catch (err) {
      console.error(err);
      setError("Failed to load templates.");
    } finally {
      setLoading(false);
    }
  };

  const handleCreate = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await apiClient.post("/api/templates", formData);
      // Reset form
      setFormData({
        name: "",
        subject: "",
        content: "",
        type: "Email",
      });
      fetchTemplates();
    } catch (err) {
      console.error(err);
      alert("Failed to create template.");
    }
  };

  const handleDelete = async (id: string) => {
    if (!confirm("Are you sure you want to delete this template?")) return;
    try {
      await apiClient.delete(`/api/templates/${id}`);
      fetchTemplates();
    } catch (err) {
      console.error(err);
      alert("Failed to delete template.");
    }
  };

  return (
    <div className="p-4">
      <h2 className="text-xl font-bold mb-4">Templates</h2>

      {/* CREATE FORM */}
      <div className="mb-8 p-4 border rounded shadow-sm bg-gray-50">
        <h3 className="font-semibold mb-2">New Template</h3>
        <form onSubmit={handleCreate} className="space-y-3">
          <div>
            <label className="block text-sm font-medium">Name (Internal)</label>
            <input
              className="border p-1 w-full"
              value={formData.name}
              onChange={(e) =>
                setFormData({ ...formData, name: e.target.value })
              }
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium">Type</label>
            <select
              className="border p-1 w-full"
              value={formData.type}
              onChange={(e) =>
                setFormData({ ...formData, type: e.target.value })
              }>
              <option value="Email">Email</option>
              <option value="SMS">SMS</option>
            </select>
          </div>

          {formData.type === "Email" && (
            <div>
              <label className="block text-sm font-medium">Subject Line</label>
              <input
                className="border p-1 w-full"
                value={formData.subject || ""}
                onChange={(e) =>
                  setFormData({ ...formData, subject: e.target.value })
                }
              />
            </div>
          )}

          <div>
            <label className="block text-sm font-medium">Content Body</label>
            <textarea
              className="border p-1 w-full h-24"
              value={formData.content}
              onChange={(e) =>
                setFormData({ ...formData, content: e.target.value })
              }
              required
            />
          </div>

          <button
            type="submit"
            className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">
            Save Template
          </button>
        </form>
      </div>

      {/* LIST */}
      {loading ? (
        <p>Loading...</p>
      ) : error ? (
        <p className="text-red-500">{error}</p>
      ) : (
        <table className="w-full border-collapse border">
          <thead>
            <tr className="bg-gray-100">
              <th className="border p-2 text-left">Name</th>
              <th className="border p-2 text-left">Type</th>
              <th className="border p-2 text-left">Subject</th>
              <th className="border p-2 text-left">Preview</th>
              <th className="border p-2 text-center">Actions</th>
            </tr>
          </thead>
          <tbody>
            {templates.map((t) => (
              <tr key={t.id} className="hover:bg-gray-50">
                <td className="border p-2 font-medium">{t.name}</td>
                <td className="border p-2">
                  <span
                    className={`px-2 py-1 rounded text-xs ${
                      t.type === "Email"
                        ? "bg-blue-100 text-blue-800"
                        : "bg-green-100 text-green-800"
                    }`}>
                    {t.type}
                  </span>
                </td>
                <td className="border p-2 text-gray-600">{t.subject || "â€”"}</td>
                <td className="border p-2 text-gray-500 text-sm">
                  {t.content.substring(0, 50)}
                  {t.content.length > 50 && "..."}
                </td>
                <td className="border p-2 text-center">
                  <button
                    onClick={() => handleDelete(t.id)}
                    className="text-red-600 hover:underline text-sm">
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}


// ==========================================
// FILE: frontend_harness/src/components/FinancialsSection.tsx 
// ==========================================
import { useCallback, useEffect, useState } from "react";
import type { EventFinancials, Expense } from "../types";
import { getEventFinancials, addExpense, upsertBudget } from "../apiClient";
import BudgetOverview from "./BudgetOverview";

interface Props {
  eventId: string;
  // NEW PROP: Accepts a key from the parent to force reload
  refreshKey: number;
}

export default function FinancialsSection({ eventId, refreshKey }: Props) {
  const [financials, setFinancials] = useState<EventFinancials | null>(null);
  const [loading, setLoading] = useState(true);

  // Form State
  const [showAddExpense, setShowAddExpense] = useState(false);
  const [newExpense, setNewExpense] = useState({
    description: "",
    amount: 0,
    category: "General",
    dateIncurred: new Date().toISOString().split("T")[0],
  });

  // Renamed loadData to fetchFinancials for clarity
  const fetchFinancials = useCallback(async () => {
    try {
      setLoading(true);
      const data = await getEventFinancials(eventId);
      setFinancials(data);
    } catch (error) {
      console.error("Failed to load financials", error);
    } finally {
      setLoading(false);
    }
  }, [eventId]); // Dependency: Only changes if the eventId itself changes

  // FIX: Reruns fetchFinancials whenever eventId OR refreshKey changes
  // The 'refreshKey' forces a re-render/re-fetch whenever the parent updates the key.
  useEffect(() => {
    fetchFinancials();
  }, [fetchFinancials, refreshKey]); // Added refreshKey as a direct trigger

  const handleCreateBudget = async () => {
    const amountStr = prompt("Enter Total Budget Amount:", "10000");
    if (!amountStr) return;
    await upsertBudget(eventId, parseFloat(amountStr), "USD", "Initial Budget");
    fetchFinancials();
  };

  const handleSubmitExpense = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newExpense.amount || !newExpense.description) return;

    await addExpense(
      eventId,
      newExpense.description,
      newExpense.amount,
      new Date(newExpense.dateIncurred).toISOString(),
      newExpense.category
    );

    setShowAddExpense(false);
    setNewExpense({
      description: "",
      amount: 0,
      category: "General",
      dateIncurred: new Date().toISOString().split("T")[0],
    });
    fetchFinancials();
  };

  if (loading)
    return (
      <div className="p-8 text-center text-gray-400">Calculating Ledger...</div>
    );

  // Scenario 1: No Budget Exists
  if (
    !financials ||
    (financials.budgetTotal === 0 && financials.expenses.length === 0)
  ) {
    return (
      <div className="text-center p-12 bg-[#333] rounded-xl border border-dashed border-gray-600 mb-8">
        <h3 className="text-lg font-medium text-white">No Budget Set</h3>
        <p className="mt-1 text-gray-400">
          Initialize a budget to start tracking expenses.
        </p>
        <button
          onClick={handleCreateBudget}
          className="mt-4 px-6 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition-colors">
          Create Budget
        </button>
      </div>
    );
  }

  return (
    <div className="space-y-8">
      <BudgetOverview data={financials} onEditBudget={handleCreateBudget} />

      <div className="flex justify-between items-center mb-4">
        <h3 className="text-xl font-bold text-white">Expenses</h3>
        <button
          onClick={() => setShowAddExpense(!showAddExpense)}
          className="px-4 py-2 bg-indigo-600 text-white rounded-md text-sm hover:bg-indigo-700 font-medium transition-colors">
          {showAddExpense ? "Cancel" : "+ Add Expense"}
        </button>
      </div>

      {showAddExpense && (
        <form
          onSubmit={handleSubmitExpense}
          className="bg-[#444] p-6 rounded-lg mb-6 border border-gray-600 grid grid-cols-1 md:grid-cols-4 gap-4 items-end">
          <div className="md:col-span-2">
            <label className="block text-xs font-medium text-gray-300 mb-1">
              Description
            </label>
            <input
              type="text"
              value={newExpense.description}
              onChange={(e) =>
                setNewExpense({ ...newExpense, description: e.target.value })
              }
              className="w-full rounded bg-[#333] border-gray-600 text-white p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500"
              required
            />
          </div>
          <div>
            <label className="block text-xs font-medium text-gray-300 mb-1">
              Amount ($)
            </label>
            <input
              type="number"
              value={newExpense.amount}
              onChange={(e) =>
                setNewExpense({
                  ...newExpense,
                  amount: parseFloat(e.target.value),
                })
              }
              className="w-full rounded bg-[#333] border-gray-600 text-white p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500"
              required
            />
          </div>
          <div>
            <label className="block text-xs font-medium text-gray-300 mb-1">
              Category
            </label>
            <select
              value={newExpense.category}
              onChange={(e) =>
                setNewExpense({ ...newExpense, category: e.target.value })
              }
              className="w-full rounded bg-[#333] border-gray-600 text-white p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500">
              {[
                "General",
                "Venue",
                "Catering",
                "Talent",
                "Production",
                "Marketing",
              ].map((c) => (
                <option key={c} value={c}>
                  {c}
                </option>
              ))}
            </select>
          </div>
          <button
            type="submit"
            className="bg-emerald-600 text-white py-2 px-4 rounded hover:bg-emerald-700 font-medium">
            Save
          </button>
        </form>
      )}

      <div className="bg-[#333] border border-gray-600 rounded-lg overflow-hidden shadow-md">
        <table className="table-fixed w-full text-left">
          <thead className="bg-[#222] text-gray-300 uppercase text-xs tracking-wider border-b border-gray-600">
            <tr>
              <th className="px-6 py-4 w-[15%]">Date</th>
              <th className="px-6 py-4 w-[35%]">Description</th>
              <th className="px-6 py-4 w-[15%]">Category</th>
              <th className="px-6 py-4 w-[15%]">Vendor</th>
              <th className="px-6 py-4 w-[20%] text-right">Amount</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-700">
            {financials.expenses.map((expense: Expense) => (
              <tr
                key={expense.id}
                className="hover:bg-[#383838] transition-colors">
                <td className="px-6 py-4 text-sm text-gray-300">
                  {new Date(expense.dateIncurred).toLocaleDateString()}
                </td>
                <td className="px-6 py-4 text-sm font-medium text-white">
                  {expense.description}
                  {expense.linkedDocumentName && (
                    <span className="ml-2 px-2 py-0.5 bg-blue-900 text-blue-200 text-xs rounded-full border border-blue-700">
                      Invoice
                    </span>
                  )}
                </td>
                <td className="px-6 py-4 text-sm text-gray-300">
                  <span className="px-2 py-1 text-xs font-semibold rounded-full bg-[#444] text-gray-200 border border-gray-600">
                    {expense.category}
                  </span>
                </td>
                <td className="px-6 py-4 text-sm text-gray-300">
                  {expense.vendorName || "-"}
                </td>
                <td className="px-6 py-4 text-sm text-right font-mono font-medium text-emerald-400">
                  ${expense.amount.toLocaleString()}
                </td>
              </tr>
            ))}
            {financials.expenses.length === 0 && (
              <tr>
                <td
                  colSpan={5}
                  className="px-6 py-8 text-center text-sm text-gray-500">
                  No expenses recorded yet.
                </td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
}


// ==========================================
// FILE: frontend_harness/src/components/VendorEventsTable.tsx 
// ==========================================
import React, { useState, useEffect, useCallback } from "react";
import { apiClient } from "../apiClient";
import type { EventDto, Guid } from "../types";

interface VendorEventsTableProps {
  vendorId: Guid;
}

const VendorEventsTable: React.FC<VendorEventsTableProps> = ({ vendorId }) => {
  const [events, setEvents] = useState<EventDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // FIX: Wrap in useCallback to satisfy ESLint and allow usage in useEffect + Retry button
  const fetchEvents = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const response = await apiClient.get<EventDto[]>(
        `/api/vendors/${vendorId}/events`
      );
      setEvents(response.data);
    } catch (err) {
      console.error("Error fetching events for vendor:", err);
      setError("Failed to load events.");
    } finally {
      setLoading(false);
    }
  }, [vendorId]); // Re-create function only if vendorId changes

  useEffect(() => {
    if (vendorId) {
      fetchEvents();
    }
  }, [fetchEvents, vendorId]); // FIX: Added fetchEvents dependency

  if (loading) return <div style={{ padding: "10px" }}>Loading events...</div>;

  if (error)
    return (
      <div style={{ color: "red", padding: "10px" }}>
        {error} <button onClick={fetchEvents}>Retry</button>
      </div>
    );

  return (
    <div style={{ marginBottom: "30px" }}>
      <h3>Events Hired For ({events.length})</h3>
      {events.length === 0 ? (
        <p>This vendor is not currently linked to any events.</p>
      ) : (
        <table style={{ width: "100%", borderCollapse: "collapse" }}>
          <thead>
            <tr style={{ borderBottom: "2px solid #ccc" }}>
              <th style={{ padding: "8px", textAlign: "left" }}>Event Name</th>
              <th style={{ padding: "8px", textAlign: "left" }}>Date</th>
              <th style={{ padding: "8px", textAlign: "left" }}>Status</th>
            </tr>
          </thead>
          <tbody>
            {events.map((event) => (
              <tr key={event.id} style={{ borderBottom: "1px solid #eee" }}>
                <td style={{ padding: "8px" }}>{event.name}</td>
                <td style={{ padding: "8px" }}>
                  {new Date(event.startDateTime).toLocaleDateString()}
                </td>
                <td style={{ padding: "8px" }}>{event.status}</td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
};

export default VendorEventsTable;


// ==========================================
// FILE: frontend_harness/src/components/ContactsPage.tsx 
// ==========================================
// FILE: frontend_harness/src/components/ContactsPage.tsx

import { useEffect, useState } from "react";
import { apiClient, scheduleEmail } from "../apiClient";
import type { ContactDto, TemplateDto } from "../types";
import { LeadStage, ConnectionStatus } from "../types";
import axios from "axios";

import { useSelectionContext } from "../context/useSelectionContext";
import {
  RelatedTasks,
  RelatedNotes,
  ContactEventsTable,
  EmailHistoryTable,
} from "./RelatedTables";

type ContactFormData = Omit<ContactDto, "id">;
type ValidationErrors = {
  [key: string]: string[];
};

const styleSheet = document.createElement("style");
styleSheet.type = "text/css";
styleSheet.innerText = `
  .contact-row:hover {
    cursor: pointer;
    background-color: #333;
  }
  .selected-row {
    background-color: #004a99;
    color: white;
  }
  .selected-row:hover {
    background-color: #005ac7;
  }
  .modal-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  .modal-content {
    background: #222;
    padding: 2rem;
    border: 1px solid #555;
    min-width: 400px;
    border-radius: 8px;
  }
`;
document.head.appendChild(styleSheet);

function ContactsPage() {
  const [contacts, setContacts] = useState<ContactDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // --- Email Scheduling State ---
  const [templates, setTemplates] = useState<TemplateDto[]>([]);
  const [isEmailModalOpen, setIsEmailModalOpen] = useState(false);
  const [emailConfig, setEmailConfig] = useState({
    contactId: "",
    contactName: "", // For display
    templateId: "",
    sendAt: "",
  });
  // ------------------------------

  const initialFormState: ContactFormData = {
    firstName: "",
    lastName: "",
    email: "",
    phoneNumber: null,
    title: null,
    organization: null,
    // New Pipeline Fields
    stage: LeadStage.NewLead,
    connectionStatus: ConnectionStatus.NeedToMeet,
    isLead: true,
    followUpCount: 0,
    source: null,
    lastContactedAt: null,
    role: null,
  };

  const [formData, setFormData] =
    useState<Partial<ContactDto>>(initialFormState);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<ValidationErrors>(
    {}
  );

  const { selectedContactId, setSelectedContactId } = useSelectionContext();
  const isEditing = editingId !== null;

  const fetchContacts = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiClient.get<ContactDto[]>("/api/contacts");
      setContacts(response.data);
    } catch (err: unknown) {
      console.error(err);
      let errorMessage = "Failed to fetch contacts. An unknown error occurred.";
      if (err instanceof Error) {
        errorMessage = `Failed to fetch contacts: ${err.message}`;
      }
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  // Fetch Templates for the dropdown
  const fetchTemplates = async () => {
    try {
      const response = await apiClient.get<TemplateDto[]>("/api/templates");
      setTemplates(response.data);
    } catch (err) {
      console.error("Failed to load templates", err);
    }
  };

  useEffect(() => {
    fetchContacts();
    fetchTemplates();
    return () => {
      setSelectedContactId(null);
    };
  }, [setSelectedContactId]);

  const handleDelete = async (id: string) => {
    if (!window.confirm("Are you sure you want to delete this contact?")) {
      return;
    }

    if (id === selectedContactId) {
      setSelectedContactId(null);
    }

    try {
      await apiClient.delete(`/api/contacts/${id}`);
      await fetchContacts();
    } catch (err) {
      console.error(err);
      if (err instanceof Error) {
        alert(`Failed to delete contact: ${err.message}`);
      }
    }
  };

  const handleEdit = (contact: ContactDto) => {
    setEditingId(contact.id);
    setFormData(contact);
    setValidationErrors({});
    window.scrollTo(0, 0);
  };

  const handleCancel = () => {
    setEditingId(null);
    setFormData(initialFormState);
    setValidationErrors({});
  };

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>
  ) => {
    const { name, value, type } = e.target;
    setFormData((prev) => {
      let newValue: string | number | boolean | null =
        value === "" ? null : value;

      // Handle Numeric Enums (Stage & ConnectionStatus)
      if (name === "stage" || name === "connectionStatus") {
        newValue = parseInt(value, 10);
      }

      // Handle Checkbox
      if (type === "checkbox") {
        newValue = (e.target as HTMLInputElement).checked;
      }

      return {
        ...prev,
        [name]: newValue,
      };
    });
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setValidationErrors({});

    const payload = {
      ...formData,
      firstName: formData.firstName ?? "",
      lastName: formData.lastName ?? "",
      email: formData.email ?? "",
      stage: formData.stage ?? LeadStage.NewLead,
      connectionStatus:
        formData.connectionStatus ?? ConnectionStatus.NeedToMeet,
      isLead: formData.isLead ?? true,
      followUpCount: formData.followUpCount ?? 0,
    };

    const promise = isEditing
      ? apiClient.put(`/api/contacts/${editingId}`, payload)
      : apiClient.post("/api/contacts", payload);

    try {
      await promise;
      handleCancel();
      await fetchContacts();
    } catch (err: unknown) {
      if (axios.isAxiosError(err) && err.response?.status === 400) {
        const apiErrors = err.response.data.errors || {
          General: ["An unknown validation error occurred."],
        };
        setValidationErrors(apiErrors);
      } else {
        console.error(err);
        alert("An unexpected error occurred.");
      }
    }
  };

  const handleRowClick = (contactId: string) => {
    if (isEditing) {
      handleCancel();
    }

    if (selectedContactId === contactId) {
      setSelectedContactId(null);
    } else {
      setSelectedContactId(contactId);
    }
  };

  // --- Email Modal Handlers ---
  const openEmailModal = (e: React.MouseEvent, contact: ContactDto) => {
    e.stopPropagation();
    // Prevent row selection
    setEmailConfig({
      contactId: contact.id,
      contactName: `${contact.firstName} ${contact.lastName}`,
      templateId: templates.length > 0 ? templates[0].id : "",
      sendAt: "",
    });
    setIsEmailModalOpen(true);
  };

  const handleEmailSubmit = async () => {
    if (!emailConfig.templateId) {
      alert("Please select a template.");
      return;
    }

    // 1. Find Data Objects
    const targetContact = contacts.find((c) => c.id === emailConfig.contactId);
    const targetTemplate = templates.find(
      (t) => t.id === emailConfig.templateId
    );

    if (!targetContact || !targetTemplate) {
      alert("Contact or Template not found.");
      return;
    }

    // 2. Safe Time Buffer (Now + 1 min if blank)
    const safeTime = emailConfig.sendAt
      ? new Date(emailConfig.sendAt).toISOString()
      : new Date(Date.now() + 60 * 1000).toISOString();

    try {
      // 3. Send Full Payload via Helper
      await scheduleEmail({
        contact: targetContact,
        templateId: targetTemplate.id,
        subject: targetTemplate.subject || "New Message",
        templateContent: targetTemplate.content, // FIXED: Renamed to templateContent
        scheduleTime: safeTime,
      });

      alert("Email scheduled successfully!");
      setIsEmailModalOpen(false);
    } catch (err: unknown) {
      console.error(err);

      let msg = "Failed to schedule email.";

      if (
        axios.isAxiosError(err) &&
        err.response?.data?.errors?.[0]?.ErrorMessage
      ) {
        msg = err.response.data.errors[0].ErrorMessage;
      } else if (err instanceof Error) {
        msg = err.message;
      }

      alert(`Error: ${msg}`);
    }
  };
  // ----------------------------

  if (error) return <p style={{ color: "red" }}>{error}</p>;

  return (
    <div>
      {/* --- Email Modal --- */}
      {isEmailModalOpen && (
        <div className="modal-overlay">
          <div className="modal-content">
            <h3>Send Email to: {emailConfig.contactName}</h3>

            <div style={{ marginBottom: "1rem" }}>
              <label style={{ display: "block", marginBottom: "0.5rem" }}>
                Select Template:
              </label>
              <select
                style={{ width: "100%", padding: "0.5rem" }}
                value={emailConfig.templateId}
                onChange={(e) =>
                  setEmailConfig((prev) => ({
                    ...prev,
                    templateId: e.target.value,
                  }))
                }>
                <option value="">-- Select a Template --</option>
                {templates.map((t) => (
                  <option key={t.id} value={t.id}>
                    {t.name}
                  </option>
                ))}
              </select>
            </div>

            <div style={{ marginBottom: "1rem" }}>
              <label style={{ display: "block", marginBottom: "0.5rem" }}>
                Send At (Optional):
              </label>
              <input
                type="datetime-local"
                style={{ width: "100%", padding: "0.5rem" }}
                value={emailConfig.sendAt}
                onChange={(e) =>
                  setEmailConfig((prev) => ({
                    ...prev,
                    sendAt: e.target.value,
                  }))
                }
              />
              <small>Leave blank to send immediately.</small>
            </div>

            <div
              style={{
                display: "flex",
                justifyContent: "flex-end",
                gap: "1rem",
              }}>
              <button onClick={() => setIsEmailModalOpen(false)}>Cancel</button>
              <button
                onClick={handleEmailSubmit}
                style={{ backgroundColor: "#004a99", color: "white" }}>
                Send Email
              </button>
            </div>
          </div>
        </div>
      )}

      <div
        style={{
          marginBottom: "2rem",
          padding: "1rem",
          border: "1px solid #555",
        }}>
        <h2>{isEditing ? "Edit Contact" : "Create Contact"}</h2>
        <form onSubmit={handleSubmit}>
          {/* --- Identity Fields --- */}
          <div style={{ display: "flex", gap: "1rem" }}>
            <div style={{ marginBottom: "0.5rem", flex: 1 }}>
              <label>First Name: </label>
              <input
                name="firstName"
                value={formData.firstName ?? ""}
                onChange={handleChange}
                style={{ width: "100%" }}
              />
              {validationErrors.FirstName && (
                <div style={{ color: "red" }}>
                  {validationErrors.FirstName[0]}
                </div>
              )}
            </div>
            <div style={{ marginBottom: "0.5rem", flex: 1 }}>
              <label>Last Name: </label>
              <input
                name="lastName"
                value={formData.lastName ?? ""}
                onChange={handleChange}
                style={{ width: "100%" }}
              />
              {validationErrors.LastName && (
                <div style={{ color: "red" }}>
                  {validationErrors.LastName[0]}
                </div>
              )}
            </div>
          </div>

          <div style={{ display: "flex", gap: "1rem" }}>
            <div style={{ marginBottom: "0.5rem", flex: 1 }}>
              <label>Email: </label>
              <input
                name="email"
                value={formData.email ?? ""}
                onChange={handleChange}
                style={{ width: "100%" }}
              />
              {validationErrors.Email && (
                <div style={{ color: "red" }}>{validationErrors.Email[0]}</div>
              )}
            </div>
            <div style={{ marginBottom: "0.5rem", flex: 1 }}>
              <label>Phone: </label>
              <input
                name="phoneNumber"
                value={formData.phoneNumber ?? ""}
                onChange={handleChange}
                style={{ width: "100%" }}
              />
            </div>
          </div>

          {/* --- Pipeline & Strategy Fields (NEW) --- */}
          <div
            style={{
              margin: "1rem 0",
              padding: "1rem",
              border: "1px dashed #666",
              borderRadius: "4px",
            }}>
            <h4 style={{ marginTop: 0, marginBottom: "0.5rem" }}>
              Pipeline Status
            </h4>
            <div style={{ display: "flex", gap: "1rem", flexWrap: "wrap" }}>
              {/* Stage Dropdown */}
              <div style={{ flex: 1 }}>
                <label>Lead Stage: </label>
                <select
                  name="stage"
                  value={formData.stage ?? LeadStage.NewLead}
                  onChange={handleChange}
                  style={{ width: "100%", padding: "4px" }}>
                  {Object.entries(LeadStage).map(([key, value]) => (
                    <option key={key} value={value}>
                      {key}
                    </option>
                  ))}
                </select>
              </div>

              {/* Connection Status Dropdown */}
              <div style={{ flex: 1 }}>
                <label>Connection Status: </label>
                <select
                  name="connectionStatus"
                  value={
                    formData.connectionStatus ?? ConnectionStatus.NeedToMeet
                  }
                  onChange={handleChange}
                  style={{ width: "100%", padding: "4px" }}>
                  {Object.entries(ConnectionStatus).map(([key, value]) => (
                    <option key={key} value={value}>
                      {key}
                    </option>
                  ))}
                </select>
              </div>

              {/* Is Lead Checkbox */}
              <div
                style={{
                  flex: "0 0 auto",
                  display: "flex",
                  alignItems: "center",
                  paddingTop: "1.2rem",
                }}>
                <label
                  style={{
                    display: "flex",
                    alignItems: "center",
                    cursor: "pointer",
                  }}>
                  <input
                    type="checkbox"
                    name="isLead"
                    checked={formData.isLead ?? true}
                    onChange={handleChange}
                    style={{ marginRight: "0.5rem" }}
                  />
                  Is Lead?
                </label>
              </div>
            </div>
          </div>

          <div style={{ marginBottom: "0.5rem" }}>
            <label>Organization: </label>
            <input
              name="organization"
              value={formData.organization ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Title: </label>
            <input
              name="title"
              value={formData.title ?? ""}
              onChange={handleChange}
            />
          </div>

          <button type="submit">{isEditing ? "Save Changes" : "Create"}</button>
          {isEditing && (
            <button
              type="button"
              onClick={handleCancel}
              style={{ marginLeft: "0.5rem" }}>
              Cancel
            </button>
          )}
          {validationErrors.General && (
            <div style={{ color: "red", marginTop: "1rem" }}>
              {validationErrors.General[0]}
            </div>
          )}
        </form>
      </div>

      <h2>Contacts List</h2>
      {loading ? (
        <p>Loading Contacts...</p>
      ) : contacts.length === 0 ? (
        <p>No contacts found.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Name</th>
              <th>Email</th>
              <th>Status</th> {/* NEW COLUMN */}
              <th>Organization</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {contacts.map((contact) => (
              <tr
                key={contact.id}
                className={`
                  contact-row 
                  ${selectedContactId === contact.id ? "selected-row" : ""}
                `}
                onClick={(e) => {
                  if (
                    e.target instanceof HTMLElement &&
                    e.target.tagName !== "BUTTON" &&
                    e.target.tagName !== "SELECT"
                  ) {
                    handleRowClick(contact.id);
                  }
                }}>
                <td>{contact.id.substring(0, 8)}...</td>
                <td>
                  {contact.firstName} {contact.lastName}
                </td>
                <td>{contact.email}</td>
                {/* NEW STATUS COLUMN */}
                <td>
                  <span
                    style={{
                      fontSize: "0.8rem",
                      padding: "2px 4px",
                      background: "#444",
                      borderRadius: "4px",
                    }}>
                    {Object.keys(LeadStage).find(
                      (key) =>
                        LeadStage[key as keyof typeof LeadStage] ===
                        contact.stage
                    )}
                  </span>
                </td>
                <td>{contact.organization ?? "N/A"}</td>
                <td>
                  <button
                    onClick={() => handleEdit(contact)}
                    style={{ color: "lightblue", marginRight: "0.5rem" }}>
                    Edit
                  </button>
                  <button
                    onClick={() => handleDelete(contact.id)}
                    style={{ color: "red", marginRight: "0.5rem" }}>
                    Delete
                  </button>
                  <button
                    onClick={(e) => openEmailModal(e, contact)}
                    style={{ color: "lightgreen" }}>
                    Send Email
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}

      {selectedContactId && (
        <div
          style={{
            borderTop: "2px solid #555",
            marginTop: "3rem",
            paddingTop: "1rem",
          }}>
          <h2>Contact Dashboard: ID {selectedContactId}</h2>
          <ContactEventsTable />
          <RelatedTasks />
          <RelatedNotes />
          <EmailHistoryTable />
        </div>
      )}
    </div>
  );
}

export default ContactsPage;


// ==========================================
// FILE: frontend_harness/src/components/EventsPage.tsx 
// ==========================================
// FILE: frontend_harness/src/components/EventsPage.tsx
import React, { useEffect, useState, useCallback } from "react";
import { apiClient } from "../apiClient";
// FIX 1: Removed unused 'Guid' import
import type { EventDto, ContactDto, VendorDto } from "../types";
import axios from "axios";
import { useSelectionContext } from "../context/useSelectionContext";
import {
  RelatedTasks,
  RelatedNotes,
  EventParticipantsTable,
} from "./RelatedTables";
import { DocumentsSection } from "./DocumentsSection";
// --- NEW: Import the Financials Module ---
import FinancialsSection from "./FinancialsSection";

type EventFormData = Omit<EventDto, "id">;
type ValidationErrors = { [key: string]: string[] };

// --- SUB-COMPONENT: EventVendorAttributesDisplay ---
interface VendorAttributeProps {
  eventVendors: VendorDto[]; // All vendors linked to the event (or fetched separately)
}

const EventVendorAttributesDisplay: React.FC<VendorAttributeProps> = ({
  eventVendors,
}) => {
  // Filter for vendors whose attributes we care about displaying prominently on the dashboard
  const featuredVendors = eventVendors.filter(
    (v) =>
      v.serviceType?.toLowerCase() === "venue" ||
      v.serviceType?.toLowerCase() === "entertainment"
  );

  if (featuredVendors.length === 0) {
    return null;
  }

  return (
    <div
      style={{
        marginTop: "20px",
        padding: "15px",
        border: "1px solid #777",
        borderRadius: "5px",
        backgroundColor: "#333",
      }}>
      <h4 style={{ margin: 0, color: "#ccc" }}>Key Vendor Attributes</h4>
      <div
        style={{
          marginTop: "10px",
          display: "flex",
          flexWrap: "wrap",
          gap: "20px",
        }}>
        {featuredVendors.map((vendor) => {
          let attributeDisplay = null;
          // FIX 2: Changed 'let title' to 'const title'
          const title = vendor.name;

          try {
            if (vendor.attributes) {
              const attrs = JSON.parse(vendor.attributes);

              if (
                vendor.serviceType?.toLowerCase() === "venue" &&
                attrs.Capacity
              ) {
                attributeDisplay = `Capacity: ${attrs.Capacity}`;
              } else if (
                vendor.serviceType?.toLowerCase() === "entertainment" &&
                attrs.Genre
              ) {
                attributeDisplay = `Genre: ${attrs.Genre}`;
              }
            }
          } catch (e) {
            console.error("Error parsing vendor attributes:", e);
          }

          if (!attributeDisplay) {
            // Skip if the required key isn't found
            return null;
          }

          return (
            <div
              key={vendor.id}
              style={{ borderLeft: "3px solid #64b5f6", paddingLeft: "10px" }}>
              <strong style={{ display: "block", color: "#fff" }}>
                {title} ({vendor.serviceType})
              </strong>
              <span style={{ color: "#aaa", fontSize: "0.9rem" }}>
                {attributeDisplay}
              </span>
            </div>
          );
        })}
      </div>
    </div>
  );
};
// --- END EventVendorAttributesDisplay ---

// --- SUB-COMPONENT: ContactLinker ---
interface ContactLinkerProps {
  eventId: string;
  onLinkSuccess: () => void;
}

const ContactLinker: React.FC<ContactLinkerProps> = ({
  eventId,
  onLinkSuccess,
}) => {
  const [contacts, setContacts] = useState<ContactDto[]>([]);
  const [selectedContactId, setSelectedContactId] = useState<string>("");
  const [loading, setLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchContacts = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<ContactDto[]>("/api/contacts");
        setContacts(response.data);
        if (response.data.length > 0) {
          setSelectedContactId(response.data[0].id);
        }
      } catch (err) {
        console.error("Failed to fetch all contacts:", err);
      } finally {
        setLoading(false);
      }
    };
    fetchContacts();
  }, []);

  const handleLink = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!selectedContactId) {
      setError("Please select a contact to link.");
      return;
    }

    setIsSubmitting(true);
    setError(null);
    try {
      const payload = { contactId: selectedContactId };
      await apiClient.post(`/api/events/${eventId}/contacts`, payload);

      onLinkSuccess();
      setError(null);
    } catch (err) {
      const message =
        axios.isAxiosError(err) && err.response?.data?.title
          ? err.response.data.title
          : "Failed to link contact to event.";
      setError(message);
    } finally {
      setIsSubmitting(false);
    }
  };

  if (loading) return <p>Loading contacts for linking...</p>;
  if (contacts.length === 0) return <p>No available contacts to link.</p>;
  return (
    <div
      style={{
        border: "1px dashed #ccc",
        padding: "1rem",
        marginBottom: "1rem",
      }}>
      <h4>Link Contact to Event</h4>
      <form onSubmit={handleLink} style={{ display: "flex", gap: "10px" }}>
        <select
          value={selectedContactId}
          onChange={(e) => setSelectedContactId(e.target.value)}
          disabled={isSubmitting}>
          {contacts.map((contact) => (
            <option key={contact.id} value={contact.id}>
              {contact.firstName} {contact.lastName} ({contact.email})
            </option>
          ))}
        </select>
        <button type="submit" disabled={isSubmitting}>
          {isSubmitting ? "Linking..." : "Link Contact"}
        </button>
      </form>
      {error && (
        <div style={{ color: "red", marginTop: "0.5rem" }}>Error: {error}</div>
      )}
    </div>
  );
};
// --- END ContactLinker ---

function EventsPage() {
  const [events, setEvents] = useState<EventDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // FIX 3: Removed unused 'allVendors' state
  const [eventVendors, setEventVendors] = useState<VendorDto[]>([]);
  // ----------------------------------

  const { selectedEventId, setSelectedEventId } = useSelectionContext();
  const [dashboardKey, setDashboardKey] = useState(0);

  const initialFormState: EventFormData = {
    name: "",
    description: null,
    startDateTime: "",
    endDateTime: "",
    location: null,
    isPublic: false,
    status: "Planned",
  };
  const [formData, setFormData] = useState<Partial<EventDto>>(initialFormState);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<ValidationErrors>(
    {}
  );

  const isEditing = editingId !== null;

  // --- PHASE 29: Fetch Vendor Data for Attribute Display (Simplified) ---
  const fetchAuxiliaryData = useCallback(async () => {
    try {
      // We only need the vendors linked to the *current* event
      // (which implicitly includes their attributes via the backend DTO)
      const eventVendorsResponse = selectedEventId
        ? await apiClient.get<VendorDto[]>(
            `/api/events/${selectedEventId}/vendors`
          )
        : { data: [] as VendorDto[] };

      setEventVendors(eventVendorsResponse.data);
    } catch (err) {
      console.error("Failed to fetch event vendor data:", err);
    }
  }, [selectedEventId]);
  // --------------------------------------------------------

  const forceDashboardRefresh = () => {
    setDashboardKey((prev) => prev + 1);
    fetchAuxiliaryData(); // Refetch vendor data when related tables change
  };

  const fetchEvents = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiClient.get<EventDto[]>("/api/events");
      setEvents(response.data);
    } catch (err: unknown) {
      console.error(err);
      setError("Failed to fetch events.");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchEvents();
  }, []);

  // --- PHASE 29: Refetch auxiliary data when event ID changes ---
  useEffect(() => {
    if (selectedEventId) {
      fetchAuxiliaryData();
    } else {
      setEventVendors([]);
    }
  }, [selectedEventId, fetchAuxiliaryData]);
  // -------------------------------------------------------------

  const handleDelete = async (id: string) => {
    if (!window.confirm("Are you sure you want to delete this event?")) return;
    try {
      await apiClient.delete(`/api/events/${id}`);
      setSelectedEventId(null);
      await fetchEvents();
    } catch (err) {
      console.error(err);
      alert("Failed to delete event.");
    }
  };

  const handleEdit = (event: EventDto) => {
    setEditingId(event.id);
    setFormData({
      ...event,
      startDateTime: event.startDateTime.slice(0, 16),
      endDateTime: event.endDateTime.slice(0, 16),
    });
    setValidationErrors({});
    window.scrollTo(0, 0);
  };

  const handleCancel = () => {
    setEditingId(null);
    setFormData(initialFormState);
    setValidationErrors({});
  };

  const handleChange = (
    e: React.ChangeEvent<
      HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement
    >
  ) => {
    const { name, value, type } = e.target;
    if (type === "checkbox") {
      setFormData((prev) => ({
        ...prev,
        [name]: (e.target as HTMLInputElement).checked,
      }));
    } else {
      setFormData((prev) => ({
        ...prev,
        [name]: value === "" ? null : value,
      }));
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setValidationErrors({});

    const payload = {
      ...formData,
      startDateTime: formData.startDateTime
        ? new Date(formData.startDateTime).toISOString()
        : "",
      endDateTime: formData.endDateTime
        ? new Date(formData.endDateTime).toISOString()
        : "",
    };
    const promise = isEditing
      ? apiClient.put(`/api/events/${editingId}`, payload)
      : apiClient.post("/api/events", payload);

    try {
      await promise;
      handleCancel();
      setSelectedEventId(null);
      await fetchEvents();
    } catch (err: unknown) {
      if (axios.isAxiosError(err) && err.response?.status === 400) {
        setValidationErrors(
          err.response.data.errors || { General: ["Validation Error"] }
        );
      } else {
        console.error(err);
        alert("An unexpected error occurred.");
      }
    }
  };

  const handleRowClick = (eventId: string) => {
    if (selectedEventId === eventId) {
      setSelectedEventId(null);
    } else {
      setSelectedEventId(eventId);
    }
    // The key update forces the entire dashboard section to remount.
    setDashboardKey((prev) => prev + 1);
  };

  if (error) return <p style={{ color: "red" }}>{error}</p>;

  return (
    <div>
      <div
        style={{
          marginBottom: "2rem",
          padding: "1rem",
          border: "1px solid #555",
        }}>
        <h2>{isEditing ? "Edit Event" : "Create Event"}</h2>
        <form onSubmit={handleSubmit}>
          {/* ... (Form fields remain the same) ... */}
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Name: </label>
            <input
              name="name"
              value={formData.name ?? ""}
              onChange={handleChange}
            />
            {validationErrors.Name && (
              <div style={{ color: "red" }}>{validationErrors.Name[0]}</div>
            )}
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Description: </label>
            <textarea
              name="description"
              value={formData.description ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Start Time: </label>
            <input
              name="startDateTime"
              type="datetime-local"
              value={formData.startDateTime ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>End Time: </label>
            <input
              name="endDateTime"
              type="datetime-local"
              value={formData.endDateTime ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Location: </label>
            <input
              name="location"
              value={formData.location ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Status: </label>
            <select
              name="status"
              value={formData.status ?? "Planned"}
              onChange={handleChange}>
              <option value="Planned">Planned</option>
              <option value="Confirmed">Confirmed</option>
              <option value="Cancelled">Cancelled</option>
            </select>
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>
              <input
                name="isPublic"
                type="checkbox"
                checked={formData.isPublic ?? false}
                onChange={handleChange}
              />
              Is Public
            </label>
          </div>

          <button type="submit">{isEditing ? "Save Changes" : "Create"}</button>
          {isEditing && (
            <button
              type="button"
              onClick={handleCancel}
              style={{ marginLeft: "0.5rem" }}>
              Cancel
            </button>
          )}
          {validationErrors.General && (
            <div style={{ color: "red", marginTop: "1rem" }}>
              {validationErrors.General[0]}
            </div>
          )}
        </form>
      </div>

      <h2>Events List (Click a row for related data)</h2>
      {loading ? (
        <p>Loading Events...</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Name</th>
              <th>Status</th>
              <th>Start</th>
              <th>End</th>
              <th>Location</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {events.map((event) => (
              <tr
                key={event.id}
                onClick={() => handleRowClick(event.id)}
                style={{
                  cursor: "pointer",
                  backgroundColor:
                    event.id === selectedEventId ? "#444" : "inherit",
                }}>
                <td>{event.id}</td>
                <td>{event.name}</td>
                <td>{event.status}</td>
                <td>{new Date(event.startDateTime).toLocaleString()}</td>
                <td>{new Date(event.endDateTime).toLocaleString()}</td>
                <td>{event.location ?? "N/A"}</td>
                <td>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      handleEdit(event);
                    }}
                    style={{ color: "blue" }}>
                    Edit
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      handleDelete(event.id);
                    }}
                    style={{ color: "red", marginLeft: "0.5rem" }}>
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}

      {/* --- DASHBOARD --- */}
      {selectedEventId && (
        <div
          key={dashboardKey}
          style={{
            borderTop: "2px solid #555",
            marginTop: "3rem",
            paddingTop: "1rem",
          }}>
          <h2 style={{ marginBottom: "2rem" }}>
            Dashboard: Event ID {selectedEventId}
          </h2>

          {/* --- PHASE 29: DISPLAY VENDOR ATTRIBUTES --- */}
          <EventVendorAttributesDisplay eventVendors={eventVendors} />
          {/* --------------------------------------------- */}

          {/* 1. Financials (High Priority) */}
          <div style={{ marginBottom: "3rem" }}>
            <FinancialsSection
              eventId={selectedEventId}
              refreshKey={dashboardKey}
            />
          </div>

          <hr style={{ margin: "2rem 0", borderColor: "#ccc" }} />

          {/* 2. Contacts & Documents */}
          <div
            style={{
              display: "grid",
              gridTemplateColumns: "1fr 1fr",
              gap: "2rem",
            }}>
            <div>
              <ContactLinker
                eventId={selectedEventId}
                onLinkSuccess={forceDashboardRefresh}
              />
              <EventParticipantsTable onUnlinkSuccess={forceDashboardRefresh} />
            </div>
            <div>
              <DocumentsSection entityId={selectedEventId} entityType="Event" />
            </div>
          </div>

          <hr style={{ margin: "2rem 0", borderColor: "#ccc" }} />

          {/* 3. Operational (Tasks & Notes) */}
          <RelatedTasks />
          <RelatedNotes />
        </div>
      )}
    </div>
  );
}

export default EventsPage;


// ==========================================
// FILE: frontend_harness/src/components/SendEmailModal.tsx 
// ==========================================
// FILE: frontend_harness/src/components/SendEmailModal.tsx

import React, { useState, useEffect } from "react";
import { templates, scheduleEmail } from "../apiClient";
import type { TemplateDto, ContactDto, VendorDto } from "../types";
import {
  RecipientType,
  TemplateType,
  LeadStage,
  ConnectionStatus,
} from "../types";
import axios from "axios";

// --- HELPER: Vendor -> ContactDto Transformer ---
const mapVendorToContact = (vendor: VendorDto): ContactDto => {
  return {
    id: vendor.id,
    firstName: vendor.name,
    lastName: null,
    email: vendor.email || "",
    phoneNumber: vendor.phoneNumber,
    organization: vendor.serviceType,
    title: "Vendor",
    stage: LeadStage.NewLead,
    connectionStatus: ConnectionStatus.Unknown,
    isLead: false,
    followUpCount: 0,
    lastContactedAt: null,
    source: "Vendor List",
    role: "Vendor",
  };
};

interface SendEmailModalProps {
  isOpen: boolean;
  onClose: () => void;
  availableContacts: ContactDto[];
  availableVendors: VendorDto[];
}

export const SendEmailModal: React.FC<SendEmailModalProps> = ({
  isOpen,
  onClose,
  availableContacts,
  availableVendors,
}) => {
  const [templateList, setTemplateList] = useState<TemplateDto[]>([]);
  const [selectedTemplateId, setSelectedTemplateId] = useState<string>("");
  const [selectedRecipientId, setSelectedRecipientId] = useState<string>("");
  const [recipientType, setRecipientType] = useState<RecipientType>(
    RecipientType.Contact
  );
  const [scheduleTime, setScheduleTime] = useState<string>("");
  const [isSending, setIsSending] = useState(false);

  useEffect(() => {
    if (isOpen) {
      loadTemplates();
      setSelectedTemplateId("");
      setSelectedRecipientId("");
      setScheduleTime("");
      setRecipientType(RecipientType.Contact);
    }
  }, [isOpen]);

  const loadTemplates = async () => {
    try {
      const data = await templates.getAll();
      setTemplateList(data);
    } catch (error) {
      console.error("Failed to load templates", error);
    }
  };

  const handleSend = async () => {
    if (!selectedTemplateId || !selectedRecipientId) return;

    // 1. Find Template
    const selectedTemplate = templateList.find(
      (t) => t.id === selectedTemplateId
    );
    if (!selectedTemplate) {
      alert("Selected template data not found.");
      return;
    }

    // 2. Prepare Contact Payload
    let contactPayload: ContactDto;

    if (recipientType === RecipientType.Contact) {
      const contact = availableContacts.find(
        (c) => c.id === selectedRecipientId
      );
      if (!contact) {
        alert("Contact not found");
        return;
      }
      contactPayload = contact;
    } else {
      const vendor = availableVendors.find((v) => v.id === selectedRecipientId);
      if (!vendor) {
        alert("Vendor not found");
        return;
      }
      contactPayload = mapVendorToContact(vendor);
    }

    // 3. Time Safety Check (60s buffer)
    const safeScheduleTime =
      scheduleTime || new Date(Date.now() + 60 * 1000).toISOString();

    // 4. Send
    setIsSending(true);
    try {
      await scheduleEmail({
        contact: contactPayload,
        templateId: selectedTemplateId,
        templateContent: selectedTemplate.content || "", // FIXED: Renamed to templateContent
        subject: selectedTemplate.subject || "New Message",
        scheduleTime: safeScheduleTime,
      });

      alert("Email scheduled successfully!");
      onClose();
    } catch (error: unknown) {
      console.error("Failed to schedule email", error);

      let errorMessage = "Check console for details.";
      if (
        axios.isAxiosError(error) &&
        error.response?.data?.errors?.[0]?.ErrorMessage
      ) {
        errorMessage = error.response.data.errors[0].ErrorMessage;
      }

      alert(`Failed to send email: ${errorMessage}`);
    } finally {
      setIsSending(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 backdrop-blur-sm">
      <div className="bg-gray-900 border border-gray-700 p-6 rounded-xl shadow-2xl w-full max-w-md text-gray-100">
        <div className="flex justify-between items-center mb-6">
          <h2 className="text-xl font-bold text-white">Send Communication</h2>
          <button onClick={onClose} className="text-gray-400 hover:text-white">
            âœ•
          </button>
        </div>

        {/* Template Selector */}
        <div className="mb-5">
          <label className="block text-xs font-bold text-gray-400 uppercase mb-2">
            Select Template
          </label>
          <select
            className="w-full bg-gray-800 border border-gray-600 p-3 rounded-lg text-white focus:ring-2 focus:ring-blue-500 outline-none"
            value={selectedTemplateId}
            onChange={(e) => setSelectedTemplateId(e.target.value)}>
            <option value="">-- Choose a Template --</option>
            {templateList.map((t) => (
              <option key={t.id} value={t.id}>
                {t.name} ({t.type === TemplateType.Email ? "Email" : "SMS"})
              </option>
            ))}
          </select>
        </div>

        {/* Recipient Type Toggle */}
        <div className="mb-4 bg-gray-800 p-1 rounded-lg flex">
          <button
            onClick={() => {
              setRecipientType(RecipientType.Contact);
              setSelectedRecipientId("");
            }}
            className={`flex-1 py-2 rounded-md text-sm font-medium transition-all ${
              recipientType === RecipientType.Contact
                ? "bg-blue-600 text-white shadow"
                : "text-gray-400 hover:text-white"
            }`}>
            Contact
          </button>
          <button
            onClick={() => {
              setRecipientType(RecipientType.Vendor);
              setSelectedRecipientId("");
            }}
            className={`flex-1 py-2 rounded-md text-sm font-medium transition-all ${
              recipientType === RecipientType.Vendor
                ? "bg-purple-600 text-white shadow"
                : "text-gray-400 hover:text-white"
            }`}>
            Vendor
          </button>
        </div>

        {/* Recipient Selector */}
        <div className="mb-5">
          <label className="block text-xs font-bold text-gray-400 uppercase mb-2">
            Select{" "}
            {recipientType === RecipientType.Contact ? "Contact" : "Vendor"}
          </label>
          <select
            className="w-full bg-gray-800 border border-gray-600 p-3 rounded-lg text-white focus:ring-2 focus:ring-blue-500 outline-none"
            value={selectedRecipientId}
            onChange={(e) => setSelectedRecipientId(e.target.value)}>
            <option value="">-- Choose Recipient --</option>
            {recipientType === RecipientType.Contact
              ? availableContacts.map((c) => (
                  <option key={c.id} value={c.id}>
                    {c.firstName} {c.lastName}
                  </option>
                ))
              : availableVendors.map((v) => (
                  <option key={v.id} value={v.id}>
                    {v.name} ({v.serviceType})
                  </option>
                ))}
          </select>
        </div>

        {/* Schedule Time */}
        <div className="mb-6">
          <label className="block text-xs font-bold text-gray-400 uppercase mb-2">
            Send At (Optional)
          </label>
          <input
            type="datetime-local"
            className="w-full bg-gray-800 border border-gray-600 p-3 rounded-lg text-white focus:ring-2 focus:ring-blue-500 outline-none"
            value={scheduleTime}
            onChange={(e) => setScheduleTime(e.target.value)}
          />
          <p className="text-xs text-gray-500 mt-1">
            Leave blank to send immediately (Autosets to +1 min).
          </p>
        </div>

        {/* Action Buttons */}
        <div className="flex gap-3 pt-2">
          <button
            onClick={onClose}
            className="flex-1 py-3 bg-gray-800 text-gray-300 hover:bg-gray-700 rounded-lg font-medium transition-colors">
            Cancel
          </button>
          <button
            onClick={handleSend}
            disabled={isSending || !selectedTemplateId || !selectedRecipientId}
            className="flex-1 py-3 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-500 hover:to-indigo-500 text-white rounded-lg font-bold shadow-lg disabled:opacity-50 disabled:cursor-not-allowed transition-all">
            {isSending ? "Confirm & Send" : "Confirm & Send"}
          </button>
        </div>
      </div>
    </div>
  );
};


// ==========================================
// FILE: frontend_harness/src/components/FileUploader.tsx 
// ==========================================
import React, { useState } from "react";
import axios from "axios";
import { uploadDocument } from "../apiClient";
import type { Document } from "../types"; // Fix: Type-only import

interface FileUploaderProps {
  relatedEntityId: string;
  relatedEntityType: "Event" | "Vendor" | "Contact" | "Task";
  onUploadSuccess?: (document: Document) => void;
}

// Hardcoded categories for The Librarian
const DOCUMENT_CATEGORIES = [
  "General",
  "Invoice",
  "Contract",
  "Rider",
  "Marketing",
  "Legal",
];

export const FileUploader: React.FC<FileUploaderProps> = ({
  relatedEntityId,
  relatedEntityType,
  onUploadSuccess,
}) => {
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [category, setCategory] = useState<string>("General"); // Default category

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files || e.target.files.length === 0) return;

    const file = e.target.files[0];
    await handleUpload(file);
  };

  const handleUpload = async (file: File) => {
    setIsUploading(true);
    setError(null);

    try {
      // Pass the selected category to the API
      const result = await uploadDocument(
        file,
        relatedEntityId,
        relatedEntityType,
        category
      );
      if (onUploadSuccess) {
        onUploadSuccess(result);
      }
    } catch (err) {
      console.error(err);

      let errorMessage = "Failed to upload file.";

      if (axios.isAxiosError(err) && err.response?.data) {
        const data = err.response.data;
        if (typeof data === "string") {
          errorMessage = data;
        } else if (typeof data === "object") {
          if (data.message) {
            errorMessage = data.message;
            if (data.details) errorMessage += ` (${data.details})`;
          } else if (data.title) {
            errorMessage = data.title;
          } else if (data.errors) {
            errorMessage = Object.values(data.errors).flat().join(", ");
          }
        }
      } else if (err instanceof Error) {
        errorMessage = err.message;
      }

      setError(errorMessage);
    } finally {
      setIsUploading(false);
    }
  };

  return (
    <div className="p-4 border-2 border-dashed border-gray-300 rounded-lg bg-gray-50 text-center hover:bg-gray-100 transition-colors">
      {/* Category Selector */}
      <div
        style={{
          marginBottom: "1rem",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          gap: "10px",
        }}>
        <label style={{ fontSize: "0.9rem", fontWeight: "600", color: "#555" }}>
          Document Type:
        </label>
        <select
          value={category}
          onChange={(e) => setCategory(e.target.value)}
          disabled={isUploading}
          style={{
            padding: "5px 10px",
            borderRadius: "4px",
            border: "1px solid #ccc",
            fontSize: "0.9rem",
            backgroundColor: "white",
            color: "#333",
          }}>
          {DOCUMENT_CATEGORIES.map((cat) => (
            <option key={cat} value={cat}>
              {cat}
            </option>
          ))}
        </select>
      </div>

      <input
        type="file"
        id={`file-upload-${relatedEntityId}`}
        className="hidden"
        onChange={handleFileChange}
        disabled={isUploading}
      />
      <label
        htmlFor={`file-upload-${relatedEntityId}`}
        className="cursor-pointer flex flex-col items-center justify-center">
        {isUploading ? (
          <span className="text-blue-600 font-semibold">Uploading...</span>
        ) : (
          <>
            <span className="text-gray-700 font-medium">
              Click to Upload Document
            </span>
            <span className="text-xs text-gray-500 mt-1">
              (PDF, DOCX, PNG, JPG)
            </span>
          </>
        )}
      </label>

      {error && (
        <div
          style={{
            color: "red",
            marginTop: "10px",
            fontSize: "0.85rem",
            maxHeight: "100px",
            overflowY: "auto",
            textAlign: "left",
            padding: "5px",
            background: "#fff0f0",
            border: "1px solid #ffcccc",
          }}>
          <strong>Error:</strong> {error}
        </div>
      )}
    </div>
  );
};


// ==========================================
// FILE: frontend_harness/src/components/DocumentsSection.tsx 
// ==========================================
import React, { useEffect, useState } from "react";
import { apiClient, deleteDocument } from "../apiClient";
import type { Document } from "../types";
import { FileUploader } from "./FileUploader";

interface DocumentsSectionProps {
  entityId: string;
  entityType: "Event" | "Vendor" | "Contact" | "Task"; // Reusable!
}

export const DocumentsSection: React.FC<DocumentsSectionProps> = ({
  entityId,
  entityType,
}) => {
  const [documents, setDocuments] = useState<Document[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchDocuments = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<Document[]>("/api/documents", {
          params: { relatedEntityId: entityId, relatedEntityType: entityType },
        });
        setDocuments(response.data);
      } catch (err) {
        console.error("Failed to load documents", err);
      } finally {
        setLoading(false);
      }
    };

    if (entityId) fetchDocuments();
  }, [entityId, entityType]);

  const handleUploadSuccess = (newDoc: Document) => {
    setDocuments((prev) => [newDoc, ...prev]);
  };

  const handleDeleteDocument = async (id: number) => {
    if (
      !window.confirm(
        "Are you sure you want to permanently delete this document?"
      )
    )
      return;

    try {
      await deleteDocument(id);
      setDocuments((prev) => prev.filter((doc) => doc.id !== id));
    } catch (err) {
      console.error("Failed to delete document", err);
      alert("Failed to delete document.");
    }
  };

  const formatFileSize = (bytes: number) => {
    if (bytes === 0) return "0 Bytes";
    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  };

  // Helper for Category Badges
  const getCategoryColor = (cat: string) => {
    switch (cat) {
      case "Invoice":
        return "#e0f2fe"; // Light Blue
      case "Contract":
        return "#fce7f3"; // Pink
      case "Legal":
        return "#fee2e2"; // Red
      case "Marketing":
        return "#dcfce7"; // Green
      default:
        return "#f3f4f6"; // Grey
    }
  };

  const getCategoryTextColor = (cat: string) => {
    switch (cat) {
      case "Invoice":
        return "#0369a1";
      case "Contract":
        return "#be185d";
      case "Legal":
        return "#b91c1c";
      case "Marketing":
        return "#15803d";
      default:
        return "#374151";
    }
  };

  return (
    <div
      style={{
        border: "1px solid #ddd",
        borderRadius: "8px",
        padding: "1.5rem",
        marginTop: "2rem",
        backgroundColor: "#ffffff",
        color: "#333",
        boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
      }}>
      <h3
        style={{
          borderBottom: "2px solid #eee",
          paddingBottom: "0.5rem",
          marginBottom: "1rem",
          color: "#222",
        }}>
        {entityType} Documents
      </h3>

      <div style={{ marginBottom: "1.5rem" }}>
        <FileUploader
          relatedEntityId={entityId}
          relatedEntityType={entityType}
          onUploadSuccess={handleUploadSuccess}
        />
      </div>

      {loading ? (
        <p style={{ color: "#666" }}>Loading documents...</p>
      ) : documents.length === 0 ? (
        <div
          style={{
            textAlign: "center",
            padding: "2rem",
            backgroundColor: "#f9fafb",
            borderRadius: "6px",
            border: "1px dashed #ccc",
            color: "#666",
          }}>
          No documents archived.
        </div>
      ) : (
        <div style={{ overflowX: "auto" }}>
          <table
            style={{
              width: "100%",
              borderCollapse: "collapse",
              fontSize: "0.95rem",
            }}>
            <thead>
              <tr
                style={{
                  backgroundColor: "#374151",
                  color: "#ffffff",
                  textAlign: "left",
                }}>
                <th style={{ padding: "12px", borderTopLeftRadius: "6px" }}>
                  File Name
                </th>
                <th style={{ padding: "12px" }}>Category</th> {/* NEW COLUMN */}
                <th style={{ padding: "12px" }}>Size</th>
                <th style={{ padding: "12px" }}>Uploaded</th>
                <th style={{ padding: "12px", borderTopRightRadius: "6px" }}>
                  Action
                </th>
              </tr>
            </thead>
            <tbody>
              {documents.map((doc, index) => (
                <tr
                  key={doc.id}
                  style={{
                    borderBottom: "1px solid #eee",
                    backgroundColor: index % 2 === 0 ? "#fff" : "#f8f9fa",
                  }}>
                  <td
                    style={{
                      padding: "12px",
                      color: "#333",
                      fontWeight: "500",
                    }}>
                    {doc.fileName}
                  </td>
                  <td style={{ padding: "12px" }}>
                    <span
                      style={{
                        backgroundColor: getCategoryColor(doc.category),
                        color: getCategoryTextColor(doc.category),
                        padding: "4px 8px",
                        borderRadius: "12px",
                        fontSize: "0.8rem",
                        fontWeight: "600",
                      }}>
                      {doc.category || "General"}
                    </span>
                  </td>
                  <td style={{ padding: "12px", color: "#555" }}>
                    {formatFileSize(doc.size)}
                  </td>
                  <td style={{ padding: "12px", color: "#555" }}>
                    {new Date(doc.uploadedAt).toLocaleDateString()}
                  </td>
                  <td style={{ padding: "12px" }}>
                    <a
                      href={`http://localhost:5179${doc.url}`}
                      target="_blank"
                      rel="noreferrer"
                      style={{
                        color: "#2563eb",
                        fontWeight: "600",
                        textDecoration: "none",
                        marginRight: "10px",
                      }}>
                      Download
                    </a>
                    <button
                      onClick={() => handleDeleteDocument(doc.id)}
                      style={{
                        color: "#dc2626",
                        fontWeight: "600",
                        background: "none",
                        border: "none",
                        cursor: "pointer",
                      }}>
                      Delete
                    </button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );
};


// ==========================================
// FILE: frontend_harness/src/components/VendorsPage.tsx 
// ==========================================
// FILE: frontend_harness/src/components/VendorsPage.tsx

import React, { useEffect, useState, useCallback, useRef } from "react";
import { apiClient } from "../apiClient";
import type { VendorDto, Guid } from "../types";
import axios from "axios";
import { useSelectionContext } from "../context/useSelectionContext";
import { RelatedTasks, RelatedNotes } from "./RelatedTables";
import VendorEventsTable from "./VendorEventsTable";
import { DocumentsSection } from "./DocumentsSection"; // NEW: The Reusable Component

type VendorFormData = Omit<VendorDto, "id">;
type ValidationErrors = { [key: string]: string[] };

const initialFormState: VendorFormData = {
  name: "",
  phoneNumber: null,
  email: null,
  serviceType: "Other",
  attributes: null, // NEW: Include attributes
};

function VendorsPage() {
  const [vendors, setVendors] = useState<VendorDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const { selectedVendorId, setSelectedVendorId } = useSelectionContext();

  const selectedVendorIdRef = useRef(selectedVendorId);
  useEffect(() => {
    selectedVendorIdRef.current = selectedVendorId;
  }, [selectedVendorId]);

  const [formData, setFormData] =
    useState<Partial<VendorDto>>(initialFormState);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<ValidationErrors>(
    {}
  );

  // --- NEW: Dynamic Attribute State ---
  const [dynamicFields, setDynamicFields] = useState<{
    Capacity?: number | string;
    Genre?: string;
  }>({});

  const isEditing = editingId !== null;
  const selectedVendor = vendors.find((v) => v.id === selectedVendorId);

  // Function to initialize dynamic fields from the current formData.attributes
  const initializeDynamicFields = useCallback(
    (attributesString: string | null) => {
      if (!attributesString) {
        setDynamicFields({});
        return;
      }
      try {
        const parsed = JSON.parse(attributesString);
        // Set the dynamic fields, ensuring Capacity is handled as a number/string
        setDynamicFields({
          Capacity: parsed.Capacity || "",
          Genre: parsed.Genre || "",
        });
      } catch (e) {
        console.error("Failed to parse vendor attributes JSON:", e);
        setDynamicFields({});
      }
    },
    []
  );

  const fetchVendors = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiClient.get<VendorDto[]>("/api/vendors");
      setVendors(response.data);
      return response.data;
    } catch (err: unknown) {
      console.error(err);
      setError("Failed to fetch vendors.");
      return [];
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    let mounted = true;

    fetchVendors().then((data) => {
      if (mounted && data && data.length > 0 && !selectedVendorIdRef.current) {
        setSelectedVendorId(data[0].id);
      }
    });

    return () => {
      mounted = false;
      setSelectedVendorId(null);
    };
  }, [fetchVendors, setSelectedVendorId]);

  const handleDelete = async (id: string) => {
    if (!window.confirm("Are you sure you want to delete this vendor?")) return;
    try {
      await apiClient.delete(`/api/vendors/${id}`);
      if (selectedVendorId === id) {
        setSelectedVendorId(null);
      }
      await fetchVendors();
    } catch (err) {
      console.error(err);
      alert("Failed to delete vendor.");
    }
  };

  const handleEdit = (vendor: VendorDto) => {
    setEditingId(vendor.id);
    setFormData(vendor);
    initializeDynamicFields(vendor.attributes); // Initialize dynamic fields when editing
    setValidationErrors({});
    window.scrollTo(0, 0);
  };

  const handleCancel = () => {
    setEditingId(null);
    setFormData(initialFormState);
    setDynamicFields({}); // Clear dynamic fields
    setValidationErrors({});
  };

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>
  ) => {
    const { name, value } = e.target;
    // When ServiceType changes, reset the dynamic fields state
    if (name === "serviceType") {
      setDynamicFields({});
    }

    setFormData((prev) => ({
      ...prev,
      [name]: value === "" ? null : value,
    }));
  };

  // NEW: Handle changes for dynamic fields separately
  const handleDynamicChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setDynamicFields((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  const getAttributesJson = () => {
    const cleanFields = Object.entries(dynamicFields)
      .filter(([, value]) => value !== null && value !== "" && value !== 0)
      .reduce((acc, [key, value]) => {
        // Attempt to parse number fields back to number types for cleaner JSON
        if (
          key === "Capacity" &&
          typeof value === "string" &&
          !isNaN(Number(value))
        ) {
          acc[key] = Number(value);
        } else {
          acc[key] = value;
        }
        return acc;
      }, {} as Record<string, string | number>);

    if (Object.keys(cleanFields).length === 0) {
      return null;
    }
    return JSON.stringify(cleanFields);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setValidationErrors({});

    // --- PHASE 27: Inject serialized attributes into payload ---
    const attributesJson = getAttributesJson();

    const payload = {
      ...formData,
      name: formData.name ?? "",
      serviceType: formData.serviceType ?? "Other",
      attributes: attributesJson, // INJECT THE JSON STRING
    };
    // -------------------------------------------------------------

    const promise = isEditing
      ? apiClient.put(`/api/vendors/${editingId}`, payload)
      : apiClient.post("/api/vendors", payload);

    try {
      await promise;
      handleCancel();
      await fetchVendors();
    } catch (err: unknown) {
      if (axios.isAxiosError(err) && err.response?.status === 400) {
        setValidationErrors(
          err.response.data.errors || { General: ["Validation Error"] }
        );
      } else {
        console.error(err);
        alert("An unexpected error occurred.");
      }
    }
  };

  if (error) return <p style={{ color: "red" }}>{error}</p>;

  // --- NEW: Dynamic Field Renderer ---
  const renderDynamicFields = (serviceType: string | null | undefined) => {
    if (serviceType?.toLowerCase() === "venue") {
      return (
        <div style={{ marginBottom: "0.5rem" }}>
          <label>Venue Capacity: </label>
          <input
            name="Capacity"
            type="number"
            value={dynamicFields.Capacity ?? ""}
            onChange={handleDynamicChange}
            placeholder="Max Capacity (e.g., 500)"
            style={{
              width: "100%",
              padding: "8px",
              backgroundColor: "#333",
              color: "white",
              border: "1px solid #555",
            }}
          />
        </div>
      );
    }
    if (serviceType?.toLowerCase() === "entertainment") {
      return (
        <div style={{ marginBottom: "0.5rem" }}>
          <label>Artist Genre: </label>
          <input
            name="Genre"
            type="text"
            value={dynamicFields.Genre ?? ""}
            onChange={handleDynamicChange}
            placeholder="e.g., Jazz, EDM, Acoustic"
            style={{
              width: "100%",
              padding: "8px",
              backgroundColor: "#333",
              color: "white",
              border: "1px solid #555",
            }}
          />
        </div>
      );
    }
    return null;
  };

  const renderVendorListPanel = () => (
    <div
      style={{
        flex: "0 0 350px",
        padding: "1rem",
        borderRight: "1px solid #555",
        overflowY: "auto",
      }}>
      <h2>Vendors List</h2>
      <button
        onClick={() => {
          setEditingId(null);
          setFormData(initialFormState);
          setDynamicFields({}); // Ensure state is reset
          setSelectedVendorId(null);
        }}
        style={{ marginBottom: "1rem", padding: "10px" }}>
        + Add New Vendor
      </button>

      {loading ? (
        <p>Loading Vendors...</p>
      ) : (
        <ul style={{ listStyle: "none", padding: 0 }}>
          {vendors.map((vendor) => (
            <li
              key={vendor.id}
              onClick={() => setSelectedVendorId(vendor.id as Guid)}
              style={{
                padding: "10px",
                marginBottom: "5px",
                cursor: "pointer",
                border: "1px solid #555",
                backgroundColor:
                  vendor.id === selectedVendorId ? "#444" : "#2a2a2a",
                borderRadius: "4px",
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                color: "white",
              }}>
              <div>
                <strong>{vendor.name}</strong> <br />
                <span style={{ fontSize: "0.8rem", color: "#ccc" }}>
                  {vendor.serviceType}
                  {/* NEW: Display a dynamic attribute if present */}
                  {vendor.attributes &&
                    (() => {
                      try {
                        const attrs = JSON.parse(vendor.attributes);
                        if (attrs.Capacity)
                          return ` | Capacity: ${attrs.Capacity}`;
                        if (attrs.Genre) return ` | Genre: ${attrs.Genre}`;
                        return null;
                      } catch {
                        return null; // Ignore invalid JSON
                      }
                    })()}
                </span>
              </div>
              <div style={{ fontSize: "0.8rem" }}>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    handleEdit(vendor);
                  }}
                  style={{
                    color: "#64b5f6",
                    marginRight: "5px",
                    padding: "2px 5px",
                    background: "transparent",
                    border: "none",
                    cursor: "pointer",
                  }}>
                  Edit
                </button>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    handleDelete(vendor.id as Guid);
                  }}
                  style={{
                    color: "#ef5350",
                    padding: "2px 5px",
                    background: "transparent",
                    border: "none",
                    cursor: "pointer",
                  }}>
                  Delete
                </button>
              </div>
            </li>
          ))}
        </ul>
      )}
    </div>
  );

  const renderVendorDashboard = () => {
    if (isEditing || !selectedVendorId) {
      return (
        <div style={{ flex: 1, padding: "20px", overflowY: "auto" }}>
          <div
            style={{
              padding: "1rem",
              border: "1px solid #555",
              width: "100%",
            }}>
            <h2>
              {isEditing
                ? `Edit Vendor: ${selectedVendor?.name}`
                : "Create New Vendor"}
            </h2>
            <form onSubmit={handleSubmit}>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Name: </label>
                <input
                  name="name"
                  value={formData.name ?? ""}
                  onChange={handleChange}
                  style={{
                    width: "100%",
                    padding: "8px",
                    backgroundColor: "#333",
                    color: "white",
                    border: "1px solid #555",
                  }}
                />
                {validationErrors.Name && (
                  <div style={{ color: "#ef5350" }}>
                    {validationErrors.Name[0]}
                  </div>
                )}
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Email: </label>
                <input
                  name="email"
                  type="email"
                  value={formData.email ?? ""}
                  onChange={handleChange}
                  style={{
                    width: "100%",
                    padding: "8px",
                    backgroundColor: "#333",
                    color: "white",
                    border: "1px solid #555",
                  }}
                />
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Phone Number: </label>
                <input
                  name="phoneNumber"
                  value={formData.phoneNumber ?? ""}
                  onChange={handleChange}
                  style={{
                    width: "100%",
                    padding: "8px",
                    backgroundColor: "#333",
                    color: "white",
                    border: "1px solid #555",
                  }}
                />
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Service Type: </label>
                <select
                  name="serviceType"
                  value={formData.serviceType ?? "Other"}
                  onChange={handleChange}
                  style={{
                    width: "100%",
                    padding: "8px",
                    backgroundColor: "#333",
                    color: "white",
                    border: "1px solid #555",
                  }}>
                  {/* NOTE: Added Entertainment option as a requirement example */}
                  <option value="Catering">Catering</option>
                  <option value="Security">Security</option>
                  <option value="Venue">Venue</option>
                  <option value="Entertainment">Entertainment</option>
                  <option value="Florist">Florist</option>
                  <option value="Photography">Photography</option>
                  <option value="Videography">Videography</option>
                  <option value="Other">Other</option>
                </select>
              </div>

              {/* --- PHASE 27: Dynamic Attribute Fields RENDER HERE --- */}
              {renderDynamicFields(formData.serviceType)}

              {validationErrors.Attributes && (
                <div style={{ color: "#ef5350", marginTop: "0.5rem" }}>
                  {/* Display validation error for the JSON field */}
                  {validationErrors.Attributes[0]}
                </div>
              )}
              {/* -------------------------------------------------------- */}

              <button
                type="submit"
                style={{
                  marginTop: "10px",
                  padding: "10px 20px",
                  cursor: "pointer",
                }}>
                {isEditing ? "Save Changes" : "Create"}
              </button>
              {isEditing && (
                <button
                  type="button"
                  onClick={handleCancel}
                  style={{
                    marginLeft: "0.5rem",
                    marginTop: "10px",
                    padding: "10px 20px",
                    cursor: "pointer",
                  }}>
                  Cancel
                </button>
              )}
              {validationErrors.General && (
                <div style={{ color: "#ef5350", marginTop: "1rem" }}>
                  {validationErrors.General[0]}
                </div>
              )}
            </form>
          </div>
        </div>
      );
    }

    const vendorIdString = selectedVendorId as string;

    // --- PHASE 27: Dashboard View ---
    const parsedAttributes = selectedVendor?.attributes
      ? JSON.parse(selectedVendor.attributes)
      : {};

    const attributeDisplay = Object.entries(parsedAttributes).map(
      ([key, value]) => (
        <p key={key}>
          <strong>{key}:</strong> {value as string}
        </p>
      )
    );

    return (
      <div style={{ flex: 1, padding: "20px", overflowY: "auto" }}>
        <h1>Vendor Command Center: {selectedVendor?.name}</h1>
        <div
          style={{
            marginBottom: "20px",
            padding: "15px",
            border: "1px solid #555",
            borderRadius: "5px",
            width: "100%",
          }}>
          <h3>Details</h3>
          <p>
            <strong>ID:</strong> {selectedVendor?.id}
          </p>
          <p>
            <strong>Type:</strong> {selectedVendor?.serviceType}
          </p>
          <p>
            <strong>Contact Info:</strong> {selectedVendor?.phoneNumber} /{" "}
            {selectedVendor?.email}
          </p>
          {/* NEW: Dynamic Attribute Display */}
          {attributeDisplay.length > 0 && (
            <div
              style={{
                marginTop: "10px",
                borderTop: "1px dashed #666",
                paddingTop: "10px",
              }}>
              <h4>Specific Attributes</h4>
              {attributeDisplay}
            </div>
          )}
        </div>

        <h2 style={{ marginTop: "30px" }}>Related Data</h2>

        {/* NEW: Reusable Documents Section for Vendors */}
        <DocumentsSection entityId={vendorIdString} entityType="Vendor" />

        <VendorEventsTable vendorId={vendorIdString as Guid} />
        <RelatedTasks vendorId={vendorIdString} />
        <RelatedNotes vendorId={vendorIdString} />
      </div>
    );
  };

  return (
    <div style={{ display: "flex", height: "100%", minHeight: "800px" }}>
      {renderVendorListPanel()}
      {renderVendorDashboard()}
    </div>
  );
}

export default VendorsPage;


// ==========================================
// FILE: frontend_harness/src/components/NotesPage.tsx 
// ==========================================
// FILE: frontend_harness/src/components/NotesPage.tsx

import { useState, useEffect, type FormEvent } from "react";
import { apiClient } from "../apiClient";
import { type NoteDto, type CreateNoteDto } from "../types";
import { AxiosError } from "axios";

// Define an explicit type for the data sent in the command,
// including the new lookup fields for clarity
type NoteCommandData = Omit<CreateNoteDto, "vendorName"> & {
  contactEmail?: string;
  eventName?: string;
  vendorName?: string; // This maps to the backend VendorName field in the command
  taskTitle?: string;
};

type UpdateNoteDto = Pick<NoteDto, "id" | "content">;

const NotesPage = () => {
  const [notes, setNotes] = useState<NoteDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Form state for creating a new note
  const initialNewNoteState: Partial<NoteCommandData> = {
    content: "",
    contactId: null,
    eventId: null,
    taskId: null,
    vendorId: null,
    // String lookup fields
    contactEmail: undefined,
    eventName: undefined,
    vendorName: undefined,
    taskTitle: undefined,
  };

  const [newNote, setNewNote] =
    useState<Partial<NoteCommandData>>(initialNewNoteState);

  // State for which note is being edited
  const [editingNote, setEditingNote] = useState<NoteDto | null>(null);

  // --- NEW: PHASE 29 Dynamic Linkage State ---
  const [entityTypeToLink, setEntityTypeToLink] = useState<
    "Contact" | "Event" | "Vendor" | "Task" | null
  >(null);
  const [linkValue, setLinkValue] = useState("");
  // ------------------------------------------

  const fetchNotes = async () => {
    try {
      setLoading(true);
      const response = await apiClient.get<NoteDto[]>("/api/notes");
      setNotes(response.data);
      setError(null);
    } catch (err) {
      setError("Failed to fetch notes.");
      console.error(err);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchNotes();
  }, []);

  // --- PHASE 29: Dynamic Linkage Handlers ---
  const handleEntityTypeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const type = e.target.value as
      | "Contact"
      | "Event"
      | "Vendor"
      | "Task"
      | "None";
    setEntityTypeToLink(type === "None" ? null : type);
    setLinkValue("");
    // Clear all previous link-related fields in newNote state
    setNewNote({
      ...newNote,
      contactId: null,
      eventId: null,
      taskId: null,
      vendorId: null,
      contactEmail: undefined,
      eventName: undefined,
      vendorName: undefined,
      taskTitle: undefined,
    });
  };

  const handleLinkValueChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setLinkValue(e.target.value);
  };

  const getLinkPlaceholder = () => {
    switch (entityTypeToLink) {
      case "Contact":
        return "Contact Email (e.g., jane@example.com)";
      case "Event":
        return "Event Name (e.g., Summer Gala 2026)";
      case "Vendor":
        return "Vendor Name (e.g., The Jazz Trio)";
      case "Task":
        return "Task Title (e.g., Book Venue)";
      default:
        return "Enter Name, Title, or Email";
    }
  };

  // --- PHASE 29: Payload Construction ---
  const constructCreatePayload = (): Partial<NoteCommandData> => {
    const payload: Partial<NoteCommandData> = {
      content: newNote.content,
    };

    if (entityTypeToLink === "Contact" && linkValue) {
      payload.contactEmail = linkValue;
    } else if (entityTypeToLink === "Event" && linkValue) {
      payload.eventName = linkValue;
    } else if (entityTypeToLink === "Vendor" && linkValue) {
      payload.vendorName = linkValue; // Maps to VendorName on backend command
    } else if (entityTypeToLink === "Task" && linkValue) {
      payload.taskTitle = linkValue;
    }
    // If IDs were manually put in (or if no dynamic link is selected,
    // they are sent as null/undefined, which is fine)

    return payload;
  };
  // ------------------------------------------

  const handleCreateSubmit = async (e: FormEvent) => {
    e.preventDefault();

    if (!newNote.content) {
      setError("Content is required.");
      return;
    }

    const payload = constructCreatePayload();

    try {
      // NOTE: We don't map string lookups to GUIDs on the FE. The FE only sends
      // the string values and the BE handler resolves them.
      const response = await apiClient.post<NoteDto>("/api/notes", payload);
      setNotes([response.data, ...notes]);

      setNewNote(initialNewNoteState); // Reset form
      setEntityTypeToLink(null);
      setLinkValue("");

      setError(null);
    } catch (err: unknown) {
      console.error(err);
      if (err instanceof AxiosError && err.response?.data?.errors) {
        // Find the 'Must Have At Least One Link' error and present it clearly
        const validationMessage = Object.values(err.response.data.errors)
          .flat()
          .join(", ");
        setError(
          validationMessage ||
            "Failed to create note. Ensure at least one ID is provided."
        );
      } else {
        setError("Failed to create note. Ensure at least one ID is provided.");
      }
    }
  };

  const handleUpdateSubmit = async (e: FormEvent) => {
    e.preventDefault();
    if (!editingNote) return;

    const updatePayload: UpdateNoteDto = {
      id: editingNote.id,
      content: editingNote.content,
    };
    try {
      await apiClient.put(`/api/notes/${editingNote.id}`, updatePayload);
      setNotes(notes.map((n) => (n.id === editingNote.id ? editingNote : n)));
      setEditingNote(null);
      setError(null);
    } catch (err: unknown) {
      console.error(err);
      setError("Failed to update note.");
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm("Are you sure you want to delete this note?")) {
      try {
        await apiClient.delete(`/api/notes/${id}`);
        setNotes(notes.filter((n) => n.id !== id));
        setError(null);
      } catch (err) {
        setError("Failed to delete note.");
        console.error(err);
      }
    }
  };

  // --- Render Logic ---

  if (loading) return <p>Loading notes...</p>;
  return (
    <div className="module-page">
      <h2>Notes Module</h2>
      {error && (
        <p className="error-message" style={{ color: "red" }}>
          {error}
        </p>
      )}

      {/* --- Create or Edit Form --- */}
      <form onSubmit={editingNote ? handleUpdateSubmit : handleCreateSubmit}>
        <h3>{editingNote ? "Edit Note" : "Create New Note"}</h3>
        <textarea
          placeholder="Note content..."
          value={editingNote ? editingNote.content : newNote.content}
          onChange={(e) =>
            editingNote
              ? setEditingNote({ ...editingNote, content: e.target.value })
              : setNewNote({ ...newNote, content: e.target.value })
          }
        />

        {/* --- Foreign Key Inputs (Dynamic Link for Create) --- */}
        {!editingNote && (
          <fieldset
            style={{
              border: "1px dashed #666",
              padding: "1rem",
              margin: "1rem 0",
            }}>
            <legend style={{ padding: "0 0.5rem" }}>
              Attach Note By ID or Lookup
            </legend>

            {/* Link Type Selector */}
            <div style={{ marginBottom: "0.5rem" }}>
              <label style={{ display: "block" }}>Link Type:</label>
              <select
                value={entityTypeToLink ?? "None"}
                onChange={handleEntityTypeChange}
                style={{ width: "100%", padding: "4px" }}>
                <option value="None">-- Select Entity Type --</option>
                <option value="Contact">Contact (by Email)</option>
                <option value="Event">Event (by Name)</option>
                <option value="Vendor">Vendor (by Name)</option>
                <option value="Task">Task (by Title)</option>
              </select>
            </div>

            {/* Lookup Value Input */}
            {entityTypeToLink && (
              <div style={{ marginBottom: "0.5rem" }}>
                <label style={{ display: "block" }}>Lookup Value:</label>
                <input
                  type={entityTypeToLink === "Contact" ? "email" : "text"}
                  value={linkValue}
                  onChange={handleLinkValueChange}
                  placeholder={getLinkPlaceholder()}
                  style={{ width: "100%" }}
                />
              </div>
            )}

            <p style={{ fontSize: "0.8rem", color: "#aaa", marginTop: "1rem" }}>
              *If you use the dropdown above, only the lookup value is sent. If
              you need to link by GUID, please use the Task/Vendor/Contact
              pages.
            </p>
          </fieldset>
        )}

        <button type="submit">
          {editingNote ? "Update Note" : "Create Note"}
        </button>
        {editingNote && (
          <button type="button" onClick={() => setEditingNote(null)}>
            Cancel Edit
          </button>
        )}
      </form>

      {/* --- Notes Table --- */}
      <h3>Existing Notes</h3>
      <table className="harness-table" style={{ width: "100%" }}>
        <thead>
          <tr>
            <th>ID</th>
            <th>Content</th>
            <th>Contact ID</th>
            <th>Event ID</th>
            <th>Task ID</th>
            <th>Vendor ID</th>
            <th>Vendor Name</th> {/* Granularity */}
            <th>Created At</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {notes.map((note) => (
            <tr key={note.id}>
              <td>{note.id.substring(0, 8)}...</td>
              <td>{note.content.substring(0, 50)}...</td>
              <td>
                {note.contactId
                  ? note.contactId.substring(0, 8) + "..."
                  : "N/A"}
              </td>
              <td>
                {note.eventId ? note.eventId.substring(0, 8) + "..." : "N/A"}
              </td>
              <td>
                {note.taskId ? note.taskId.substring(0, 8) + "..." : "N/A"}
              </td>
              <td>
                {note.vendorId ? note.vendorId.substring(0, 8) + "..." : "N/A"}
              </td>
              <td>{note.vendorName ?? "N/A"}</td>
              <td>{new Date(note.createdAt).toLocaleString()}</td>
              <td>
                <button
                  className="edit-button"
                  onClick={() => setEditingNote(note)}>
                  Edit
                </button>
                <button
                  className="delete-button"
                  onClick={() => handleDelete(note.id)}>
                  Delete
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

export default NotesPage;


// ==========================================
// FILE: frontend_harness/src/components/BudgetOverview.tsx 
// ==========================================
import type { EventFinancials } from "../types";

interface Props {
  data: EventFinancials;
  onEditBudget: () => void;
}

export default function BudgetOverview({ data, onEditBudget }: Props) {
  // Color Logic: Green < 80%, Yellow < 100%, Red >= 100%
  const getProgressColor = () => {
    if (data.burnRate >= 1) return "bg-red-600";
    if (data.burnRate > 0.8) return "bg-yellow-500";
    return "bg-emerald-500";
  };

  const percentage = Math.min(data.burnRate * 100, 100);

  return (
    <div className="p-6 rounded-xl shadow-sm border border-gray-600 bg-[#333] text-white mb-8">
      {/* PHASE 26 ADDITION: BUDGET LOCK STATUS BANNER */}
      {data.isLocked ? (
        <div className="bg-red-900/50 border border-red-700 p-3 rounded-lg flex items-center mb-6">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 20 20"
            fill="currentColor"
            className="w-5 h-5 text-red-400 mr-3">
            <path
              fillRule="evenodd"
              d="M10 1a4.5 4.5 0 0 0-4.5 4.5V9H5a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2h-.5V5.5A4.5 4.5 0 0 0 10 1Zm3 8V5.5a3 3 0 1 0-6 0V9h6Z"
              clipRule="evenodd"
            />
          </svg>
          <span className="text-sm font-medium text-red-300">
            BUDGET LOCKED: Contract Signed. This budget cannot be edited.
          </span>
        </div>
      ) : (
        <div className="bg-emerald-900/50 border border-emerald-700 p-3 rounded-lg flex items-center mb-6">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 20 20"
            fill="currentColor"
            className="w-5 h-5 text-emerald-400 mr-3">
            <path d="M10 1a.75.75 0 0 1 .75.75V3a.75.75 0 1 1-1.5 0V1.75A.75.75 0 0 1 10 1ZM5.5 5.5a.75.75 0 0 0-1.5 0v2.75a.75.75 0 0 0 1.5 0V5.5ZM16 8.25a.75.75 0 0 1 1.5 0v-2.5a.75.75 0 0 1-1.5 0v2.5ZM5.5 12.5a.75.75 0 0 0-1.5 0v2.75a.75.75 0 0 0 1.5 0v-2.75ZM16 14.75a.75.75 0 0 1 1.5 0v-2.5a.75.75 0 0 1-1.5 0v2.5ZM10 6a4 4 0 0 1 4 4v.75c0 1.05.57 2.053 1.5 2.5a.75.75 0 0 1-.6 1.34c-1.288-.574-2.15-1.782-2.3-3.14h-1.3c-.15 1.358-1.012 2.566-2.3 3.14a.75.75 0 0 1-.6-1.34c.93-.447 1.5-1.45 1.5-2.5V10a4 4 0 0 1 4-4Z" />
          </svg>
          <span className="text-sm font-medium text-emerald-300">
            BUDGET UNLOCKED: Ready for updates.
          </span>
        </div>
      )}

      <div className="flex justify-between items-start mb-6">
        <div>
          <h3 className="text-xl font-bold text-white">Budget Overview</h3>
          <p className="text-sm text-gray-400 mt-1">{data.currency} Ledger</p>
        </div>
        <button
          onClick={onEditBudget}
          disabled={data.isLocked} // DISABLES BUTTON WHEN LOCKED
          className={`px-3 py-1 text-sm rounded transition-colors ${
            data.isLocked
              ? "bg-gray-800 text-gray-500 cursor-not-allowed border border-gray-700"
              : "bg-gray-700 hover:bg-gray-600 text-white border border-gray-500"
          }`}>
          {data.isLocked ? "Budget Locked" : "Edit Budget"}
        </button>
      </div>

      {/* Stat Cards */}
      <div className="grid grid-cols-3 gap-6 mb-8">
        <div className="p-4 bg-[#444] rounded-lg border border-gray-600">
          <p className="text-xs text-gray-400 uppercase tracking-wider mb-1">
            Total Budget
          </p>
          <p className="text-2xl font-bold text-white">
            ${data.budgetTotal.toLocaleString()}
          </p>
        </div>
        <div className="p-4 bg-[#444] rounded-lg border border-gray-600">
          <p className="text-xs text-gray-400 uppercase tracking-wider mb-1">
            Spent
          </p>
          <p className="text-2xl font-bold text-white">
            ${data.totalSpent.toLocaleString()}
          </p>
        </div>
        <div className="p-4 bg-[#444] rounded-lg border border-gray-600">
          <p className="text-xs text-gray-400 uppercase tracking-wider mb-1">
            Remaining
          </p>
          <p
            className={`text-2xl font-bold ${
              data.remainingBudget < 0 ? "text-red-400" : "text-emerald-400"
            }`}>
            ${data.remainingBudget.toLocaleString()}
          </p>
        </div>
      </div>

      {/* Progress Bar Section */}
      <div className="relative pt-1">
        <div className="flex mb-2 items-center justify-between text-sm">
          <span className="font-semibold uppercase tracking-wide text-gray-300">
            Burn Rate
          </span>
          <span className="font-bold text-white">
            {Math.round(data.burnRate * 100)}%
          </span>
        </div>
        <div className="overflow-hidden h-3 mb-4 text-xs flex rounded-full bg-gray-700 border border-gray-600">
          <div
            style={{ width: `${percentage}%` }}
            className={`shadow-none flex flex-col text-center whitespace-nowrap text-white justify-center ${getProgressColor()} transition-all duration-500`}></div>
        </div>
      </div>

      {data.notes && (
        <div className="mt-4 text-sm text-gray-400 italic border-l-4 border-gray-500 pl-3">
          "{data.notes}"
        </div>
      )}
    </div>
  );
}


// ==========================================
// FILE: frontend_harness/src/components/TasksPage.tsx 
// ==========================================
// FILE: frontend_harness/src/components/TasksPage.tsx (COMPLETE FILE)

import { useEffect, useState } from "react";
import { apiClient } from "../apiClient";
import type { TaskDto } from "../types";
import axios from "axios";

// Define an explicit type for the data sent in the command,
// including the new lookup fields for clarity
type TaskCommandData = Omit<TaskDto, "id" | "createdAt" | "vendorName"> & {
  contactEmail?: string;
  eventName?: string;
  vendorName?: string; // This maps to the backend VendorName field in the command
};
type ValidationErrors = { [key: string]: string[] };

function TasksPage() {
  const [tasks, setTasks] = useState<TaskDto[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const initialFormState: Partial<TaskCommandData> = {
    title: "",
    description: null,
    status: "NotStarted", // Default enum string
    priority: "Medium", // Default enum string
    dueDate: null,
    // Original GUID fields (cleared for the form but used in DTO)
    contactId: null,
    eventId: null,
    vendorId: null,
    // String lookup fields
    contactEmail: undefined,
    eventName: undefined,
    vendorName: undefined,
  };

  const [formData, setFormData] =
    useState<Partial<TaskCommandData>>(initialFormState);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<ValidationErrors>(
    {}
  );

  // --- NEW: PHASE 29 Dynamic Linkage State ---
  const [entityTypeToLink, setEntityTypeToLink] = useState<
    "Contact" | "Event" | "Vendor" | null
  >(null);
  const [linkValue, setLinkValue] = useState("");
  // ------------------------------------------

  const isEditing = editingId !== null;

  const fetchTasks = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiClient.get<TaskDto[]>("/api/tasks");
      setTasks(response.data);
    } catch (err: unknown) {
      console.error(err);
      setError("Failed to fetch tasks.");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchTasks();
  }, []);

  const handleDelete = async (id: string) => {
    if (!window.confirm("Are you sure you want to delete this task?")) return;
    try {
      await apiClient.delete(`/api/tasks/${id}`);
      await fetchTasks();
    } catch (err) {
      console.error(err);
      alert("Failed to delete task.");
    }
  };

  const handleEdit = (task: TaskDto) => {
    setEditingId(task.id);

    // Clear dynamic link state when editing, as the fields are GUID-based on update
    setEntityTypeToLink(null);
    setLinkValue("");

    // Format date for date input
    setFormData({
      ...task,
      dueDate: task.dueDate ? task.dueDate.slice(0, 10) : null,
      vendorId: task.vendorId ?? null,
      contactId: task.contactId ?? null,
      eventId: task.eventId ?? null,
      // Clear string lookup fields when editing an existing task by ID
      contactEmail: undefined,
      eventName: undefined,
      vendorName: undefined,
    });
    setValidationErrors({});
    window.scrollTo(0, 0);
  };

  const handleCancel = () => {
    setEditingId(null);
    setFormData(initialFormState);
    setEntityTypeToLink(null); // Reset link state
    setLinkValue(""); // Reset link value
    setValidationErrors({});
  };

  const handleChange = (
    e: React.ChangeEvent<
      HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement
    >
  ) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value === "" ? null : value,
    }));
  };

  // --- PHASE 29: Dynamic Linkage Handler ---
  const handleEntityTypeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const type = e.target.value as "Contact" | "Event" | "Vendor" | "None";
    setEntityTypeToLink(type === "None" ? null : type);
    setLinkValue("");
    // Clear all previous link-related fields in formData to prevent conflicts
    setFormData({
      ...formData,
      contactId: null,
      eventId: null,
      vendorId: null,
      contactEmail: undefined,
      eventName: undefined,
      vendorName: undefined,
    });
  };

  const handleLinkValueChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setLinkValue(e.target.value);
  };

  // --- PHASE 29: Payload Construction ---
  const constructPayload = (
    baseData: Partial<TaskCommandData>
  ): TaskCommandData => {
    const payload: Partial<TaskCommandData> = {
      ...baseData,
      description: baseData.description ?? null,
      dueDate: baseData.dueDate ?? null,
    };

    // If we are editing, we submit the GUIDs (contactId, eventId, etc.)
    // already present in formData, and string fields are undefined.
    if (isEditing) {
      return payload as TaskCommandData;
    }

    // If creating, we inject the dynamic linkage values into the string lookup fields.
    // GUID fields are null, string fields hold the lookup value.
    if (entityTypeToLink === "Contact" && linkValue) {
      payload.contactEmail = linkValue;
      payload.contactId = null; // Ensure ID is null
    } else if (entityTypeToLink === "Event" && linkValue) {
      payload.eventName = linkValue;
      payload.eventId = null; // Ensure ID is null
    } else if (entityTypeToLink === "Vendor" && linkValue) {
      payload.vendorName = linkValue; // Maps to VendorName on backend command
      payload.vendorId = null; // Ensure ID is null
    }

    return payload as TaskCommandData;
  };
  // ------------------------------------------

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setValidationErrors({});

    const payload = constructPayload(formData);

    const promise = isEditing
      ? apiClient.put(`/api/tasks/${editingId}`, payload)
      : apiClient.post("/api/tasks", payload);

    try {
      await promise;
      handleCancel();
      await fetchTasks();
    } catch (err: unknown) {
      if (axios.isAxiosError(err) && err.response?.status === 400) {
        setValidationErrors(
          err.response.data.errors || { General: ["Validation Error"] }
        );
      } else {
        console.error(err);
        alert("An unexpected error occurred.");
      }
    }
  };

  if (error) return <p style={{ color: "red" }}>{error}</p>;

  // Helper to determine the placeholder text
  const getLinkPlaceholder = () => {
    switch (entityTypeToLink) {
      case "Contact":
        return "Contact Email (e.g., jane@example.com)";
      case "Event":
        return "Event Name (e.g., Summer Gala 2026)";
      case "Vendor":
        return "Vendor Name (e.g., The Jazz Trio)";
      default:
        return "Enter ID, Name, or Email";
    }
  };

  return (
    <div>
      <div
        style={{
          marginBottom: "2rem",
          padding: "1rem",
          border: "1px solid #555",
        }}>
        <h2>{isEditing ? "Edit Task" : "Create Task"}</h2>
        <form onSubmit={handleSubmit}>
          {/* Form fields */}
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Title: </label>
            <input
              name="title"
              value={formData.title ?? ""}
              onChange={handleChange}
            />
            {validationErrors.Title && (
              <div style={{ color: "red" }}>{validationErrors.Title[0]}</div>
            )}
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Description: </label>
            <textarea
              name="description"
              value={formData.description ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Due Date: </label>
            <input
              name="dueDate"
              type="date"
              value={formData.dueDate ?? ""}
              onChange={handleChange}
            />
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Status: </label>
            <select
              name="status"
              value={formData.status ?? "NotStarted"}
              onChange={handleChange}>
              <option value="NotStarted">Not Started</option>
              <option value="InProgress">In Progress</option>
              <option value="Completed">Completed</option>
            </select>
          </div>
          <div style={{ marginBottom: "0.5rem" }}>
            <label>Priority: </label>
            <select
              name="priority"
              value={formData.priority ?? "Medium"}
              onChange={handleChange}>
              <option value="Low">Low</option>
              <option value="Medium">Medium</option>
              <option value="High">High</option>
            </select>
          </div>

          {/* --- PHASE 29: DYNAMIC LINKING SECTION --- */}
          {!isEditing && (
            <div
              style={{
                margin: "1rem 0",
                padding: "1rem",
                border: "1px dashed #666",
                borderRadius: "4px",
              }}>
              <h4 style={{ marginTop: 0 }}>
                Link Task To: (Name or Email Lookup)
              </h4>
              <div style={{ marginBottom: "0.5rem" }}>
                <label style={{ display: "block" }}>Link Type:</label>
                <select
                  value={entityTypeToLink ?? "None"}
                  onChange={handleEntityTypeChange}
                  style={{ width: "100%", padding: "4px" }}>
                  <option value="None">-- Select Entity Type --</option>
                  <option value="Contact">Contact (by Email)</option>
                  <option value="Event">Event (by Name)</option>
                  <option value="Vendor">Vendor (by Name)</option>
                </select>
              </div>
              {entityTypeToLink && (
                <div style={{ marginBottom: "0.5rem" }}>
                  <label style={{ display: "block" }}>Lookup Value:</label>
                  <input
                    type={entityTypeToLink === "Contact" ? "email" : "text"}
                    value={linkValue}
                    onChange={handleLinkValueChange}
                    placeholder={getLinkPlaceholder()}
                    style={{ width: "100%" }}
                  />
                </div>
              )}
            </div>
          )}

          {/* --- LEGACY GUID INPUTS (Hidden on Create, Used on Edit) --- */}
          {/* On Edit mode, we submit the existing GUIDs. */}
          {/* NOTE: We only display the GUIDs on edit if you need to change the parent via GUID */}
          {isEditing && (
            <>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Contact ID (Optional): </label>
                <input
                  name="contactId"
                  value={formData.contactId ?? ""}
                  onChange={handleChange}
                />
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Event ID (Optional): </label>
                <input
                  name="eventId"
                  value={formData.eventId ?? ""}
                  onChange={handleChange}
                />
              </div>
              <div style={{ marginBottom: "0.5rem" }}>
                <label>Vendor ID (Optional): </label>
                <input
                  name="vendorId"
                  value={formData.vendorId ?? ""}
                  onChange={handleChange}
                />
              </div>
            </>
          )}
          {/* ---------------------------------------------------- */}

          {validationErrors.General && (
            <div style={{ color: "red", marginTop: "1rem" }}>
              {validationErrors.General[0]}
            </div>
          )}

          <button type="submit">{isEditing ? "Save Changes" : "Create"}</button>
          {isEditing && (
            <button
              type="button"
              onClick={handleCancel}
              style={{ marginLeft: "0.5rem" }}>
              Cancel
            </button>
          )}
        </form>
      </div>

      <h2>Tasks List</h2>
      {loading ? (
        <p>Loading Tasks...</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Title</th>
              <th>Status</th>
              <th>Priority</th>
              <th>Due Date</th>
              <th>Vendor</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {tasks.map((task) => (
              <tr key={task.id}>
                <td>{task.id}</td>
                <td>{task.title}</td>
                <td>{task.status}</td>
                <td>{task.priority}</td>
                <td>
                  {task.dueDate
                    ? new Date(task.dueDate).toLocaleDateString()
                    : "N/A"}
                </td>
                <td>{task.vendorName ?? "N/A"}</td>
                <td>
                  <button
                    onClick={() => handleEdit(task)}
                    style={{ color: "blue" }}>
                    Edit
                  </button>
                  <button
                    onClick={() => handleDelete(task.id)}
                    style={{ color: "red", marginLeft: "0.5rem" }}>
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

export default TasksPage;


// ==========================================
// FILE: frontend_harness/src/components/RelatedTables.tsx 
// ==========================================
import { useEffect, useState } from "react";
import { useSelectionContext } from "../context/useSelectionContext";
import { apiClient } from "../apiClient";
import type {
  TaskDto,
  NoteDto,
  EventDto,
  ContactDto,
  Guid,
  EmailLogDto,
} from "../types";

// Add vendorId to the props of the related tables
interface RelatedTableProps {
  contactId?: Guid | null;
  eventId?: Guid | null;
  vendorId?: Guid | null;
}

// --- Utility function to determine the API path and selection ID ---
const getApiContext = (
  props: RelatedTableProps,
  selectedContactId: Guid | null,
  selectedEventId: Guid | null,
  resource: "tasks" | "notes"
) => {
  // 1. Check for explicit props (used by Command Centers)
  if (props.vendorId) {
    return {
      id: props.vendorId,
      url: `/api/${resource}?vendorId=${props.vendorId}`,
      label: "Vendor",
    };
  }
  if (props.contactId) {
    return {
      id: props.contactId,
      url: `/api/${resource}?contactId=${props.contactId}`,
      label: "Contact",
    };
  }
  if (props.eventId) {
    return {
      id: props.eventId,
      url: `/api/${resource}?eventId=${props.eventId}`,
      label: "Event",
    };
  }

  // 2. Fall back to context (used by old pages/global lists)
  if (selectedContactId) {
    return {
      id: selectedContactId,
      url: `/api/${resource}?contactId=${selectedContactId}`,
      label: "Contact",
    };
  }
  if (selectedEventId) {
    return {
      id: selectedEventId,
      url: `/api/${resource}?eventId=${selectedEventId}`,
      label: "Event",
    };
  }
  return { id: null, url: null, label: null };
};

// --- 1. RelatedTasks ---
export function RelatedTasks(props: RelatedTableProps) {
  const { selectedContactId, selectedEventId } = useSelectionContext();
  const [tasks, setTasks] = useState<TaskDto[]>([]);
  const [loading, setLoading] = useState(false);

  const context = getApiContext(
    props,
    selectedContactId,
    selectedEventId,
    "tasks"
  );
  const selectedId = context.id;
  const apiUrl = context.url;
  const contextLabel = context.label;

  useEffect(() => {
    if (!selectedId || !apiUrl) {
      setTasks([]);
      return;
    }

    const fetchTasks = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<TaskDto[]>(apiUrl);
        setTasks(response.data);
      } catch (err) {
        console.error("Failed to fetch related tasks:", err);
      } finally {
        setLoading(false);
      }
    };

    fetchTasks();
  }, [selectedId, apiUrl]);

  if (!selectedId) return null;
  if (loading) return <p>Loading related tasks...</p>;

  const safeContextLabel = contextLabel as string;

  return (
    <div style={{ marginTop: "2rem" }}>
      {/* FIX: Show Full ID */}
      <h3>
        Related Tasks (for {safeContextLabel} ID: {selectedId})
      </h3>
      {tasks.length === 0 ? (
        <p>No tasks found for this {safeContextLabel.toLowerCase()}.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Title</th>
              <th>Status</th>
              <th>Due Date</th>
              <th>Linked Vendor</th> {/* NEW COLUMN HEADER */}
              <th>Linked Contact</th> {/* NEW COLUMN HEADER */}
              <th>Linked Event</th> {/* NEW COLUMN HEADER */}
            </tr>
          </thead>
          <tbody>
            {tasks.map((task) => (
              <tr key={task.id}>
                {/* FIX: Show Full ID (Shortened for space) */}
                <td>{task.id.substring(0, 8)}...</td>
                <td>{task.title}</td>
                <td>{task.status}</td>
                <td>
                  {task.dueDate
                    ? new Date(task.dueDate).toLocaleDateString()
                    : "N/A"}
                </td>
                {/* PHASE 28: Vendor Granularity */}
                <td>
                  {task.vendorName ??
                    (task.vendorId
                      ? `ID: ${task.vendorId.substring(0, 8)}...`
                      : "N/A")}
                </td>
                {/* PHASE 28: Contact/Event Granularity */}
                <td>
                  {task.contactId
                    ? `ID: ${task.contactId.substring(0, 8)}...`
                    : "N/A"}
                </td>
                <td>
                  {task.eventId
                    ? `ID: ${task.eventId.substring(0, 8)}...`
                    : "N/A"}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

// --- 2. RelatedNotes ---
export function RelatedNotes(props: RelatedTableProps) {
  const { selectedContactId, selectedEventId } = useSelectionContext();
  const [notes, setNotes] = useState<NoteDto[]>([]);
  const [loading, setLoading] = useState(false);

  const context = getApiContext(
    props,
    selectedContactId,
    selectedEventId,
    "notes"
  );
  const selectedId = context.id;
  const apiUrl = context.url;
  const contextLabel = context.label;

  useEffect(() => {
    if (!selectedId || !apiUrl) {
      setNotes([]);
      return;
    }

    const fetchNotes = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<NoteDto[]>(apiUrl);
        setNotes(response.data);
      } catch (err) {
        console.error("Failed to fetch related notes:", err);
      } finally {
        setLoading(false);
      }
    };

    fetchNotes();
  }, [selectedId, apiUrl]);

  if (!selectedId) return null;
  if (loading) return <p>Loading related notes...</p>;

  const safeContextLabel = contextLabel as string;

  return (
    <div style={{ marginTop: "2rem" }}>
      {/* FIX: Show Full ID */}
      <h3>
        Related Notes (for {safeContextLabel} ID: {selectedId})
      </h3>
      {notes.length === 0 ? (
        <p>No notes found for this {safeContextLabel.toLowerCase()}.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Content</th>
              <th>Linked Vendor</th> {/* NEW COLUMN HEADER */}
              <th>Linked Contact</th> {/* NEW COLUMN HEADER */}
              <th>Linked Event</th> {/* NEW COLUMN HEADER */}
            </tr>
          </thead>
          <tbody>
            {notes.map((note) => (
              <tr key={note.id}>
                {/* FIX: Show Full ID (Shortened for space) */}
                <td>{note.id.substring(0, 8)}...</td>
                <td>{note.content}</td>
                {/* PHASE 28: Vendor Granularity */}
                <td>
                  {note.vendorName ??
                    (note.vendorId
                      ? `ID: ${note.vendorId.substring(0, 8)}...`
                      : "N/A")}
                </td>
                {/* PHASE 28: Contact/Event Granularity */}
                <td>
                  {note.contactId
                    ? `ID: ${note.contactId.substring(0, 8)}...`
                    : "N/A"}
                </td>
                <td>
                  {note.eventId
                    ? `ID: ${note.eventId.substring(0, 8)}...`
                    : "N/A"}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

// --- 3. ContactEventsTable ---
export function ContactEventsTable() {
  const { selectedContactId } = useSelectionContext();
  const [events, setEvents] = useState<EventDto[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (!selectedContactId) {
      setEvents([]);
      return;
    }

    const fetchEvents = async () => {
      setLoading(true);
      try {
        const response = await apiClient.get<EventDto[]>(
          `/api/contacts/${selectedContactId}/events`
        );
        setEvents(response.data);
      } catch (err) {
        console.error("Failed to fetch contact's events:", err);
      } finally {
        setLoading(false);
      }
    };

    fetchEvents();
  }, [selectedContactId]);

  if (!selectedContactId) return null;
  if (loading) return <p>Loading related events...</p>;

  return (
    <div style={{ marginTop: "2rem" }}>
      {/* FIX: Show Full ID */}
      <h3>Related Events (for Contact ID: {selectedContactId})</h3>
      {events.length === 0 ? (
        <p>No events found linked to this contact.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>Name</th>
              <th>Status</th>
              <th>Start</th>
              <th>Location</th>
            </tr>
          </thead>
          <tbody>
            {events.map((event) => (
              <tr key={event.id}>
                {/* FIX: Show Full ID */}
                <td>{event.id}</td>
                <td>{event.name}</td>
                <td>{event.status}</td>
                <td>{new Date(event.startDateTime).toLocaleString()}</td>
                <td>{event.location ?? "N/A"}</td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

// --- 4. EventParticipantsTable ---
interface EventParticipantsTableProps {
  onUnlinkSuccess: () => void;
}

export function EventParticipantsTable({
  onUnlinkSuccess,
}: EventParticipantsTableProps) {
  const { selectedEventId } = useSelectionContext();
  const [contacts, setContacts] = useState<ContactDto[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    const fetchContacts = async () => {
      if (!selectedEventId) {
        setContacts([]);
        return;
      }
      setLoading(true);
      try {
        const response = await apiClient.get<ContactDto[]>(
          `/api/events/${selectedEventId}/contacts`
        );
        setContacts(response.data);
      } catch (err) {
        console.error("Failed to fetch event participants:", err);
      } finally {
        setLoading(false);
      }
    };

    fetchContacts();
  }, [selectedEventId]);

  const handleUnlink = async (contactId: string) => {
    if (!selectedEventId) return;
    if (
      !window.confirm(
        "Are you sure you want to remove this contact from the event?"
      )
    )
      return;

    try {
      await apiClient.delete(
        `/api/events/${selectedEventId}/contacts/${contactId}`
      );
      onUnlinkSuccess();
    } catch (err) {
      console.error("Failed to unlink contact:", err);
      alert("Failed to unlink contact.");
    }
  };

  if (!selectedEventId) return null;
  if (loading) return <p>Loading event participants...</p>;

  return (
    <div style={{ marginTop: "2rem" }}>
      <h3>Event Participants (Staff/Guests)</h3>
      {contacts.length === 0 ? (
        <p>No participants linked to this event.</p>
      ) : (
        <table border={1} cellPadding={5} style={{ width: "100%" }}>
          <thead>
            <tr>
              <th>ID</th>
              <th>First Name</th>
              <th>Last Name</th>
              <th>Email</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {contacts.map((contact) => (
              <tr key={contact.id}>
                {/* FIX: Show Full ID */}
                <td>{contact.id}</td>
                <td>{contact.firstName}</td>
                <td>{contact.lastName}</td>
                <td>{contact.email}</td>
                <td>
                  <button
                    onClick={() => handleUnlink(contact.id)}
                    style={{ color: "red", cursor: "pointer" }}>
                    Unlink
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

// --- 5. EmailHistoryTable ---
export function EmailHistoryTable() {
  const { selectedContactId } = useSelectionContext();
  const [logs, setLogs] = useState<EmailLogDto[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (!selectedContactId) {
      setLogs([]);
      return;
    }

    const fetchLogs = async () => {
      setLoading(true);
      try {
        const res = await apiClient.get<EmailLogDto[]>(
          `/api/contacts/${selectedContactId}/email-logs`
        );
        setLogs(res.data);
      } catch (err) {
        console.error("Failed to fetch email logs", err);
      } finally {
        setLoading(false);
      }
    };

    fetchLogs();
  }, [selectedContactId]);

  if (!selectedContactId) return null;

  return (
    <div style={{ marginTop: "2rem" }}>
      <h3>Email History (for Contact ID: {selectedContactId})</h3>
      {loading ? (
        <p>Loading logs...</p>
      ) : logs.length === 0 ? (
        <p>No emails sent to this contact.</p>
      ) : (
        <table
          border={1}
          cellPadding={5}
          style={{ width: "100%", borderCollapse: "collapse" }}>
          <thead>
            <tr style={{ background: "#333", color: "#fff" }}>
              <th>Subject</th>
              <th>Sent At</th>
              <th>Status</th>
              <th>Message</th>
            </tr>
          </thead>
          <tbody>
            {logs.map((log) => (
              <tr key={log.id}>
                <td>{log.subject}</td>
                <td>{new Date(log.sentAt).toLocaleString()}</td>
                <td
                  style={{
                    color: log.isSuccess ? "lightgreen" : "#ff6b6b",
                    fontWeight: "bold",
                  }}>
                  {log.isSuccess ? "Success" : "Failed"}
                </td>
                <td
                  style={{
                    maxWidth: "300px",
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    whiteSpace: "nowrap",
                  }}>
                  {log.errorMessage ? log.errorMessage : "Sent via SendGrid"}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

export default function RelatedTables() {
  return (
    <div>
      <RelatedTasks />
      <RelatedNotes />
    </div>
  );
}


// ==========================================
// FILE: frontend_harness/src/components/DashboardPage.tsx 
// ==========================================
// FILE: frontend_harness/src/components/DashboardPage.tsx

import { useEffect, useState, useCallback } from "react";
import {
  apiClient,
  submitLead,
  updateContact,
  deleteContact as deleteContactClient,
  initializeTestFixtures,
} from "../apiClient";
import { SendEmailModal } from "./SendEmailModal";
import type {
  DashboardStatsDto,
  ContactDto,
  VendorDto,
  EventDto,
} from "../types";

// --- INTERFACES ---

interface TestExecutionPanelProps {
  contacts: ContactDto[];
  logTestResult: (
    message: string,
    level: "PASS" | "FAIL" | "INFO" | "WARN"
  ) => void;
  onSeedDatabase: () => Promise<void>;
}

// --- COMPONENT: Test Execution Panel ---

const TestExecutionPanel: React.FC<TestExecutionPanelProps> = ({
  contacts,
  logTestResult,
  onSeedDatabase,
}) => {
  const [manualContactId, setManualContactId] = useState("");
  const [manualTemplateId, setManualTemplateId] = useState("");

  const executeLiveEmail = async () => {
    if (!manualContactId || !manualTemplateId) {
      alert("Please enter both Contact ID and Template ID.");
      return;
    }

    logTestResult(
      `Attempting to send Email to Contact: ${manualContactId}...`,
      "INFO"
    );

    try {
      await apiClient.post("/api/templates/send-email", {
        contactId: manualContactId,
        templateId: manualTemplateId,
      });
      logTestResult("SUCCESS: Email request sent to SendGrid.", "PASS");
      alert("Email Queued Successfully!");
    } catch (e: unknown) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      logTestResult(`FAILED: Could not send email. Error: ${errorMsg}`, "FAIL");
    }
  };

  const executeLiveSms = async () => {
    if (!manualContactId || !manualTemplateId) {
      alert("Please enter both Contact ID and Template ID.");
      return;
    }

    logTestResult(
      `Attempting to send SMS to Contact: ${manualContactId}...`,
      "INFO"
    );

    try {
      await apiClient.post("/api/automation/send-sms", {
        contactId: manualContactId,
        templateId: manualTemplateId,
      });
      logTestResult("SUCCESS: SMS request sent to Twilio.", "PASS");
      alert("SMS Queued Successfully! Check your phone.");
    } catch (e: unknown) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      logTestResult(`FAILED: Could not send SMS. Error: ${errorMsg}`, "FAIL");
    }
  };

  const runSystemTests = useCallback(async () => {
    const output = document.getElementById("test-log-output");
    if (output) output.innerHTML = "";

    logTestResult("Starting System Integrity Check...", "INFO");

    if (contacts.length === 0) {
      logTestResult(
        "ABORT: No contacts found. Please run 'Seed Database' first.",
        "WARN"
      );
      return;
    }

    const testContact = contacts[0];

    // A. Lead Submission
    try {
      const leadId = await submitLead({
        firstName: "Auto",
        lastName: "Lead",
        email: `auto_lead_${Date.now()}@test.com`,
        source: "Dashboard Test Harness",
        phoneNumber: null,
        organization: null,
      });
      logTestResult(
        `POST /leads/submit: PASS. Created ID: ${leadId.substring(0, 8)}...`,
        "PASS"
      );

      await deleteContactClient(leadId);
      logTestResult(`DELETE /contacts: PASS. Cleaned up test lead.`, "PASS");
    } catch (e: unknown) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      logTestResult(`Lead Flow FAILED: ${errorMsg}`, "FAIL");
    }

    // B. Update Contact
    try {
      await updateContact(testContact.id, {
        ...testContact,
        lastName: "UpdatedByTest",
      });
      logTestResult(
        `PUT /contacts: PASS. Updated Contact ${testContact.id.substring(
          0,
          8
        )}.`,
        "PASS"
      );
    } catch (e: unknown) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      logTestResult(`Contact Update FAILED: ${errorMsg}`, "FAIL");
    }

    logTestResult("System Integrity Check Complete.", "INFO");
  }, [contacts, logTestResult]);

  return (
    <div className="mt-8 p-6 border border-gray-700 rounded-xl bg-gray-900 shadow-2xl">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-xl font-bold text-white flex items-center gap-2">
          <span className="w-3 h-3 bg-green-500 rounded-full animate-pulse"></span>
          API Test Lab
        </h2>
        <span className="text-xs font-mono text-gray-500">v48.0.6</span>
      </div>

      <div className="bg-gray-800 p-4 rounded-lg mb-6 border border-gray-700">
        <h3 className="text-sm font-bold text-blue-400 uppercase tracking-wider mb-4">
          Live Communication Lab
        </h3>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
          <div>
            <label className="block text-xs text-gray-400 mb-1">
              Target Contact ID (UUID)
            </label>
            <input
              value={manualContactId}
              onChange={(e) => setManualContactId(e.target.value)}
              placeholder="e.g. 3fa85f64-..."
              className="w-full bg-gray-900 border border-gray-600 rounded p-2 text-sm text-white font-mono focus:border-blue-500 outline-none"
            />
          </div>
          <div>
            <label className="block text-xs text-gray-400 mb-1">
              Template ID (UUID)
            </label>
            <input
              value={manualTemplateId}
              onChange={(e) => setManualTemplateId(e.target.value)}
              placeholder="e.g. 8efe1c11-..."
              className="w-full bg-gray-900 border border-gray-600 rounded p-2 text-sm text-white font-mono focus:border-purple-500 outline-none"
            />
          </div>
        </div>

        <div className="flex gap-3">
          <button
            onClick={executeLiveEmail}
            className="flex-1 bg-indigo-600 hover:bg-indigo-500 text-white py-2 rounded font-medium transition-colors text-sm">
            Test Real Email
          </button>
          <button
            onClick={executeLiveSms}
            className="flex-1 bg-green-600 hover:bg-green-500 text-white py-2 rounded font-medium transition-colors text-sm">
            Test Real SMS
          </button>
        </div>
      </div>

      <div className="flex gap-4 mb-4">
        <button
          onClick={onSeedDatabase}
          className="flex-1 bg-gray-700 hover:bg-gray-600 text-blue-300 py-2 rounded font-medium transition-colors text-sm border border-gray-600">
          Seed Database (Fixtures)
        </button>

        <button
          onClick={runSystemTests}
          className="flex-1 bg-gray-700 hover:bg-gray-600 text-gray-200 py-2 rounded font-medium transition-colors text-sm border border-gray-600">
          Run CRUD Integrity Suite
        </button>
      </div>

      <div className="bg-black rounded-lg p-3 border border-gray-800">
        <h4 className="text-gray-500 text-[10px] font-bold uppercase mb-2">
          Execution Log:
        </h4>
        <div
          id="test-log-output"
          className="h-32 overflow-y-auto font-mono text-xs space-y-1 text-gray-300"></div>
      </div>
    </div>
  );
};

// --- MAIN PAGE COMPONENT ---

export default function DashboardPage() {
  const [stats, setStats] = useState<DashboardStatsDto | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");

  const [isEmailModalOpen, setIsEmailModalOpen] = useState(false);
  const [contacts, setContacts] = useState<ContactDto[]>([]);
  const [vendors, setVendors] = useState<VendorDto[]>([]);

  const logTestResult = useCallback(
    (message: string, level: "PASS" | "FAIL" | "INFO" | "WARN") => {
      let color = "#e5e7eb";
      if (level === "PASS") color = "#4ade80";
      if (level === "FAIL") color = "#f87171";
      if (level === "WARN") color = "#fbbf24";

      const logEntry = `<div style="color: ${color}; margin-bottom: 2px;">
      <span style="opacity: 0.5;">[${new Date().toLocaleTimeString()}]</span> 
      <strong>${level}:</strong> ${message}
    </div>`;

      const output = document.getElementById("test-log-output");
      if (output) {
        output.innerHTML += logEntry;
        output.scrollTop = output.scrollHeight;
      }
    },
    []
  );

  // FIXED: Removed synchronous setLoading(true) from the top.
  // We rely on 'loading' being initialized to true for the first run.
  const fetchDashboardData = useCallback(async () => {
    try {
      const [statsRes, contactsRes, vendorsRes] = await Promise.all([
        apiClient.get<DashboardStatsDto>("/api/dashboard"),
        apiClient.get<ContactDto[]>("/api/contacts"),
        apiClient.get<VendorDto[]>("/api/vendors"),
      ]);

      setStats(statsRes.data);
      setContacts(contactsRes.data);
      setVendors(vendorsRes.data);
    } catch (err: unknown) {
      console.error(err);
      setError("Dashboard failed to load. Ensure backend is running.");
    } finally {
      // Ensuring loading is turned off after fetch completes
      setLoading(false);
    }
  }, []);

  const handleSeedDatabase = async () => {
    logTestResult("Seeding Database with Fixtures...", "INFO");

    // FIXED: Manually set loading here for user feedback during manual seed
    setLoading(true);

    try {
      await initializeTestFixtures();
      logTestResult("Fixtures Initialized Successfully.", "PASS");
      await fetchDashboardData();
    } catch {
      logTestResult("Failed to seed database.", "FAIL");
      setLoading(false); // Ensure loading turns off on failure
    }
  };

  useEffect(() => {
    fetchDashboardData();
  }, [fetchDashboardData]);

  if (loading)
    return (
      <div className="min-h-screen flex items-center justify-center text-gray-500 animate-pulse">
        Loading Command Center...
      </div>
    );

  if (error)
    return (
      <div className="p-8 m-8 bg-red-900/20 border border-red-800 text-red-200 rounded-lg">
        <h3 className="font-bold">Connection Error</h3>
        <p>{error}</p>
      </div>
    );

  if (!stats) return null;

  return (
    <div className="space-y-8 pb-10 max-w-7xl mx-auto px-4 sm:px-6">
      <TestExecutionPanel
        contacts={contacts}
        logTestResult={logTestResult}
        onSeedDatabase={handleSeedDatabase}
      />

      <div className="flex flex-col sm:flex-row justify-between items-end border-b border-gray-800 pb-6 gap-4">
        <div>
          <h1 className="text-4xl font-extrabold text-white tracking-tight">
            Command Center
          </h1>
          <p className="text-gray-400 mt-1">
            LCD Entertainment System Overview
          </p>
        </div>
        <div className="text-right">
          <div className="inline-flex items-center px-3 py-1 rounded-full bg-green-900/30 border border-green-800 text-green-400 text-xs font-bold uppercase tracking-wide">
            Phase 48: Active
          </div>
        </div>
      </div>

      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
        <StatCard
          label="Total Contacts"
          value={stats.totalContacts}
          color="border-blue-500"
        />
        <StatCard
          label="Active Events"
          value={stats.activeEvents}
          color="border-purple-500"
        />
        <StatCard
          label="Pending Tasks"
          value={stats.pendingTasks}
          color="border-yellow-500"
        />
        <StatCard
          label="Recent Emails"
          value={stats.recentEmails}
          color="border-green-500"
        />
      </div>

      <div className="bg-gray-800 rounded-2xl border border-gray-700 shadow-xl overflow-hidden">
        <div className="p-6 border-b border-gray-700 bg-gray-800/50">
          <h2 className="text-xl font-bold text-white">Upcoming Schedule</h2>
        </div>
        <div className="divide-y divide-gray-700">
          {stats.upcomingEvents.length === 0 ? (
            <div className="p-8 text-center text-gray-500 italic">
              No events scheduled.
            </div>
          ) : (
            stats.upcomingEvents.map((evt: EventDto) => (
              <div
                key={evt.id}
                className="p-6 flex flex-col sm:flex-row items-start sm:items-center gap-6 hover:bg-gray-700/30 transition-all">
                <div className="bg-gray-900 w-16 h-16 rounded-xl border border-gray-600 flex flex-col items-center justify-center flex-shrink-0">
                  <span className="text-[10px] text-gray-400 uppercase font-black">
                    {new Date(evt.startDateTime).toLocaleString("default", {
                      month: "short",
                    })}
                  </span>
                  <span className="text-2xl font-black text-white">
                    {new Date(evt.startDateTime).getDate()}
                  </span>
                </div>

                <div className="flex-grow">
                  <h3 className="text-lg font-bold text-white">{evt.name}</h3>
                  <div className="flex flex-wrap gap-4 mt-1 text-sm text-gray-400">
                    <span className="flex items-center gap-1">
                      <span>ðŸ“</span> {evt.location || "TBD"}
                    </span>
                    <span className="flex items-center gap-1">
                      <span>ðŸ•’</span>{" "}
                      {new Date(evt.startDateTime).toLocaleTimeString([], {
                        hour: "2-digit",
                        minute: "2-digit",
                      })}
                    </span>
                  </div>
                </div>

                <button
                  onClick={() => setIsEmailModalOpen(true)}
                  className="w-full sm:w-auto bg-gray-900 hover:bg-blue-600 border border-gray-600 hover:border-blue-500 text-gray-300 hover:text-white px-4 py-2 rounded-lg text-sm font-bold transition-all shadow-sm">
                  Send Comms
                </button>
              </div>
            ))
          )}
        </div>
      </div>

      <SendEmailModal
        isOpen={isEmailModalOpen}
        onClose={() => setIsEmailModalOpen(false)}
        availableContacts={contacts}
        availableVendors={vendors}
      />
    </div>
  );
}

function StatCard({
  label,
  value,
  color,
}: {
  label: string;
  value: number;
  color: string;
}) {
  return (
    <div
      className={`bg-gray-800 p-6 rounded-2xl border-b-4 ${color} shadow-lg transition-transform hover:scale-[1.02]`}>
      <p className="text-gray-400 text-xs font-black uppercase mb-1 tracking-widest">
        {label}
      </p>
      <p className="text-4xl font-black text-white">{value}</p>
    </div>
  );
}


// ==========================================
// FILE: frontend_harness/src/apiClient.ts 
// ==========================================
// FILE: frontend_harness/src/apiClient.ts (COMPLETE REPLACEMENT)
import axios from 'axios';
import { 
  type EventFinancialsDto, 
  type SendTemplateEmailCommand,
  type TemplateDto, 
  type ContactDto,
  type VendorDto,
  type EventDto,
  type TaskDto,
  type NoteDto,
  type EmailLogDto,
  type SubmitLeadCommand,
  RecipientType,
} from './types';

// Define the base URL of your local API
const API_BASE_URL = 'http://localhost:5179';

export const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// =======================================================
// CORE SERVICES
// =======================================================

// --- DOCUMENT SERVICES ---

export const uploadDocument = async (
  file: File, 
  relatedEntityId: string, 
  relatedEntityType: string,
  category: string
): Promise<Document> => {
  const formData = new FormData();
  formData.append('file', file);
  formData.append('relatedEntityId', relatedEntityId);
  formData.append('relatedEntityType', relatedEntityType);
  formData.append('category', category);

  const response = await apiClient.post<Document>('/api/documents', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  });
  return response.data;
};

export const deleteDocument = async (id: number): Promise<void> => {
  await apiClient.delete(`/api/documents/${id}`);
};

// --- FINANCIALS SERVICES ---

export const getEventFinancials = async (eventId: string): Promise<EventFinancialsDto> => {
  const response = await apiClient.get<EventFinancialsDto>(`/api/events/${eventId}/financials`);
  return response.data;
};

export const upsertBudget = async (
  eventId: string, 
  totalAmount: number, 
  currency: string, 
  notes?: string
): Promise<string> => {
  const payload = { eventId, totalAmount, currency, notes };
  const response = await apiClient.post<string>(`/api/events/${eventId}/financials/budget`, payload);
  return response.data;
};

export const addExpense = async (
  eventId: string,
  description: string,
  amount: number,
  dateIncurred: string, // ISO String
  category: string,
  vendorId?: string,
  linkedDocumentId?: number
): Promise<string> => {
  const payload = { eventId, description, amount, dateIncurred, category, vendorId, linkedDocumentId };
  const response = await apiClient.post<string>(`/api/events/${eventId}/financials/expenses`, payload);
  return response.data;
};


// --- TEMPLATE SERVICES ---

export const templates = {
  getAll: async () => {
    const response = await apiClient.get<TemplateDto[]>('/api/templates');
    return response.data;
  },
  create: async (data: unknown) => {
    const response = await apiClient.post<string>('/api/templates', data);
    return response.data;
  },
  sendEmail: async (command: SendTemplateEmailCommand) => {
    // Uses POST /api/templates/send
    await apiClient.post('/api/templates/send', command);
  }
};

/**
 * Initializes required contacts, vendors, and events for testing.
 * @returns The ID of the primary contact created.
 */
export const initializeTestFixtures = async (): Promise<string> => {
  const response = await apiClient.post<string>('/api/contacts/init-fixtures');
  return response.data;
};

// =======================================================
// FULL CRUD IMPLEMENTATION (PHASE 31)
// =======================================================

// --- CONTACTS CRUD & RELATIONS ---

export const updateContact = async (id: string, data: Partial<ContactDto>): Promise<void> => {
  await apiClient.put(`/api/contacts/${id}`, data);
};

export const deleteContact = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/contacts/${id}`);
};

export const getContactEmailLogs = async (contactId: string): Promise<EmailLogDto[]> => {
  const response = await apiClient.get<EmailLogDto[]>(`/api/contacts/${contactId}/email-logs`);
  return response.data;
};

// --- EVENTS CRUD & RELATIONS ---

export const updateEvent = async (id: string, data: Partial<EventDto>): Promise<void> => {
  await apiClient.put(`/api/events/${id}`, data);
};

export const deleteEvent = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/events/${id}`);
};

export const unlinkContactFromEvent = async (eventId: string, contactId: string): Promise<void> => {
  await apiClient.delete(`/api/events/${eventId}/contacts/${contactId}`);
};


// --- VENDORS CRUD ---

export const updateVendor = async (id: string, data: Partial<VendorDto>): Promise<void> => {
  await apiClient.put(`/api/vendors/${id}`, data);
};

export const deleteVendor = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/vendors/${id}`);
};


// --- TASKS CRUD ---
// (TasksController only has Create/Update/Delete - Reads are handled via GetTasksQuery)
export const updateTask = async (id: string, data: Partial<TaskDto>): Promise<void> => {
  await apiClient.put(`/api/tasks/${id}`, data);
};

export const deleteTask = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/tasks/${id}`);
};


// --- NOTES CRUD ---
// (NotesController only has Update/Delete - Create returns DTO)
export const updateNote = async (id: string, data: Partial<NoteDto>): Promise<void> => {
  // NOTE: Notes only allow updating 'content' per the business logic
  await apiClient.put(`/api/notes/${id}`, data); 
};

export const deleteNote = async (id: string): Promise<void> => {
  await apiClient.delete(`/api/notes/${id}`);
};


// --- AUTOMATION & LEADS ---

export const submitLead = async (command: SubmitLeadCommand): Promise<string> => {
  const response = await apiClient.post<string>('/api/leads/submit', command);
  return response.data;
};

export const scheduleFollowUp = async (
  contactId: string, 
  templateId: string, 
  scheduleTime: string, // ISO String
  type: RecipientType = RecipientType.Contact
): Promise<string> => {
  const payload = { contactId, templateId, scheduleTime, type };
  const response = await apiClient.post<string>('/api/automation/schedule-followup', payload);
  return response.data;
};

// FIXED: Interface matches Backend expectation of 'TemplateContent'
export interface ScheduleEmailCommand {
  contact: ContactDto;
  templateId?: string;
  subject: string;
  templateContent: string; // RENAMED from 'body' to match backend property
  scheduleTime: string;
}

export const scheduleEmail = async (command: ScheduleEmailCommand): Promise<void> => {
  // DIAGNOSTIC LOG (You can remove this later)
  console.log("ðŸš€ SENDING PAYLOAD:", JSON.stringify(command, null, 2)); 
  await apiClient.post('/api/automation/schedule-email', command);
};